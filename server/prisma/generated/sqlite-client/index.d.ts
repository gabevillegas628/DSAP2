
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model School
 * 
 */
export type School = $Result.DefaultSelection<Prisma.$SchoolPayload>
/**
 * Model ProgramSettings
 * 
 */
export type ProgramSettings = $Result.DefaultSelection<Prisma.$ProgramSettingsPayload>
/**
 * Model Demographics
 * 
 */
export type Demographics = $Result.DefaultSelection<Prisma.$DemographicsPayload>
/**
 * Model LoginLog
 * 
 */
export type LoginLog = $Result.DefaultSelection<Prisma.$LoginLogPayload>
/**
 * Model AnalysisQuestion
 * 
 */
export type AnalysisQuestion = $Result.DefaultSelection<Prisma.$AnalysisQuestionPayload>
/**
 * Model CommonFeedback
 * 
 */
export type CommonFeedback = $Result.DefaultSelection<Prisma.$CommonFeedbackPayload>
/**
 * Model UploadedFile
 * 
 */
export type UploadedFile = $Result.DefaultSelection<Prisma.$UploadedFilePayload>
/**
 * Model CloneDiscussion
 * 
 */
export type CloneDiscussion = $Result.DefaultSelection<Prisma.$CloneDiscussionPayload>
/**
 * Model DiscussionMessage
 * 
 */
export type DiscussionMessage = $Result.DefaultSelection<Prisma.$DiscussionMessagePayload>
/**
 * Model Message
 * 
 */
export type Message = $Result.DefaultSelection<Prisma.$MessagePayload>
/**
 * Model PracticeClone
 * 
 */
export type PracticeClone = $Result.DefaultSelection<Prisma.$PracticeClonePayload>
/**
 * Model PracticeAnswer
 * 
 */
export type PracticeAnswer = $Result.DefaultSelection<Prisma.$PracticeAnswerPayload>
/**
 * Model UserPracticeProgress
 * 
 */
export type UserPracticeProgress = $Result.DefaultSelection<Prisma.$UserPracticeProgressPayload>
/**
 * Model HelpTopic
 * 
 */
export type HelpTopic = $Result.DefaultSelection<Prisma.$HelpTopicPayload>
/**
 * Model StepHelp
 * 
 */
export type StepHelp = $Result.DefaultSelection<Prisma.$StepHelpPayload>

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  const U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.school`: Exposes CRUD operations for the **School** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Schools
    * const schools = await prisma.school.findMany()
    * ```
    */
  get school(): Prisma.SchoolDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.programSettings`: Exposes CRUD operations for the **ProgramSettings** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProgramSettings
    * const programSettings = await prisma.programSettings.findMany()
    * ```
    */
  get programSettings(): Prisma.ProgramSettingsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.demographics`: Exposes CRUD operations for the **Demographics** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Demographics
    * const demographics = await prisma.demographics.findMany()
    * ```
    */
  get demographics(): Prisma.DemographicsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.loginLog`: Exposes CRUD operations for the **LoginLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LoginLogs
    * const loginLogs = await prisma.loginLog.findMany()
    * ```
    */
  get loginLog(): Prisma.LoginLogDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.analysisQuestion`: Exposes CRUD operations for the **AnalysisQuestion** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AnalysisQuestions
    * const analysisQuestions = await prisma.analysisQuestion.findMany()
    * ```
    */
  get analysisQuestion(): Prisma.AnalysisQuestionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.commonFeedback`: Exposes CRUD operations for the **CommonFeedback** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CommonFeedbacks
    * const commonFeedbacks = await prisma.commonFeedback.findMany()
    * ```
    */
  get commonFeedback(): Prisma.CommonFeedbackDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.uploadedFile`: Exposes CRUD operations for the **UploadedFile** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UploadedFiles
    * const uploadedFiles = await prisma.uploadedFile.findMany()
    * ```
    */
  get uploadedFile(): Prisma.UploadedFileDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.cloneDiscussion`: Exposes CRUD operations for the **CloneDiscussion** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CloneDiscussions
    * const cloneDiscussions = await prisma.cloneDiscussion.findMany()
    * ```
    */
  get cloneDiscussion(): Prisma.CloneDiscussionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.discussionMessage`: Exposes CRUD operations for the **DiscussionMessage** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DiscussionMessages
    * const discussionMessages = await prisma.discussionMessage.findMany()
    * ```
    */
  get discussionMessage(): Prisma.DiscussionMessageDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.message`: Exposes CRUD operations for the **Message** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Messages
    * const messages = await prisma.message.findMany()
    * ```
    */
  get message(): Prisma.MessageDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.practiceClone`: Exposes CRUD operations for the **PracticeClone** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PracticeClones
    * const practiceClones = await prisma.practiceClone.findMany()
    * ```
    */
  get practiceClone(): Prisma.PracticeCloneDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.practiceAnswer`: Exposes CRUD operations for the **PracticeAnswer** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PracticeAnswers
    * const practiceAnswers = await prisma.practiceAnswer.findMany()
    * ```
    */
  get practiceAnswer(): Prisma.PracticeAnswerDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.userPracticeProgress`: Exposes CRUD operations for the **UserPracticeProgress** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserPracticeProgresses
    * const userPracticeProgresses = await prisma.userPracticeProgress.findMany()
    * ```
    */
  get userPracticeProgress(): Prisma.UserPracticeProgressDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.helpTopic`: Exposes CRUD operations for the **HelpTopic** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more HelpTopics
    * const helpTopics = await prisma.helpTopic.findMany()
    * ```
    */
  get helpTopic(): Prisma.HelpTopicDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.stepHelp`: Exposes CRUD operations for the **StepHelp** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more StepHelps
    * const stepHelps = await prisma.stepHelp.findMany()
    * ```
    */
  get stepHelp(): Prisma.StepHelpDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.14.0
   * Query Engine version: 717184b7b35ea05dfa71a3236b7af656013e1e49
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    School: 'School',
    ProgramSettings: 'ProgramSettings',
    Demographics: 'Demographics',
    LoginLog: 'LoginLog',
    AnalysisQuestion: 'AnalysisQuestion',
    CommonFeedback: 'CommonFeedback',
    UploadedFile: 'UploadedFile',
    CloneDiscussion: 'CloneDiscussion',
    DiscussionMessage: 'DiscussionMessage',
    Message: 'Message',
    PracticeClone: 'PracticeClone',
    PracticeAnswer: 'PracticeAnswer',
    UserPracticeProgress: 'UserPracticeProgress',
    HelpTopic: 'HelpTopic',
    StepHelp: 'StepHelp'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "user" | "school" | "programSettings" | "demographics" | "loginLog" | "analysisQuestion" | "commonFeedback" | "uploadedFile" | "cloneDiscussion" | "discussionMessage" | "message" | "practiceClone" | "practiceAnswer" | "userPracticeProgress" | "helpTopic" | "stepHelp"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      School: {
        payload: Prisma.$SchoolPayload<ExtArgs>
        fields: Prisma.SchoolFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SchoolFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchoolPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SchoolFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchoolPayload>
          }
          findFirst: {
            args: Prisma.SchoolFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchoolPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SchoolFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchoolPayload>
          }
          findMany: {
            args: Prisma.SchoolFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchoolPayload>[]
          }
          create: {
            args: Prisma.SchoolCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchoolPayload>
          }
          createMany: {
            args: Prisma.SchoolCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SchoolCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchoolPayload>[]
          }
          delete: {
            args: Prisma.SchoolDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchoolPayload>
          }
          update: {
            args: Prisma.SchoolUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchoolPayload>
          }
          deleteMany: {
            args: Prisma.SchoolDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SchoolUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SchoolUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchoolPayload>[]
          }
          upsert: {
            args: Prisma.SchoolUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchoolPayload>
          }
          aggregate: {
            args: Prisma.SchoolAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSchool>
          }
          groupBy: {
            args: Prisma.SchoolGroupByArgs<ExtArgs>
            result: $Utils.Optional<SchoolGroupByOutputType>[]
          }
          count: {
            args: Prisma.SchoolCountArgs<ExtArgs>
            result: $Utils.Optional<SchoolCountAggregateOutputType> | number
          }
        }
      }
      ProgramSettings: {
        payload: Prisma.$ProgramSettingsPayload<ExtArgs>
        fields: Prisma.ProgramSettingsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProgramSettingsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgramSettingsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProgramSettingsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgramSettingsPayload>
          }
          findFirst: {
            args: Prisma.ProgramSettingsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgramSettingsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProgramSettingsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgramSettingsPayload>
          }
          findMany: {
            args: Prisma.ProgramSettingsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgramSettingsPayload>[]
          }
          create: {
            args: Prisma.ProgramSettingsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgramSettingsPayload>
          }
          createMany: {
            args: Prisma.ProgramSettingsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProgramSettingsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgramSettingsPayload>[]
          }
          delete: {
            args: Prisma.ProgramSettingsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgramSettingsPayload>
          }
          update: {
            args: Prisma.ProgramSettingsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgramSettingsPayload>
          }
          deleteMany: {
            args: Prisma.ProgramSettingsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProgramSettingsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ProgramSettingsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgramSettingsPayload>[]
          }
          upsert: {
            args: Prisma.ProgramSettingsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgramSettingsPayload>
          }
          aggregate: {
            args: Prisma.ProgramSettingsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProgramSettings>
          }
          groupBy: {
            args: Prisma.ProgramSettingsGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProgramSettingsGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProgramSettingsCountArgs<ExtArgs>
            result: $Utils.Optional<ProgramSettingsCountAggregateOutputType> | number
          }
        }
      }
      Demographics: {
        payload: Prisma.$DemographicsPayload<ExtArgs>
        fields: Prisma.DemographicsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DemographicsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DemographicsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DemographicsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DemographicsPayload>
          }
          findFirst: {
            args: Prisma.DemographicsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DemographicsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DemographicsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DemographicsPayload>
          }
          findMany: {
            args: Prisma.DemographicsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DemographicsPayload>[]
          }
          create: {
            args: Prisma.DemographicsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DemographicsPayload>
          }
          createMany: {
            args: Prisma.DemographicsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DemographicsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DemographicsPayload>[]
          }
          delete: {
            args: Prisma.DemographicsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DemographicsPayload>
          }
          update: {
            args: Prisma.DemographicsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DemographicsPayload>
          }
          deleteMany: {
            args: Prisma.DemographicsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DemographicsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DemographicsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DemographicsPayload>[]
          }
          upsert: {
            args: Prisma.DemographicsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DemographicsPayload>
          }
          aggregate: {
            args: Prisma.DemographicsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDemographics>
          }
          groupBy: {
            args: Prisma.DemographicsGroupByArgs<ExtArgs>
            result: $Utils.Optional<DemographicsGroupByOutputType>[]
          }
          count: {
            args: Prisma.DemographicsCountArgs<ExtArgs>
            result: $Utils.Optional<DemographicsCountAggregateOutputType> | number
          }
        }
      }
      LoginLog: {
        payload: Prisma.$LoginLogPayload<ExtArgs>
        fields: Prisma.LoginLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LoginLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LoginLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LoginLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LoginLogPayload>
          }
          findFirst: {
            args: Prisma.LoginLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LoginLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LoginLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LoginLogPayload>
          }
          findMany: {
            args: Prisma.LoginLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LoginLogPayload>[]
          }
          create: {
            args: Prisma.LoginLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LoginLogPayload>
          }
          createMany: {
            args: Prisma.LoginLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LoginLogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LoginLogPayload>[]
          }
          delete: {
            args: Prisma.LoginLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LoginLogPayload>
          }
          update: {
            args: Prisma.LoginLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LoginLogPayload>
          }
          deleteMany: {
            args: Prisma.LoginLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LoginLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.LoginLogUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LoginLogPayload>[]
          }
          upsert: {
            args: Prisma.LoginLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LoginLogPayload>
          }
          aggregate: {
            args: Prisma.LoginLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLoginLog>
          }
          groupBy: {
            args: Prisma.LoginLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<LoginLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.LoginLogCountArgs<ExtArgs>
            result: $Utils.Optional<LoginLogCountAggregateOutputType> | number
          }
        }
      }
      AnalysisQuestion: {
        payload: Prisma.$AnalysisQuestionPayload<ExtArgs>
        fields: Prisma.AnalysisQuestionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AnalysisQuestionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalysisQuestionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AnalysisQuestionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalysisQuestionPayload>
          }
          findFirst: {
            args: Prisma.AnalysisQuestionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalysisQuestionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AnalysisQuestionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalysisQuestionPayload>
          }
          findMany: {
            args: Prisma.AnalysisQuestionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalysisQuestionPayload>[]
          }
          create: {
            args: Prisma.AnalysisQuestionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalysisQuestionPayload>
          }
          createMany: {
            args: Prisma.AnalysisQuestionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AnalysisQuestionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalysisQuestionPayload>[]
          }
          delete: {
            args: Prisma.AnalysisQuestionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalysisQuestionPayload>
          }
          update: {
            args: Prisma.AnalysisQuestionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalysisQuestionPayload>
          }
          deleteMany: {
            args: Prisma.AnalysisQuestionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AnalysisQuestionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AnalysisQuestionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalysisQuestionPayload>[]
          }
          upsert: {
            args: Prisma.AnalysisQuestionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalysisQuestionPayload>
          }
          aggregate: {
            args: Prisma.AnalysisQuestionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAnalysisQuestion>
          }
          groupBy: {
            args: Prisma.AnalysisQuestionGroupByArgs<ExtArgs>
            result: $Utils.Optional<AnalysisQuestionGroupByOutputType>[]
          }
          count: {
            args: Prisma.AnalysisQuestionCountArgs<ExtArgs>
            result: $Utils.Optional<AnalysisQuestionCountAggregateOutputType> | number
          }
        }
      }
      CommonFeedback: {
        payload: Prisma.$CommonFeedbackPayload<ExtArgs>
        fields: Prisma.CommonFeedbackFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CommonFeedbackFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommonFeedbackPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CommonFeedbackFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommonFeedbackPayload>
          }
          findFirst: {
            args: Prisma.CommonFeedbackFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommonFeedbackPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CommonFeedbackFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommonFeedbackPayload>
          }
          findMany: {
            args: Prisma.CommonFeedbackFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommonFeedbackPayload>[]
          }
          create: {
            args: Prisma.CommonFeedbackCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommonFeedbackPayload>
          }
          createMany: {
            args: Prisma.CommonFeedbackCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CommonFeedbackCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommonFeedbackPayload>[]
          }
          delete: {
            args: Prisma.CommonFeedbackDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommonFeedbackPayload>
          }
          update: {
            args: Prisma.CommonFeedbackUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommonFeedbackPayload>
          }
          deleteMany: {
            args: Prisma.CommonFeedbackDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CommonFeedbackUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CommonFeedbackUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommonFeedbackPayload>[]
          }
          upsert: {
            args: Prisma.CommonFeedbackUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommonFeedbackPayload>
          }
          aggregate: {
            args: Prisma.CommonFeedbackAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCommonFeedback>
          }
          groupBy: {
            args: Prisma.CommonFeedbackGroupByArgs<ExtArgs>
            result: $Utils.Optional<CommonFeedbackGroupByOutputType>[]
          }
          count: {
            args: Prisma.CommonFeedbackCountArgs<ExtArgs>
            result: $Utils.Optional<CommonFeedbackCountAggregateOutputType> | number
          }
        }
      }
      UploadedFile: {
        payload: Prisma.$UploadedFilePayload<ExtArgs>
        fields: Prisma.UploadedFileFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UploadedFileFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UploadedFilePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UploadedFileFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UploadedFilePayload>
          }
          findFirst: {
            args: Prisma.UploadedFileFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UploadedFilePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UploadedFileFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UploadedFilePayload>
          }
          findMany: {
            args: Prisma.UploadedFileFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UploadedFilePayload>[]
          }
          create: {
            args: Prisma.UploadedFileCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UploadedFilePayload>
          }
          createMany: {
            args: Prisma.UploadedFileCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UploadedFileCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UploadedFilePayload>[]
          }
          delete: {
            args: Prisma.UploadedFileDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UploadedFilePayload>
          }
          update: {
            args: Prisma.UploadedFileUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UploadedFilePayload>
          }
          deleteMany: {
            args: Prisma.UploadedFileDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UploadedFileUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UploadedFileUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UploadedFilePayload>[]
          }
          upsert: {
            args: Prisma.UploadedFileUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UploadedFilePayload>
          }
          aggregate: {
            args: Prisma.UploadedFileAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUploadedFile>
          }
          groupBy: {
            args: Prisma.UploadedFileGroupByArgs<ExtArgs>
            result: $Utils.Optional<UploadedFileGroupByOutputType>[]
          }
          count: {
            args: Prisma.UploadedFileCountArgs<ExtArgs>
            result: $Utils.Optional<UploadedFileCountAggregateOutputType> | number
          }
        }
      }
      CloneDiscussion: {
        payload: Prisma.$CloneDiscussionPayload<ExtArgs>
        fields: Prisma.CloneDiscussionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CloneDiscussionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CloneDiscussionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CloneDiscussionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CloneDiscussionPayload>
          }
          findFirst: {
            args: Prisma.CloneDiscussionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CloneDiscussionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CloneDiscussionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CloneDiscussionPayload>
          }
          findMany: {
            args: Prisma.CloneDiscussionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CloneDiscussionPayload>[]
          }
          create: {
            args: Prisma.CloneDiscussionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CloneDiscussionPayload>
          }
          createMany: {
            args: Prisma.CloneDiscussionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CloneDiscussionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CloneDiscussionPayload>[]
          }
          delete: {
            args: Prisma.CloneDiscussionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CloneDiscussionPayload>
          }
          update: {
            args: Prisma.CloneDiscussionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CloneDiscussionPayload>
          }
          deleteMany: {
            args: Prisma.CloneDiscussionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CloneDiscussionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CloneDiscussionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CloneDiscussionPayload>[]
          }
          upsert: {
            args: Prisma.CloneDiscussionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CloneDiscussionPayload>
          }
          aggregate: {
            args: Prisma.CloneDiscussionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCloneDiscussion>
          }
          groupBy: {
            args: Prisma.CloneDiscussionGroupByArgs<ExtArgs>
            result: $Utils.Optional<CloneDiscussionGroupByOutputType>[]
          }
          count: {
            args: Prisma.CloneDiscussionCountArgs<ExtArgs>
            result: $Utils.Optional<CloneDiscussionCountAggregateOutputType> | number
          }
        }
      }
      DiscussionMessage: {
        payload: Prisma.$DiscussionMessagePayload<ExtArgs>
        fields: Prisma.DiscussionMessageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DiscussionMessageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DiscussionMessagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DiscussionMessageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DiscussionMessagePayload>
          }
          findFirst: {
            args: Prisma.DiscussionMessageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DiscussionMessagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DiscussionMessageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DiscussionMessagePayload>
          }
          findMany: {
            args: Prisma.DiscussionMessageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DiscussionMessagePayload>[]
          }
          create: {
            args: Prisma.DiscussionMessageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DiscussionMessagePayload>
          }
          createMany: {
            args: Prisma.DiscussionMessageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DiscussionMessageCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DiscussionMessagePayload>[]
          }
          delete: {
            args: Prisma.DiscussionMessageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DiscussionMessagePayload>
          }
          update: {
            args: Prisma.DiscussionMessageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DiscussionMessagePayload>
          }
          deleteMany: {
            args: Prisma.DiscussionMessageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DiscussionMessageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DiscussionMessageUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DiscussionMessagePayload>[]
          }
          upsert: {
            args: Prisma.DiscussionMessageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DiscussionMessagePayload>
          }
          aggregate: {
            args: Prisma.DiscussionMessageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDiscussionMessage>
          }
          groupBy: {
            args: Prisma.DiscussionMessageGroupByArgs<ExtArgs>
            result: $Utils.Optional<DiscussionMessageGroupByOutputType>[]
          }
          count: {
            args: Prisma.DiscussionMessageCountArgs<ExtArgs>
            result: $Utils.Optional<DiscussionMessageCountAggregateOutputType> | number
          }
        }
      }
      Message: {
        payload: Prisma.$MessagePayload<ExtArgs>
        fields: Prisma.MessageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MessageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MessageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          findFirst: {
            args: Prisma.MessageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MessageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          findMany: {
            args: Prisma.MessageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>[]
          }
          create: {
            args: Prisma.MessageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          createMany: {
            args: Prisma.MessageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MessageCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>[]
          }
          delete: {
            args: Prisma.MessageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          update: {
            args: Prisma.MessageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          deleteMany: {
            args: Prisma.MessageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MessageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MessageUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>[]
          }
          upsert: {
            args: Prisma.MessageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          aggregate: {
            args: Prisma.MessageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMessage>
          }
          groupBy: {
            args: Prisma.MessageGroupByArgs<ExtArgs>
            result: $Utils.Optional<MessageGroupByOutputType>[]
          }
          count: {
            args: Prisma.MessageCountArgs<ExtArgs>
            result: $Utils.Optional<MessageCountAggregateOutputType> | number
          }
        }
      }
      PracticeClone: {
        payload: Prisma.$PracticeClonePayload<ExtArgs>
        fields: Prisma.PracticeCloneFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PracticeCloneFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PracticeClonePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PracticeCloneFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PracticeClonePayload>
          }
          findFirst: {
            args: Prisma.PracticeCloneFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PracticeClonePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PracticeCloneFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PracticeClonePayload>
          }
          findMany: {
            args: Prisma.PracticeCloneFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PracticeClonePayload>[]
          }
          create: {
            args: Prisma.PracticeCloneCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PracticeClonePayload>
          }
          createMany: {
            args: Prisma.PracticeCloneCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PracticeCloneCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PracticeClonePayload>[]
          }
          delete: {
            args: Prisma.PracticeCloneDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PracticeClonePayload>
          }
          update: {
            args: Prisma.PracticeCloneUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PracticeClonePayload>
          }
          deleteMany: {
            args: Prisma.PracticeCloneDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PracticeCloneUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PracticeCloneUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PracticeClonePayload>[]
          }
          upsert: {
            args: Prisma.PracticeCloneUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PracticeClonePayload>
          }
          aggregate: {
            args: Prisma.PracticeCloneAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePracticeClone>
          }
          groupBy: {
            args: Prisma.PracticeCloneGroupByArgs<ExtArgs>
            result: $Utils.Optional<PracticeCloneGroupByOutputType>[]
          }
          count: {
            args: Prisma.PracticeCloneCountArgs<ExtArgs>
            result: $Utils.Optional<PracticeCloneCountAggregateOutputType> | number
          }
        }
      }
      PracticeAnswer: {
        payload: Prisma.$PracticeAnswerPayload<ExtArgs>
        fields: Prisma.PracticeAnswerFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PracticeAnswerFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PracticeAnswerPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PracticeAnswerFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PracticeAnswerPayload>
          }
          findFirst: {
            args: Prisma.PracticeAnswerFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PracticeAnswerPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PracticeAnswerFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PracticeAnswerPayload>
          }
          findMany: {
            args: Prisma.PracticeAnswerFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PracticeAnswerPayload>[]
          }
          create: {
            args: Prisma.PracticeAnswerCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PracticeAnswerPayload>
          }
          createMany: {
            args: Prisma.PracticeAnswerCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PracticeAnswerCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PracticeAnswerPayload>[]
          }
          delete: {
            args: Prisma.PracticeAnswerDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PracticeAnswerPayload>
          }
          update: {
            args: Prisma.PracticeAnswerUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PracticeAnswerPayload>
          }
          deleteMany: {
            args: Prisma.PracticeAnswerDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PracticeAnswerUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PracticeAnswerUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PracticeAnswerPayload>[]
          }
          upsert: {
            args: Prisma.PracticeAnswerUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PracticeAnswerPayload>
          }
          aggregate: {
            args: Prisma.PracticeAnswerAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePracticeAnswer>
          }
          groupBy: {
            args: Prisma.PracticeAnswerGroupByArgs<ExtArgs>
            result: $Utils.Optional<PracticeAnswerGroupByOutputType>[]
          }
          count: {
            args: Prisma.PracticeAnswerCountArgs<ExtArgs>
            result: $Utils.Optional<PracticeAnswerCountAggregateOutputType> | number
          }
        }
      }
      UserPracticeProgress: {
        payload: Prisma.$UserPracticeProgressPayload<ExtArgs>
        fields: Prisma.UserPracticeProgressFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserPracticeProgressFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPracticeProgressPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserPracticeProgressFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPracticeProgressPayload>
          }
          findFirst: {
            args: Prisma.UserPracticeProgressFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPracticeProgressPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserPracticeProgressFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPracticeProgressPayload>
          }
          findMany: {
            args: Prisma.UserPracticeProgressFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPracticeProgressPayload>[]
          }
          create: {
            args: Prisma.UserPracticeProgressCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPracticeProgressPayload>
          }
          createMany: {
            args: Prisma.UserPracticeProgressCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserPracticeProgressCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPracticeProgressPayload>[]
          }
          delete: {
            args: Prisma.UserPracticeProgressDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPracticeProgressPayload>
          }
          update: {
            args: Prisma.UserPracticeProgressUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPracticeProgressPayload>
          }
          deleteMany: {
            args: Prisma.UserPracticeProgressDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserPracticeProgressUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserPracticeProgressUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPracticeProgressPayload>[]
          }
          upsert: {
            args: Prisma.UserPracticeProgressUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPracticeProgressPayload>
          }
          aggregate: {
            args: Prisma.UserPracticeProgressAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserPracticeProgress>
          }
          groupBy: {
            args: Prisma.UserPracticeProgressGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserPracticeProgressGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserPracticeProgressCountArgs<ExtArgs>
            result: $Utils.Optional<UserPracticeProgressCountAggregateOutputType> | number
          }
        }
      }
      HelpTopic: {
        payload: Prisma.$HelpTopicPayload<ExtArgs>
        fields: Prisma.HelpTopicFieldRefs
        operations: {
          findUnique: {
            args: Prisma.HelpTopicFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HelpTopicPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.HelpTopicFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HelpTopicPayload>
          }
          findFirst: {
            args: Prisma.HelpTopicFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HelpTopicPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.HelpTopicFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HelpTopicPayload>
          }
          findMany: {
            args: Prisma.HelpTopicFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HelpTopicPayload>[]
          }
          create: {
            args: Prisma.HelpTopicCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HelpTopicPayload>
          }
          createMany: {
            args: Prisma.HelpTopicCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.HelpTopicCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HelpTopicPayload>[]
          }
          delete: {
            args: Prisma.HelpTopicDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HelpTopicPayload>
          }
          update: {
            args: Prisma.HelpTopicUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HelpTopicPayload>
          }
          deleteMany: {
            args: Prisma.HelpTopicDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.HelpTopicUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.HelpTopicUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HelpTopicPayload>[]
          }
          upsert: {
            args: Prisma.HelpTopicUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HelpTopicPayload>
          }
          aggregate: {
            args: Prisma.HelpTopicAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateHelpTopic>
          }
          groupBy: {
            args: Prisma.HelpTopicGroupByArgs<ExtArgs>
            result: $Utils.Optional<HelpTopicGroupByOutputType>[]
          }
          count: {
            args: Prisma.HelpTopicCountArgs<ExtArgs>
            result: $Utils.Optional<HelpTopicCountAggregateOutputType> | number
          }
        }
      }
      StepHelp: {
        payload: Prisma.$StepHelpPayload<ExtArgs>
        fields: Prisma.StepHelpFieldRefs
        operations: {
          findUnique: {
            args: Prisma.StepHelpFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StepHelpPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StepHelpFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StepHelpPayload>
          }
          findFirst: {
            args: Prisma.StepHelpFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StepHelpPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StepHelpFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StepHelpPayload>
          }
          findMany: {
            args: Prisma.StepHelpFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StepHelpPayload>[]
          }
          create: {
            args: Prisma.StepHelpCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StepHelpPayload>
          }
          createMany: {
            args: Prisma.StepHelpCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.StepHelpCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StepHelpPayload>[]
          }
          delete: {
            args: Prisma.StepHelpDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StepHelpPayload>
          }
          update: {
            args: Prisma.StepHelpUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StepHelpPayload>
          }
          deleteMany: {
            args: Prisma.StepHelpDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.StepHelpUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.StepHelpUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StepHelpPayload>[]
          }
          upsert: {
            args: Prisma.StepHelpUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StepHelpPayload>
          }
          aggregate: {
            args: Prisma.StepHelpAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStepHelp>
          }
          groupBy: {
            args: Prisma.StepHelpGroupByArgs<ExtArgs>
            result: $Utils.Optional<StepHelpGroupByOutputType>[]
          }
          count: {
            args: Prisma.StepHelpCountArgs<ExtArgs>
            result: $Utils.Optional<StepHelpCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Shorthand for `emit: 'stdout'`
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events only
     * log: [
     *   { emit: 'event', level: 'query' },
     *   { emit: 'event', level: 'info' },
     *   { emit: 'event', level: 'warn' }
     *   { emit: 'event', level: 'error' }
     * ]
     * 
     * / Emit as events and log to stdout
     * og: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * 
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    user?: UserOmit
    school?: SchoolOmit
    programSettings?: ProgramSettingsOmit
    demographics?: DemographicsOmit
    loginLog?: LoginLogOmit
    analysisQuestion?: AnalysisQuestionOmit
    commonFeedback?: CommonFeedbackOmit
    uploadedFile?: UploadedFileOmit
    cloneDiscussion?: CloneDiscussionOmit
    discussionMessage?: DiscussionMessageOmit
    message?: MessageOmit
    practiceClone?: PracticeCloneOmit
    practiceAnswer?: PracticeAnswerOmit
    userPracticeProgress?: UserPracticeProgressOmit
    helpTopic?: HelpTopicOmit
    stepHelp?: StepHelpOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type CheckIsLogLevel<T> = T extends LogLevel ? T : never;

  export type GetLogType<T> = CheckIsLogLevel<
    T extends LogDefinition ? T['level'] : T
  >;

  export type GetEvents<T extends any[]> = T extends Array<LogLevel | LogDefinition>
    ? GetLogType<T[number]>
    : never;

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    assignedFiles: number
    uploadedFiles: number
    sentMessages: number
    receivedMessages: number
    practiceProgress: number
    loginLogs: number
    discussions: number
    discussionMessagesSent: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    assignedFiles?: boolean | UserCountOutputTypeCountAssignedFilesArgs
    uploadedFiles?: boolean | UserCountOutputTypeCountUploadedFilesArgs
    sentMessages?: boolean | UserCountOutputTypeCountSentMessagesArgs
    receivedMessages?: boolean | UserCountOutputTypeCountReceivedMessagesArgs
    practiceProgress?: boolean | UserCountOutputTypeCountPracticeProgressArgs
    loginLogs?: boolean | UserCountOutputTypeCountLoginLogsArgs
    discussions?: boolean | UserCountOutputTypeCountDiscussionsArgs
    discussionMessagesSent?: boolean | UserCountOutputTypeCountDiscussionMessagesSentArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAssignedFilesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UploadedFileWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountUploadedFilesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UploadedFileWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSentMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MessageWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountReceivedMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MessageWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountPracticeProgressArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserPracticeProgressWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountLoginLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LoginLogWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountDiscussionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CloneDiscussionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountDiscussionMessagesSentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DiscussionMessageWhereInput
  }


  /**
   * Count Type SchoolCountOutputType
   */

  export type SchoolCountOutputType = {
    users: number
  }

  export type SchoolCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | SchoolCountOutputTypeCountUsersArgs
  }

  // Custom InputTypes
  /**
   * SchoolCountOutputType without action
   */
  export type SchoolCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SchoolCountOutputType
     */
    select?: SchoolCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SchoolCountOutputType without action
   */
  export type SchoolCountOutputTypeCountUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
  }


  /**
   * Count Type AnalysisQuestionCountOutputType
   */

  export type AnalysisQuestionCountOutputType = {
    HelpTopic: number
  }

  export type AnalysisQuestionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    HelpTopic?: boolean | AnalysisQuestionCountOutputTypeCountHelpTopicArgs
  }

  // Custom InputTypes
  /**
   * AnalysisQuestionCountOutputType without action
   */
  export type AnalysisQuestionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnalysisQuestionCountOutputType
     */
    select?: AnalysisQuestionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AnalysisQuestionCountOutputType without action
   */
  export type AnalysisQuestionCountOutputTypeCountHelpTopicArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: HelpTopicWhereInput
  }


  /**
   * Count Type UploadedFileCountOutputType
   */

  export type UploadedFileCountOutputType = {
    messages: number
    cloneDiscussions: number
  }

  export type UploadedFileCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    messages?: boolean | UploadedFileCountOutputTypeCountMessagesArgs
    cloneDiscussions?: boolean | UploadedFileCountOutputTypeCountCloneDiscussionsArgs
  }

  // Custom InputTypes
  /**
   * UploadedFileCountOutputType without action
   */
  export type UploadedFileCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UploadedFileCountOutputType
     */
    select?: UploadedFileCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UploadedFileCountOutputType without action
   */
  export type UploadedFileCountOutputTypeCountMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MessageWhereInput
  }

  /**
   * UploadedFileCountOutputType without action
   */
  export type UploadedFileCountOutputTypeCountCloneDiscussionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CloneDiscussionWhereInput
  }


  /**
   * Count Type CloneDiscussionCountOutputType
   */

  export type CloneDiscussionCountOutputType = {
    messages: number
  }

  export type CloneDiscussionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    messages?: boolean | CloneDiscussionCountOutputTypeCountMessagesArgs
  }

  // Custom InputTypes
  /**
   * CloneDiscussionCountOutputType without action
   */
  export type CloneDiscussionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CloneDiscussionCountOutputType
     */
    select?: CloneDiscussionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CloneDiscussionCountOutputType without action
   */
  export type CloneDiscussionCountOutputTypeCountMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DiscussionMessageWhereInput
  }


  /**
   * Count Type PracticeCloneCountOutputType
   */

  export type PracticeCloneCountOutputType = {
    practiceAnswers: number
    userProgress: number
    cloneDiscussions: number
  }

  export type PracticeCloneCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    practiceAnswers?: boolean | PracticeCloneCountOutputTypeCountPracticeAnswersArgs
    userProgress?: boolean | PracticeCloneCountOutputTypeCountUserProgressArgs
    cloneDiscussions?: boolean | PracticeCloneCountOutputTypeCountCloneDiscussionsArgs
  }

  // Custom InputTypes
  /**
   * PracticeCloneCountOutputType without action
   */
  export type PracticeCloneCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PracticeCloneCountOutputType
     */
    select?: PracticeCloneCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PracticeCloneCountOutputType without action
   */
  export type PracticeCloneCountOutputTypeCountPracticeAnswersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PracticeAnswerWhereInput
  }

  /**
   * PracticeCloneCountOutputType without action
   */
  export type PracticeCloneCountOutputTypeCountUserProgressArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserPracticeProgressWhereInput
  }

  /**
   * PracticeCloneCountOutputType without action
   */
  export type PracticeCloneCountOutputTypeCountCloneDiscussionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CloneDiscussionWhereInput
  }


  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserAvgAggregateOutputType = {
    id: number | null
    schoolId: number | null
  }

  export type UserSumAggregateOutputType = {
    id: number | null
    schoolId: number | null
  }

  export type UserMinAggregateOutputType = {
    id: number | null
    email: string | null
    password: string | null
    name: string | null
    role: string | null
    status: string | null
    schoolId: number | null
    resetToken: string | null
    resetTokenExpiry: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: number | null
    email: string | null
    password: string | null
    name: string | null
    role: string | null
    status: string | null
    schoolId: number | null
    resetToken: string | null
    resetTokenExpiry: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    email: number
    password: number
    name: number
    role: number
    status: number
    schoolId: number
    resetToken: number
    resetTokenExpiry: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserAvgAggregateInputType = {
    id?: true
    schoolId?: true
  }

  export type UserSumAggregateInputType = {
    id?: true
    schoolId?: true
  }

  export type UserMinAggregateInputType = {
    id?: true
    email?: true
    password?: true
    name?: true
    role?: true
    status?: true
    schoolId?: true
    resetToken?: true
    resetTokenExpiry?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    email?: true
    password?: true
    name?: true
    role?: true
    status?: true
    schoolId?: true
    resetToken?: true
    resetTokenExpiry?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    email?: true
    password?: true
    name?: true
    role?: true
    status?: true
    schoolId?: true
    resetToken?: true
    resetTokenExpiry?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _avg?: UserAvgAggregateInputType
    _sum?: UserSumAggregateInputType
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: number
    email: string
    password: string
    name: string
    role: string
    status: string
    schoolId: number | null
    resetToken: string | null
    resetTokenExpiry: Date | null
    createdAt: Date
    updatedAt: Date
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    password?: boolean
    name?: boolean
    role?: boolean
    status?: boolean
    schoolId?: boolean
    resetToken?: boolean
    resetTokenExpiry?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    school?: boolean | User$schoolArgs<ExtArgs>
    demographics?: boolean | User$demographicsArgs<ExtArgs>
    assignedFiles?: boolean | User$assignedFilesArgs<ExtArgs>
    uploadedFiles?: boolean | User$uploadedFilesArgs<ExtArgs>
    sentMessages?: boolean | User$sentMessagesArgs<ExtArgs>
    receivedMessages?: boolean | User$receivedMessagesArgs<ExtArgs>
    practiceProgress?: boolean | User$practiceProgressArgs<ExtArgs>
    loginLogs?: boolean | User$loginLogsArgs<ExtArgs>
    discussions?: boolean | User$discussionsArgs<ExtArgs>
    discussionMessagesSent?: boolean | User$discussionMessagesSentArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    password?: boolean
    name?: boolean
    role?: boolean
    status?: boolean
    schoolId?: boolean
    resetToken?: boolean
    resetTokenExpiry?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    school?: boolean | User$schoolArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    password?: boolean
    name?: boolean
    role?: boolean
    status?: boolean
    schoolId?: boolean
    resetToken?: boolean
    resetTokenExpiry?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    school?: boolean | User$schoolArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    email?: boolean
    password?: boolean
    name?: boolean
    role?: boolean
    status?: boolean
    schoolId?: boolean
    resetToken?: boolean
    resetTokenExpiry?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "email" | "password" | "name" | "role" | "status" | "schoolId" | "resetToken" | "resetTokenExpiry" | "createdAt" | "updatedAt", ExtArgs["result"]["user"]>
  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    school?: boolean | User$schoolArgs<ExtArgs>
    demographics?: boolean | User$demographicsArgs<ExtArgs>
    assignedFiles?: boolean | User$assignedFilesArgs<ExtArgs>
    uploadedFiles?: boolean | User$uploadedFilesArgs<ExtArgs>
    sentMessages?: boolean | User$sentMessagesArgs<ExtArgs>
    receivedMessages?: boolean | User$receivedMessagesArgs<ExtArgs>
    practiceProgress?: boolean | User$practiceProgressArgs<ExtArgs>
    loginLogs?: boolean | User$loginLogsArgs<ExtArgs>
    discussions?: boolean | User$discussionsArgs<ExtArgs>
    discussionMessagesSent?: boolean | User$discussionMessagesSentArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    school?: boolean | User$schoolArgs<ExtArgs>
  }
  export type UserIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    school?: boolean | User$schoolArgs<ExtArgs>
  }

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      school: Prisma.$SchoolPayload<ExtArgs> | null
      demographics: Prisma.$DemographicsPayload<ExtArgs> | null
      assignedFiles: Prisma.$UploadedFilePayload<ExtArgs>[]
      uploadedFiles: Prisma.$UploadedFilePayload<ExtArgs>[]
      sentMessages: Prisma.$MessagePayload<ExtArgs>[]
      receivedMessages: Prisma.$MessagePayload<ExtArgs>[]
      practiceProgress: Prisma.$UserPracticeProgressPayload<ExtArgs>[]
      loginLogs: Prisma.$LoginLogPayload<ExtArgs>[]
      discussions: Prisma.$CloneDiscussionPayload<ExtArgs>[]
      discussionMessagesSent: Prisma.$DiscussionMessagePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      email: string
      password: string
      name: string
      role: string
      status: string
      schoolId: number | null
      resetToken: string | null
      resetTokenExpiry: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {UserUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Users and only return the `id`
     * const userWithIdOnly = await prisma.user.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserUpdateManyAndReturnArgs>(args: SelectSubset<T, UserUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    school<T extends User$schoolArgs<ExtArgs> = {}>(args?: Subset<T, User$schoolArgs<ExtArgs>>): Prisma__SchoolClient<$Result.GetResult<Prisma.$SchoolPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    demographics<T extends User$demographicsArgs<ExtArgs> = {}>(args?: Subset<T, User$demographicsArgs<ExtArgs>>): Prisma__DemographicsClient<$Result.GetResult<Prisma.$DemographicsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    assignedFiles<T extends User$assignedFilesArgs<ExtArgs> = {}>(args?: Subset<T, User$assignedFilesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UploadedFilePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    uploadedFiles<T extends User$uploadedFilesArgs<ExtArgs> = {}>(args?: Subset<T, User$uploadedFilesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UploadedFilePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    sentMessages<T extends User$sentMessagesArgs<ExtArgs> = {}>(args?: Subset<T, User$sentMessagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    receivedMessages<T extends User$receivedMessagesArgs<ExtArgs> = {}>(args?: Subset<T, User$receivedMessagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    practiceProgress<T extends User$practiceProgressArgs<ExtArgs> = {}>(args?: Subset<T, User$practiceProgressArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPracticeProgressPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    loginLogs<T extends User$loginLogsArgs<ExtArgs> = {}>(args?: Subset<T, User$loginLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LoginLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    discussions<T extends User$discussionsArgs<ExtArgs> = {}>(args?: Subset<T, User$discussionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CloneDiscussionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    discussionMessagesSent<T extends User$discussionMessagesSentArgs<ExtArgs> = {}>(args?: Subset<T, User$discussionMessagesSentArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DiscussionMessagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'Int'>
    readonly email: FieldRef<"User", 'String'>
    readonly password: FieldRef<"User", 'String'>
    readonly name: FieldRef<"User", 'String'>
    readonly role: FieldRef<"User", 'String'>
    readonly status: FieldRef<"User", 'String'>
    readonly schoolId: FieldRef<"User", 'Int'>
    readonly resetToken: FieldRef<"User", 'String'>
    readonly resetTokenExpiry: FieldRef<"User", 'DateTime'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User updateManyAndReturn
   */
  export type UserUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * User.school
   */
  export type User$schoolArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the School
     */
    select?: SchoolSelect<ExtArgs> | null
    /**
     * Omit specific fields from the School
     */
    omit?: SchoolOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolInclude<ExtArgs> | null
    where?: SchoolWhereInput
  }

  /**
   * User.demographics
   */
  export type User$demographicsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Demographics
     */
    select?: DemographicsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Demographics
     */
    omit?: DemographicsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DemographicsInclude<ExtArgs> | null
    where?: DemographicsWhereInput
  }

  /**
   * User.assignedFiles
   */
  export type User$assignedFilesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UploadedFile
     */
    select?: UploadedFileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UploadedFile
     */
    omit?: UploadedFileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UploadedFileInclude<ExtArgs> | null
    where?: UploadedFileWhereInput
    orderBy?: UploadedFileOrderByWithRelationInput | UploadedFileOrderByWithRelationInput[]
    cursor?: UploadedFileWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UploadedFileScalarFieldEnum | UploadedFileScalarFieldEnum[]
  }

  /**
   * User.uploadedFiles
   */
  export type User$uploadedFilesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UploadedFile
     */
    select?: UploadedFileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UploadedFile
     */
    omit?: UploadedFileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UploadedFileInclude<ExtArgs> | null
    where?: UploadedFileWhereInput
    orderBy?: UploadedFileOrderByWithRelationInput | UploadedFileOrderByWithRelationInput[]
    cursor?: UploadedFileWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UploadedFileScalarFieldEnum | UploadedFileScalarFieldEnum[]
  }

  /**
   * User.sentMessages
   */
  export type User$sentMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    where?: MessageWhereInput
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    cursor?: MessageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * User.receivedMessages
   */
  export type User$receivedMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    where?: MessageWhereInput
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    cursor?: MessageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * User.practiceProgress
   */
  export type User$practiceProgressArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPracticeProgress
     */
    select?: UserPracticeProgressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPracticeProgress
     */
    omit?: UserPracticeProgressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPracticeProgressInclude<ExtArgs> | null
    where?: UserPracticeProgressWhereInput
    orderBy?: UserPracticeProgressOrderByWithRelationInput | UserPracticeProgressOrderByWithRelationInput[]
    cursor?: UserPracticeProgressWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserPracticeProgressScalarFieldEnum | UserPracticeProgressScalarFieldEnum[]
  }

  /**
   * User.loginLogs
   */
  export type User$loginLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoginLog
     */
    select?: LoginLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LoginLog
     */
    omit?: LoginLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoginLogInclude<ExtArgs> | null
    where?: LoginLogWhereInput
    orderBy?: LoginLogOrderByWithRelationInput | LoginLogOrderByWithRelationInput[]
    cursor?: LoginLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LoginLogScalarFieldEnum | LoginLogScalarFieldEnum[]
  }

  /**
   * User.discussions
   */
  export type User$discussionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CloneDiscussion
     */
    select?: CloneDiscussionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CloneDiscussion
     */
    omit?: CloneDiscussionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CloneDiscussionInclude<ExtArgs> | null
    where?: CloneDiscussionWhereInput
    orderBy?: CloneDiscussionOrderByWithRelationInput | CloneDiscussionOrderByWithRelationInput[]
    cursor?: CloneDiscussionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CloneDiscussionScalarFieldEnum | CloneDiscussionScalarFieldEnum[]
  }

  /**
   * User.discussionMessagesSent
   */
  export type User$discussionMessagesSentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DiscussionMessage
     */
    select?: DiscussionMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DiscussionMessage
     */
    omit?: DiscussionMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DiscussionMessageInclude<ExtArgs> | null
    where?: DiscussionMessageWhereInput
    orderBy?: DiscussionMessageOrderByWithRelationInput | DiscussionMessageOrderByWithRelationInput[]
    cursor?: DiscussionMessageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DiscussionMessageScalarFieldEnum | DiscussionMessageScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model School
   */

  export type AggregateSchool = {
    _count: SchoolCountAggregateOutputType | null
    _avg: SchoolAvgAggregateOutputType | null
    _sum: SchoolSumAggregateOutputType | null
    _min: SchoolMinAggregateOutputType | null
    _max: SchoolMaxAggregateOutputType | null
  }

  export type SchoolAvgAggregateOutputType = {
    id: number | null
    students: number | null
  }

  export type SchoolSumAggregateOutputType = {
    id: number | null
    students: number | null
  }

  export type SchoolMinAggregateOutputType = {
    id: number | null
    name: string | null
    schoolId: string | null
    instructor: string | null
    students: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SchoolMaxAggregateOutputType = {
    id: number | null
    name: string | null
    schoolId: string | null
    instructor: string | null
    students: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SchoolCountAggregateOutputType = {
    id: number
    name: number
    schoolId: number
    instructor: number
    students: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SchoolAvgAggregateInputType = {
    id?: true
    students?: true
  }

  export type SchoolSumAggregateInputType = {
    id?: true
    students?: true
  }

  export type SchoolMinAggregateInputType = {
    id?: true
    name?: true
    schoolId?: true
    instructor?: true
    students?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SchoolMaxAggregateInputType = {
    id?: true
    name?: true
    schoolId?: true
    instructor?: true
    students?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SchoolCountAggregateInputType = {
    id?: true
    name?: true
    schoolId?: true
    instructor?: true
    students?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SchoolAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which School to aggregate.
     */
    where?: SchoolWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Schools to fetch.
     */
    orderBy?: SchoolOrderByWithRelationInput | SchoolOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SchoolWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Schools from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Schools.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Schools
    **/
    _count?: true | SchoolCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SchoolAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SchoolSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SchoolMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SchoolMaxAggregateInputType
  }

  export type GetSchoolAggregateType<T extends SchoolAggregateArgs> = {
        [P in keyof T & keyof AggregateSchool]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSchool[P]>
      : GetScalarType<T[P], AggregateSchool[P]>
  }




  export type SchoolGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SchoolWhereInput
    orderBy?: SchoolOrderByWithAggregationInput | SchoolOrderByWithAggregationInput[]
    by: SchoolScalarFieldEnum[] | SchoolScalarFieldEnum
    having?: SchoolScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SchoolCountAggregateInputType | true
    _avg?: SchoolAvgAggregateInputType
    _sum?: SchoolSumAggregateInputType
    _min?: SchoolMinAggregateInputType
    _max?: SchoolMaxAggregateInputType
  }

  export type SchoolGroupByOutputType = {
    id: number
    name: string
    schoolId: string
    instructor: string
    students: number
    createdAt: Date
    updatedAt: Date
    _count: SchoolCountAggregateOutputType | null
    _avg: SchoolAvgAggregateOutputType | null
    _sum: SchoolSumAggregateOutputType | null
    _min: SchoolMinAggregateOutputType | null
    _max: SchoolMaxAggregateOutputType | null
  }

  type GetSchoolGroupByPayload<T extends SchoolGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SchoolGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SchoolGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SchoolGroupByOutputType[P]>
            : GetScalarType<T[P], SchoolGroupByOutputType[P]>
        }
      >
    >


  export type SchoolSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    schoolId?: boolean
    instructor?: boolean
    students?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    users?: boolean | School$usersArgs<ExtArgs>
    _count?: boolean | SchoolCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["school"]>

  export type SchoolSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    schoolId?: boolean
    instructor?: boolean
    students?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["school"]>

  export type SchoolSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    schoolId?: boolean
    instructor?: boolean
    students?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["school"]>

  export type SchoolSelectScalar = {
    id?: boolean
    name?: boolean
    schoolId?: boolean
    instructor?: boolean
    students?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SchoolOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "schoolId" | "instructor" | "students" | "createdAt" | "updatedAt", ExtArgs["result"]["school"]>
  export type SchoolInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | School$usersArgs<ExtArgs>
    _count?: boolean | SchoolCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type SchoolIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type SchoolIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $SchoolPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "School"
    objects: {
      users: Prisma.$UserPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      schoolId: string
      instructor: string
      students: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["school"]>
    composites: {}
  }

  type SchoolGetPayload<S extends boolean | null | undefined | SchoolDefaultArgs> = $Result.GetResult<Prisma.$SchoolPayload, S>

  type SchoolCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SchoolFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SchoolCountAggregateInputType | true
    }

  export interface SchoolDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['School'], meta: { name: 'School' } }
    /**
     * Find zero or one School that matches the filter.
     * @param {SchoolFindUniqueArgs} args - Arguments to find a School
     * @example
     * // Get one School
     * const school = await prisma.school.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SchoolFindUniqueArgs>(args: SelectSubset<T, SchoolFindUniqueArgs<ExtArgs>>): Prisma__SchoolClient<$Result.GetResult<Prisma.$SchoolPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one School that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SchoolFindUniqueOrThrowArgs} args - Arguments to find a School
     * @example
     * // Get one School
     * const school = await prisma.school.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SchoolFindUniqueOrThrowArgs>(args: SelectSubset<T, SchoolFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SchoolClient<$Result.GetResult<Prisma.$SchoolPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first School that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SchoolFindFirstArgs} args - Arguments to find a School
     * @example
     * // Get one School
     * const school = await prisma.school.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SchoolFindFirstArgs>(args?: SelectSubset<T, SchoolFindFirstArgs<ExtArgs>>): Prisma__SchoolClient<$Result.GetResult<Prisma.$SchoolPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first School that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SchoolFindFirstOrThrowArgs} args - Arguments to find a School
     * @example
     * // Get one School
     * const school = await prisma.school.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SchoolFindFirstOrThrowArgs>(args?: SelectSubset<T, SchoolFindFirstOrThrowArgs<ExtArgs>>): Prisma__SchoolClient<$Result.GetResult<Prisma.$SchoolPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Schools that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SchoolFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Schools
     * const schools = await prisma.school.findMany()
     * 
     * // Get first 10 Schools
     * const schools = await prisma.school.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const schoolWithIdOnly = await prisma.school.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SchoolFindManyArgs>(args?: SelectSubset<T, SchoolFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SchoolPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a School.
     * @param {SchoolCreateArgs} args - Arguments to create a School.
     * @example
     * // Create one School
     * const School = await prisma.school.create({
     *   data: {
     *     // ... data to create a School
     *   }
     * })
     * 
     */
    create<T extends SchoolCreateArgs>(args: SelectSubset<T, SchoolCreateArgs<ExtArgs>>): Prisma__SchoolClient<$Result.GetResult<Prisma.$SchoolPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Schools.
     * @param {SchoolCreateManyArgs} args - Arguments to create many Schools.
     * @example
     * // Create many Schools
     * const school = await prisma.school.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SchoolCreateManyArgs>(args?: SelectSubset<T, SchoolCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Schools and returns the data saved in the database.
     * @param {SchoolCreateManyAndReturnArgs} args - Arguments to create many Schools.
     * @example
     * // Create many Schools
     * const school = await prisma.school.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Schools and only return the `id`
     * const schoolWithIdOnly = await prisma.school.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SchoolCreateManyAndReturnArgs>(args?: SelectSubset<T, SchoolCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SchoolPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a School.
     * @param {SchoolDeleteArgs} args - Arguments to delete one School.
     * @example
     * // Delete one School
     * const School = await prisma.school.delete({
     *   where: {
     *     // ... filter to delete one School
     *   }
     * })
     * 
     */
    delete<T extends SchoolDeleteArgs>(args: SelectSubset<T, SchoolDeleteArgs<ExtArgs>>): Prisma__SchoolClient<$Result.GetResult<Prisma.$SchoolPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one School.
     * @param {SchoolUpdateArgs} args - Arguments to update one School.
     * @example
     * // Update one School
     * const school = await prisma.school.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SchoolUpdateArgs>(args: SelectSubset<T, SchoolUpdateArgs<ExtArgs>>): Prisma__SchoolClient<$Result.GetResult<Prisma.$SchoolPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Schools.
     * @param {SchoolDeleteManyArgs} args - Arguments to filter Schools to delete.
     * @example
     * // Delete a few Schools
     * const { count } = await prisma.school.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SchoolDeleteManyArgs>(args?: SelectSubset<T, SchoolDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Schools.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SchoolUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Schools
     * const school = await prisma.school.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SchoolUpdateManyArgs>(args: SelectSubset<T, SchoolUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Schools and returns the data updated in the database.
     * @param {SchoolUpdateManyAndReturnArgs} args - Arguments to update many Schools.
     * @example
     * // Update many Schools
     * const school = await prisma.school.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Schools and only return the `id`
     * const schoolWithIdOnly = await prisma.school.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SchoolUpdateManyAndReturnArgs>(args: SelectSubset<T, SchoolUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SchoolPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one School.
     * @param {SchoolUpsertArgs} args - Arguments to update or create a School.
     * @example
     * // Update or create a School
     * const school = await prisma.school.upsert({
     *   create: {
     *     // ... data to create a School
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the School we want to update
     *   }
     * })
     */
    upsert<T extends SchoolUpsertArgs>(args: SelectSubset<T, SchoolUpsertArgs<ExtArgs>>): Prisma__SchoolClient<$Result.GetResult<Prisma.$SchoolPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Schools.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SchoolCountArgs} args - Arguments to filter Schools to count.
     * @example
     * // Count the number of Schools
     * const count = await prisma.school.count({
     *   where: {
     *     // ... the filter for the Schools we want to count
     *   }
     * })
    **/
    count<T extends SchoolCountArgs>(
      args?: Subset<T, SchoolCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SchoolCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a School.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SchoolAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SchoolAggregateArgs>(args: Subset<T, SchoolAggregateArgs>): Prisma.PrismaPromise<GetSchoolAggregateType<T>>

    /**
     * Group by School.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SchoolGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SchoolGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SchoolGroupByArgs['orderBy'] }
        : { orderBy?: SchoolGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SchoolGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSchoolGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the School model
   */
  readonly fields: SchoolFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for School.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SchoolClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    users<T extends School$usersArgs<ExtArgs> = {}>(args?: Subset<T, School$usersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the School model
   */
  interface SchoolFieldRefs {
    readonly id: FieldRef<"School", 'Int'>
    readonly name: FieldRef<"School", 'String'>
    readonly schoolId: FieldRef<"School", 'String'>
    readonly instructor: FieldRef<"School", 'String'>
    readonly students: FieldRef<"School", 'Int'>
    readonly createdAt: FieldRef<"School", 'DateTime'>
    readonly updatedAt: FieldRef<"School", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * School findUnique
   */
  export type SchoolFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the School
     */
    select?: SchoolSelect<ExtArgs> | null
    /**
     * Omit specific fields from the School
     */
    omit?: SchoolOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolInclude<ExtArgs> | null
    /**
     * Filter, which School to fetch.
     */
    where: SchoolWhereUniqueInput
  }

  /**
   * School findUniqueOrThrow
   */
  export type SchoolFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the School
     */
    select?: SchoolSelect<ExtArgs> | null
    /**
     * Omit specific fields from the School
     */
    omit?: SchoolOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolInclude<ExtArgs> | null
    /**
     * Filter, which School to fetch.
     */
    where: SchoolWhereUniqueInput
  }

  /**
   * School findFirst
   */
  export type SchoolFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the School
     */
    select?: SchoolSelect<ExtArgs> | null
    /**
     * Omit specific fields from the School
     */
    omit?: SchoolOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolInclude<ExtArgs> | null
    /**
     * Filter, which School to fetch.
     */
    where?: SchoolWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Schools to fetch.
     */
    orderBy?: SchoolOrderByWithRelationInput | SchoolOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Schools.
     */
    cursor?: SchoolWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Schools from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Schools.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Schools.
     */
    distinct?: SchoolScalarFieldEnum | SchoolScalarFieldEnum[]
  }

  /**
   * School findFirstOrThrow
   */
  export type SchoolFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the School
     */
    select?: SchoolSelect<ExtArgs> | null
    /**
     * Omit specific fields from the School
     */
    omit?: SchoolOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolInclude<ExtArgs> | null
    /**
     * Filter, which School to fetch.
     */
    where?: SchoolWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Schools to fetch.
     */
    orderBy?: SchoolOrderByWithRelationInput | SchoolOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Schools.
     */
    cursor?: SchoolWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Schools from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Schools.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Schools.
     */
    distinct?: SchoolScalarFieldEnum | SchoolScalarFieldEnum[]
  }

  /**
   * School findMany
   */
  export type SchoolFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the School
     */
    select?: SchoolSelect<ExtArgs> | null
    /**
     * Omit specific fields from the School
     */
    omit?: SchoolOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolInclude<ExtArgs> | null
    /**
     * Filter, which Schools to fetch.
     */
    where?: SchoolWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Schools to fetch.
     */
    orderBy?: SchoolOrderByWithRelationInput | SchoolOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Schools.
     */
    cursor?: SchoolWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Schools from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Schools.
     */
    skip?: number
    distinct?: SchoolScalarFieldEnum | SchoolScalarFieldEnum[]
  }

  /**
   * School create
   */
  export type SchoolCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the School
     */
    select?: SchoolSelect<ExtArgs> | null
    /**
     * Omit specific fields from the School
     */
    omit?: SchoolOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolInclude<ExtArgs> | null
    /**
     * The data needed to create a School.
     */
    data: XOR<SchoolCreateInput, SchoolUncheckedCreateInput>
  }

  /**
   * School createMany
   */
  export type SchoolCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Schools.
     */
    data: SchoolCreateManyInput | SchoolCreateManyInput[]
  }

  /**
   * School createManyAndReturn
   */
  export type SchoolCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the School
     */
    select?: SchoolSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the School
     */
    omit?: SchoolOmit<ExtArgs> | null
    /**
     * The data used to create many Schools.
     */
    data: SchoolCreateManyInput | SchoolCreateManyInput[]
  }

  /**
   * School update
   */
  export type SchoolUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the School
     */
    select?: SchoolSelect<ExtArgs> | null
    /**
     * Omit specific fields from the School
     */
    omit?: SchoolOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolInclude<ExtArgs> | null
    /**
     * The data needed to update a School.
     */
    data: XOR<SchoolUpdateInput, SchoolUncheckedUpdateInput>
    /**
     * Choose, which School to update.
     */
    where: SchoolWhereUniqueInput
  }

  /**
   * School updateMany
   */
  export type SchoolUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Schools.
     */
    data: XOR<SchoolUpdateManyMutationInput, SchoolUncheckedUpdateManyInput>
    /**
     * Filter which Schools to update
     */
    where?: SchoolWhereInput
    /**
     * Limit how many Schools to update.
     */
    limit?: number
  }

  /**
   * School updateManyAndReturn
   */
  export type SchoolUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the School
     */
    select?: SchoolSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the School
     */
    omit?: SchoolOmit<ExtArgs> | null
    /**
     * The data used to update Schools.
     */
    data: XOR<SchoolUpdateManyMutationInput, SchoolUncheckedUpdateManyInput>
    /**
     * Filter which Schools to update
     */
    where?: SchoolWhereInput
    /**
     * Limit how many Schools to update.
     */
    limit?: number
  }

  /**
   * School upsert
   */
  export type SchoolUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the School
     */
    select?: SchoolSelect<ExtArgs> | null
    /**
     * Omit specific fields from the School
     */
    omit?: SchoolOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolInclude<ExtArgs> | null
    /**
     * The filter to search for the School to update in case it exists.
     */
    where: SchoolWhereUniqueInput
    /**
     * In case the School found by the `where` argument doesn't exist, create a new School with this data.
     */
    create: XOR<SchoolCreateInput, SchoolUncheckedCreateInput>
    /**
     * In case the School was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SchoolUpdateInput, SchoolUncheckedUpdateInput>
  }

  /**
   * School delete
   */
  export type SchoolDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the School
     */
    select?: SchoolSelect<ExtArgs> | null
    /**
     * Omit specific fields from the School
     */
    omit?: SchoolOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolInclude<ExtArgs> | null
    /**
     * Filter which School to delete.
     */
    where: SchoolWhereUniqueInput
  }

  /**
   * School deleteMany
   */
  export type SchoolDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Schools to delete
     */
    where?: SchoolWhereInput
    /**
     * Limit how many Schools to delete.
     */
    limit?: number
  }

  /**
   * School.users
   */
  export type School$usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    cursor?: UserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * School without action
   */
  export type SchoolDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the School
     */
    select?: SchoolSelect<ExtArgs> | null
    /**
     * Omit specific fields from the School
     */
    omit?: SchoolOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolInclude<ExtArgs> | null
  }


  /**
   * Model ProgramSettings
   */

  export type AggregateProgramSettings = {
    _count: ProgramSettingsCountAggregateOutputType | null
    _avg: ProgramSettingsAvgAggregateOutputType | null
    _sum: ProgramSettingsSumAggregateOutputType | null
    _min: ProgramSettingsMinAggregateOutputType | null
    _max: ProgramSettingsMaxAggregateOutputType | null
  }

  export type ProgramSettingsAvgAggregateOutputType = {
    id: number | null
  }

  export type ProgramSettingsSumAggregateOutputType = {
    id: number | null
  }

  export type ProgramSettingsMinAggregateOutputType = {
    id: number | null
    projectHeader: string | null
    principalInvestigator: string | null
    projectName: string | null
    staffEmail: string | null
    organismName: string | null
    orfContactInformation: string | null
    cloningVector: string | null
    sequencePrimer: string | null
    libraryName: string | null
    restrictionEnzyme: string | null
    description: string | null
    welcomeText: string | null
    overview: string | null
    collectDemographics: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProgramSettingsMaxAggregateOutputType = {
    id: number | null
    projectHeader: string | null
    principalInvestigator: string | null
    projectName: string | null
    staffEmail: string | null
    organismName: string | null
    orfContactInformation: string | null
    cloningVector: string | null
    sequencePrimer: string | null
    libraryName: string | null
    restrictionEnzyme: string | null
    description: string | null
    welcomeText: string | null
    overview: string | null
    collectDemographics: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProgramSettingsCountAggregateOutputType = {
    id: number
    projectHeader: number
    principalInvestigator: number
    projectName: number
    staffEmail: number
    organismName: number
    orfContactInformation: number
    cloningVector: number
    sequencePrimer: number
    libraryName: number
    restrictionEnzyme: number
    description: number
    welcomeText: number
    overview: number
    collectDemographics: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ProgramSettingsAvgAggregateInputType = {
    id?: true
  }

  export type ProgramSettingsSumAggregateInputType = {
    id?: true
  }

  export type ProgramSettingsMinAggregateInputType = {
    id?: true
    projectHeader?: true
    principalInvestigator?: true
    projectName?: true
    staffEmail?: true
    organismName?: true
    orfContactInformation?: true
    cloningVector?: true
    sequencePrimer?: true
    libraryName?: true
    restrictionEnzyme?: true
    description?: true
    welcomeText?: true
    overview?: true
    collectDemographics?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProgramSettingsMaxAggregateInputType = {
    id?: true
    projectHeader?: true
    principalInvestigator?: true
    projectName?: true
    staffEmail?: true
    organismName?: true
    orfContactInformation?: true
    cloningVector?: true
    sequencePrimer?: true
    libraryName?: true
    restrictionEnzyme?: true
    description?: true
    welcomeText?: true
    overview?: true
    collectDemographics?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProgramSettingsCountAggregateInputType = {
    id?: true
    projectHeader?: true
    principalInvestigator?: true
    projectName?: true
    staffEmail?: true
    organismName?: true
    orfContactInformation?: true
    cloningVector?: true
    sequencePrimer?: true
    libraryName?: true
    restrictionEnzyme?: true
    description?: true
    welcomeText?: true
    overview?: true
    collectDemographics?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ProgramSettingsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProgramSettings to aggregate.
     */
    where?: ProgramSettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProgramSettings to fetch.
     */
    orderBy?: ProgramSettingsOrderByWithRelationInput | ProgramSettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProgramSettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProgramSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProgramSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProgramSettings
    **/
    _count?: true | ProgramSettingsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProgramSettingsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProgramSettingsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProgramSettingsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProgramSettingsMaxAggregateInputType
  }

  export type GetProgramSettingsAggregateType<T extends ProgramSettingsAggregateArgs> = {
        [P in keyof T & keyof AggregateProgramSettings]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProgramSettings[P]>
      : GetScalarType<T[P], AggregateProgramSettings[P]>
  }




  export type ProgramSettingsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProgramSettingsWhereInput
    orderBy?: ProgramSettingsOrderByWithAggregationInput | ProgramSettingsOrderByWithAggregationInput[]
    by: ProgramSettingsScalarFieldEnum[] | ProgramSettingsScalarFieldEnum
    having?: ProgramSettingsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProgramSettingsCountAggregateInputType | true
    _avg?: ProgramSettingsAvgAggregateInputType
    _sum?: ProgramSettingsSumAggregateInputType
    _min?: ProgramSettingsMinAggregateInputType
    _max?: ProgramSettingsMaxAggregateInputType
  }

  export type ProgramSettingsGroupByOutputType = {
    id: number
    projectHeader: string
    principalInvestigator: string | null
    projectName: string | null
    staffEmail: string | null
    organismName: string | null
    orfContactInformation: string | null
    cloningVector: string | null
    sequencePrimer: string | null
    libraryName: string | null
    restrictionEnzyme: string | null
    description: string | null
    welcomeText: string | null
    overview: string | null
    collectDemographics: boolean
    createdAt: Date
    updatedAt: Date
    _count: ProgramSettingsCountAggregateOutputType | null
    _avg: ProgramSettingsAvgAggregateOutputType | null
    _sum: ProgramSettingsSumAggregateOutputType | null
    _min: ProgramSettingsMinAggregateOutputType | null
    _max: ProgramSettingsMaxAggregateOutputType | null
  }

  type GetProgramSettingsGroupByPayload<T extends ProgramSettingsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProgramSettingsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProgramSettingsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProgramSettingsGroupByOutputType[P]>
            : GetScalarType<T[P], ProgramSettingsGroupByOutputType[P]>
        }
      >
    >


  export type ProgramSettingsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projectHeader?: boolean
    principalInvestigator?: boolean
    projectName?: boolean
    staffEmail?: boolean
    organismName?: boolean
    orfContactInformation?: boolean
    cloningVector?: boolean
    sequencePrimer?: boolean
    libraryName?: boolean
    restrictionEnzyme?: boolean
    description?: boolean
    welcomeText?: boolean
    overview?: boolean
    collectDemographics?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["programSettings"]>

  export type ProgramSettingsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projectHeader?: boolean
    principalInvestigator?: boolean
    projectName?: boolean
    staffEmail?: boolean
    organismName?: boolean
    orfContactInformation?: boolean
    cloningVector?: boolean
    sequencePrimer?: boolean
    libraryName?: boolean
    restrictionEnzyme?: boolean
    description?: boolean
    welcomeText?: boolean
    overview?: boolean
    collectDemographics?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["programSettings"]>

  export type ProgramSettingsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projectHeader?: boolean
    principalInvestigator?: boolean
    projectName?: boolean
    staffEmail?: boolean
    organismName?: boolean
    orfContactInformation?: boolean
    cloningVector?: boolean
    sequencePrimer?: boolean
    libraryName?: boolean
    restrictionEnzyme?: boolean
    description?: boolean
    welcomeText?: boolean
    overview?: boolean
    collectDemographics?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["programSettings"]>

  export type ProgramSettingsSelectScalar = {
    id?: boolean
    projectHeader?: boolean
    principalInvestigator?: boolean
    projectName?: boolean
    staffEmail?: boolean
    organismName?: boolean
    orfContactInformation?: boolean
    cloningVector?: boolean
    sequencePrimer?: boolean
    libraryName?: boolean
    restrictionEnzyme?: boolean
    description?: boolean
    welcomeText?: boolean
    overview?: boolean
    collectDemographics?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ProgramSettingsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "projectHeader" | "principalInvestigator" | "projectName" | "staffEmail" | "organismName" | "orfContactInformation" | "cloningVector" | "sequencePrimer" | "libraryName" | "restrictionEnzyme" | "description" | "welcomeText" | "overview" | "collectDemographics" | "createdAt" | "updatedAt", ExtArgs["result"]["programSettings"]>

  export type $ProgramSettingsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ProgramSettings"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      projectHeader: string
      principalInvestigator: string | null
      projectName: string | null
      staffEmail: string | null
      organismName: string | null
      orfContactInformation: string | null
      cloningVector: string | null
      sequencePrimer: string | null
      libraryName: string | null
      restrictionEnzyme: string | null
      description: string | null
      welcomeText: string | null
      overview: string | null
      collectDemographics: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["programSettings"]>
    composites: {}
  }

  type ProgramSettingsGetPayload<S extends boolean | null | undefined | ProgramSettingsDefaultArgs> = $Result.GetResult<Prisma.$ProgramSettingsPayload, S>

  type ProgramSettingsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProgramSettingsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProgramSettingsCountAggregateInputType | true
    }

  export interface ProgramSettingsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ProgramSettings'], meta: { name: 'ProgramSettings' } }
    /**
     * Find zero or one ProgramSettings that matches the filter.
     * @param {ProgramSettingsFindUniqueArgs} args - Arguments to find a ProgramSettings
     * @example
     * // Get one ProgramSettings
     * const programSettings = await prisma.programSettings.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProgramSettingsFindUniqueArgs>(args: SelectSubset<T, ProgramSettingsFindUniqueArgs<ExtArgs>>): Prisma__ProgramSettingsClient<$Result.GetResult<Prisma.$ProgramSettingsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ProgramSettings that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProgramSettingsFindUniqueOrThrowArgs} args - Arguments to find a ProgramSettings
     * @example
     * // Get one ProgramSettings
     * const programSettings = await prisma.programSettings.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProgramSettingsFindUniqueOrThrowArgs>(args: SelectSubset<T, ProgramSettingsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProgramSettingsClient<$Result.GetResult<Prisma.$ProgramSettingsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProgramSettings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProgramSettingsFindFirstArgs} args - Arguments to find a ProgramSettings
     * @example
     * // Get one ProgramSettings
     * const programSettings = await prisma.programSettings.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProgramSettingsFindFirstArgs>(args?: SelectSubset<T, ProgramSettingsFindFirstArgs<ExtArgs>>): Prisma__ProgramSettingsClient<$Result.GetResult<Prisma.$ProgramSettingsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProgramSettings that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProgramSettingsFindFirstOrThrowArgs} args - Arguments to find a ProgramSettings
     * @example
     * // Get one ProgramSettings
     * const programSettings = await prisma.programSettings.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProgramSettingsFindFirstOrThrowArgs>(args?: SelectSubset<T, ProgramSettingsFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProgramSettingsClient<$Result.GetResult<Prisma.$ProgramSettingsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ProgramSettings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProgramSettingsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProgramSettings
     * const programSettings = await prisma.programSettings.findMany()
     * 
     * // Get first 10 ProgramSettings
     * const programSettings = await prisma.programSettings.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const programSettingsWithIdOnly = await prisma.programSettings.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProgramSettingsFindManyArgs>(args?: SelectSubset<T, ProgramSettingsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProgramSettingsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ProgramSettings.
     * @param {ProgramSettingsCreateArgs} args - Arguments to create a ProgramSettings.
     * @example
     * // Create one ProgramSettings
     * const ProgramSettings = await prisma.programSettings.create({
     *   data: {
     *     // ... data to create a ProgramSettings
     *   }
     * })
     * 
     */
    create<T extends ProgramSettingsCreateArgs>(args: SelectSubset<T, ProgramSettingsCreateArgs<ExtArgs>>): Prisma__ProgramSettingsClient<$Result.GetResult<Prisma.$ProgramSettingsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ProgramSettings.
     * @param {ProgramSettingsCreateManyArgs} args - Arguments to create many ProgramSettings.
     * @example
     * // Create many ProgramSettings
     * const programSettings = await prisma.programSettings.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProgramSettingsCreateManyArgs>(args?: SelectSubset<T, ProgramSettingsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ProgramSettings and returns the data saved in the database.
     * @param {ProgramSettingsCreateManyAndReturnArgs} args - Arguments to create many ProgramSettings.
     * @example
     * // Create many ProgramSettings
     * const programSettings = await prisma.programSettings.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ProgramSettings and only return the `id`
     * const programSettingsWithIdOnly = await prisma.programSettings.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProgramSettingsCreateManyAndReturnArgs>(args?: SelectSubset<T, ProgramSettingsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProgramSettingsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ProgramSettings.
     * @param {ProgramSettingsDeleteArgs} args - Arguments to delete one ProgramSettings.
     * @example
     * // Delete one ProgramSettings
     * const ProgramSettings = await prisma.programSettings.delete({
     *   where: {
     *     // ... filter to delete one ProgramSettings
     *   }
     * })
     * 
     */
    delete<T extends ProgramSettingsDeleteArgs>(args: SelectSubset<T, ProgramSettingsDeleteArgs<ExtArgs>>): Prisma__ProgramSettingsClient<$Result.GetResult<Prisma.$ProgramSettingsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ProgramSettings.
     * @param {ProgramSettingsUpdateArgs} args - Arguments to update one ProgramSettings.
     * @example
     * // Update one ProgramSettings
     * const programSettings = await prisma.programSettings.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProgramSettingsUpdateArgs>(args: SelectSubset<T, ProgramSettingsUpdateArgs<ExtArgs>>): Prisma__ProgramSettingsClient<$Result.GetResult<Prisma.$ProgramSettingsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ProgramSettings.
     * @param {ProgramSettingsDeleteManyArgs} args - Arguments to filter ProgramSettings to delete.
     * @example
     * // Delete a few ProgramSettings
     * const { count } = await prisma.programSettings.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProgramSettingsDeleteManyArgs>(args?: SelectSubset<T, ProgramSettingsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProgramSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProgramSettingsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProgramSettings
     * const programSettings = await prisma.programSettings.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProgramSettingsUpdateManyArgs>(args: SelectSubset<T, ProgramSettingsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProgramSettings and returns the data updated in the database.
     * @param {ProgramSettingsUpdateManyAndReturnArgs} args - Arguments to update many ProgramSettings.
     * @example
     * // Update many ProgramSettings
     * const programSettings = await prisma.programSettings.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ProgramSettings and only return the `id`
     * const programSettingsWithIdOnly = await prisma.programSettings.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ProgramSettingsUpdateManyAndReturnArgs>(args: SelectSubset<T, ProgramSettingsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProgramSettingsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ProgramSettings.
     * @param {ProgramSettingsUpsertArgs} args - Arguments to update or create a ProgramSettings.
     * @example
     * // Update or create a ProgramSettings
     * const programSettings = await prisma.programSettings.upsert({
     *   create: {
     *     // ... data to create a ProgramSettings
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProgramSettings we want to update
     *   }
     * })
     */
    upsert<T extends ProgramSettingsUpsertArgs>(args: SelectSubset<T, ProgramSettingsUpsertArgs<ExtArgs>>): Prisma__ProgramSettingsClient<$Result.GetResult<Prisma.$ProgramSettingsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ProgramSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProgramSettingsCountArgs} args - Arguments to filter ProgramSettings to count.
     * @example
     * // Count the number of ProgramSettings
     * const count = await prisma.programSettings.count({
     *   where: {
     *     // ... the filter for the ProgramSettings we want to count
     *   }
     * })
    **/
    count<T extends ProgramSettingsCountArgs>(
      args?: Subset<T, ProgramSettingsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProgramSettingsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProgramSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProgramSettingsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProgramSettingsAggregateArgs>(args: Subset<T, ProgramSettingsAggregateArgs>): Prisma.PrismaPromise<GetProgramSettingsAggregateType<T>>

    /**
     * Group by ProgramSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProgramSettingsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProgramSettingsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProgramSettingsGroupByArgs['orderBy'] }
        : { orderBy?: ProgramSettingsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProgramSettingsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProgramSettingsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ProgramSettings model
   */
  readonly fields: ProgramSettingsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ProgramSettings.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProgramSettingsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ProgramSettings model
   */
  interface ProgramSettingsFieldRefs {
    readonly id: FieldRef<"ProgramSettings", 'Int'>
    readonly projectHeader: FieldRef<"ProgramSettings", 'String'>
    readonly principalInvestigator: FieldRef<"ProgramSettings", 'String'>
    readonly projectName: FieldRef<"ProgramSettings", 'String'>
    readonly staffEmail: FieldRef<"ProgramSettings", 'String'>
    readonly organismName: FieldRef<"ProgramSettings", 'String'>
    readonly orfContactInformation: FieldRef<"ProgramSettings", 'String'>
    readonly cloningVector: FieldRef<"ProgramSettings", 'String'>
    readonly sequencePrimer: FieldRef<"ProgramSettings", 'String'>
    readonly libraryName: FieldRef<"ProgramSettings", 'String'>
    readonly restrictionEnzyme: FieldRef<"ProgramSettings", 'String'>
    readonly description: FieldRef<"ProgramSettings", 'String'>
    readonly welcomeText: FieldRef<"ProgramSettings", 'String'>
    readonly overview: FieldRef<"ProgramSettings", 'String'>
    readonly collectDemographics: FieldRef<"ProgramSettings", 'Boolean'>
    readonly createdAt: FieldRef<"ProgramSettings", 'DateTime'>
    readonly updatedAt: FieldRef<"ProgramSettings", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ProgramSettings findUnique
   */
  export type ProgramSettingsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProgramSettings
     */
    select?: ProgramSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProgramSettings
     */
    omit?: ProgramSettingsOmit<ExtArgs> | null
    /**
     * Filter, which ProgramSettings to fetch.
     */
    where: ProgramSettingsWhereUniqueInput
  }

  /**
   * ProgramSettings findUniqueOrThrow
   */
  export type ProgramSettingsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProgramSettings
     */
    select?: ProgramSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProgramSettings
     */
    omit?: ProgramSettingsOmit<ExtArgs> | null
    /**
     * Filter, which ProgramSettings to fetch.
     */
    where: ProgramSettingsWhereUniqueInput
  }

  /**
   * ProgramSettings findFirst
   */
  export type ProgramSettingsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProgramSettings
     */
    select?: ProgramSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProgramSettings
     */
    omit?: ProgramSettingsOmit<ExtArgs> | null
    /**
     * Filter, which ProgramSettings to fetch.
     */
    where?: ProgramSettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProgramSettings to fetch.
     */
    orderBy?: ProgramSettingsOrderByWithRelationInput | ProgramSettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProgramSettings.
     */
    cursor?: ProgramSettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProgramSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProgramSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProgramSettings.
     */
    distinct?: ProgramSettingsScalarFieldEnum | ProgramSettingsScalarFieldEnum[]
  }

  /**
   * ProgramSettings findFirstOrThrow
   */
  export type ProgramSettingsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProgramSettings
     */
    select?: ProgramSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProgramSettings
     */
    omit?: ProgramSettingsOmit<ExtArgs> | null
    /**
     * Filter, which ProgramSettings to fetch.
     */
    where?: ProgramSettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProgramSettings to fetch.
     */
    orderBy?: ProgramSettingsOrderByWithRelationInput | ProgramSettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProgramSettings.
     */
    cursor?: ProgramSettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProgramSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProgramSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProgramSettings.
     */
    distinct?: ProgramSettingsScalarFieldEnum | ProgramSettingsScalarFieldEnum[]
  }

  /**
   * ProgramSettings findMany
   */
  export type ProgramSettingsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProgramSettings
     */
    select?: ProgramSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProgramSettings
     */
    omit?: ProgramSettingsOmit<ExtArgs> | null
    /**
     * Filter, which ProgramSettings to fetch.
     */
    where?: ProgramSettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProgramSettings to fetch.
     */
    orderBy?: ProgramSettingsOrderByWithRelationInput | ProgramSettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProgramSettings.
     */
    cursor?: ProgramSettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProgramSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProgramSettings.
     */
    skip?: number
    distinct?: ProgramSettingsScalarFieldEnum | ProgramSettingsScalarFieldEnum[]
  }

  /**
   * ProgramSettings create
   */
  export type ProgramSettingsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProgramSettings
     */
    select?: ProgramSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProgramSettings
     */
    omit?: ProgramSettingsOmit<ExtArgs> | null
    /**
     * The data needed to create a ProgramSettings.
     */
    data: XOR<ProgramSettingsCreateInput, ProgramSettingsUncheckedCreateInput>
  }

  /**
   * ProgramSettings createMany
   */
  export type ProgramSettingsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ProgramSettings.
     */
    data: ProgramSettingsCreateManyInput | ProgramSettingsCreateManyInput[]
  }

  /**
   * ProgramSettings createManyAndReturn
   */
  export type ProgramSettingsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProgramSettings
     */
    select?: ProgramSettingsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ProgramSettings
     */
    omit?: ProgramSettingsOmit<ExtArgs> | null
    /**
     * The data used to create many ProgramSettings.
     */
    data: ProgramSettingsCreateManyInput | ProgramSettingsCreateManyInput[]
  }

  /**
   * ProgramSettings update
   */
  export type ProgramSettingsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProgramSettings
     */
    select?: ProgramSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProgramSettings
     */
    omit?: ProgramSettingsOmit<ExtArgs> | null
    /**
     * The data needed to update a ProgramSettings.
     */
    data: XOR<ProgramSettingsUpdateInput, ProgramSettingsUncheckedUpdateInput>
    /**
     * Choose, which ProgramSettings to update.
     */
    where: ProgramSettingsWhereUniqueInput
  }

  /**
   * ProgramSettings updateMany
   */
  export type ProgramSettingsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ProgramSettings.
     */
    data: XOR<ProgramSettingsUpdateManyMutationInput, ProgramSettingsUncheckedUpdateManyInput>
    /**
     * Filter which ProgramSettings to update
     */
    where?: ProgramSettingsWhereInput
    /**
     * Limit how many ProgramSettings to update.
     */
    limit?: number
  }

  /**
   * ProgramSettings updateManyAndReturn
   */
  export type ProgramSettingsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProgramSettings
     */
    select?: ProgramSettingsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ProgramSettings
     */
    omit?: ProgramSettingsOmit<ExtArgs> | null
    /**
     * The data used to update ProgramSettings.
     */
    data: XOR<ProgramSettingsUpdateManyMutationInput, ProgramSettingsUncheckedUpdateManyInput>
    /**
     * Filter which ProgramSettings to update
     */
    where?: ProgramSettingsWhereInput
    /**
     * Limit how many ProgramSettings to update.
     */
    limit?: number
  }

  /**
   * ProgramSettings upsert
   */
  export type ProgramSettingsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProgramSettings
     */
    select?: ProgramSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProgramSettings
     */
    omit?: ProgramSettingsOmit<ExtArgs> | null
    /**
     * The filter to search for the ProgramSettings to update in case it exists.
     */
    where: ProgramSettingsWhereUniqueInput
    /**
     * In case the ProgramSettings found by the `where` argument doesn't exist, create a new ProgramSettings with this data.
     */
    create: XOR<ProgramSettingsCreateInput, ProgramSettingsUncheckedCreateInput>
    /**
     * In case the ProgramSettings was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProgramSettingsUpdateInput, ProgramSettingsUncheckedUpdateInput>
  }

  /**
   * ProgramSettings delete
   */
  export type ProgramSettingsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProgramSettings
     */
    select?: ProgramSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProgramSettings
     */
    omit?: ProgramSettingsOmit<ExtArgs> | null
    /**
     * Filter which ProgramSettings to delete.
     */
    where: ProgramSettingsWhereUniqueInput
  }

  /**
   * ProgramSettings deleteMany
   */
  export type ProgramSettingsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProgramSettings to delete
     */
    where?: ProgramSettingsWhereInput
    /**
     * Limit how many ProgramSettings to delete.
     */
    limit?: number
  }

  /**
   * ProgramSettings without action
   */
  export type ProgramSettingsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProgramSettings
     */
    select?: ProgramSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProgramSettings
     */
    omit?: ProgramSettingsOmit<ExtArgs> | null
  }


  /**
   * Model Demographics
   */

  export type AggregateDemographics = {
    _count: DemographicsCountAggregateOutputType | null
    _avg: DemographicsAvgAggregateOutputType | null
    _sum: DemographicsSumAggregateOutputType | null
    _min: DemographicsMinAggregateOutputType | null
    _max: DemographicsMaxAggregateOutputType | null
  }

  export type DemographicsAvgAggregateOutputType = {
    id: number | null
    userId: number | null
    age: number | null
  }

  export type DemographicsSumAggregateOutputType = {
    id: number | null
    userId: number | null
    age: number | null
  }

  export type DemographicsMinAggregateOutputType = {
    id: number | null
    userId: number | null
    academicYear: string | null
    yearsInProgram: string | null
    classesTaken: string | null
    otherScienceCourses: string | null
    age: number | null
    gender: string | null
    ethnicity: string | null
    educationLevel: string | null
    city: string | null
    state: string | null
    country: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DemographicsMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    academicYear: string | null
    yearsInProgram: string | null
    classesTaken: string | null
    otherScienceCourses: string | null
    age: number | null
    gender: string | null
    ethnicity: string | null
    educationLevel: string | null
    city: string | null
    state: string | null
    country: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DemographicsCountAggregateOutputType = {
    id: number
    userId: number
    academicYear: number
    yearsInProgram: number
    classesTaken: number
    otherScienceCourses: number
    age: number
    gender: number
    ethnicity: number
    educationLevel: number
    city: number
    state: number
    country: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type DemographicsAvgAggregateInputType = {
    id?: true
    userId?: true
    age?: true
  }

  export type DemographicsSumAggregateInputType = {
    id?: true
    userId?: true
    age?: true
  }

  export type DemographicsMinAggregateInputType = {
    id?: true
    userId?: true
    academicYear?: true
    yearsInProgram?: true
    classesTaken?: true
    otherScienceCourses?: true
    age?: true
    gender?: true
    ethnicity?: true
    educationLevel?: true
    city?: true
    state?: true
    country?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DemographicsMaxAggregateInputType = {
    id?: true
    userId?: true
    academicYear?: true
    yearsInProgram?: true
    classesTaken?: true
    otherScienceCourses?: true
    age?: true
    gender?: true
    ethnicity?: true
    educationLevel?: true
    city?: true
    state?: true
    country?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DemographicsCountAggregateInputType = {
    id?: true
    userId?: true
    academicYear?: true
    yearsInProgram?: true
    classesTaken?: true
    otherScienceCourses?: true
    age?: true
    gender?: true
    ethnicity?: true
    educationLevel?: true
    city?: true
    state?: true
    country?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type DemographicsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Demographics to aggregate.
     */
    where?: DemographicsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Demographics to fetch.
     */
    orderBy?: DemographicsOrderByWithRelationInput | DemographicsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DemographicsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Demographics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Demographics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Demographics
    **/
    _count?: true | DemographicsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DemographicsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DemographicsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DemographicsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DemographicsMaxAggregateInputType
  }

  export type GetDemographicsAggregateType<T extends DemographicsAggregateArgs> = {
        [P in keyof T & keyof AggregateDemographics]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDemographics[P]>
      : GetScalarType<T[P], AggregateDemographics[P]>
  }




  export type DemographicsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DemographicsWhereInput
    orderBy?: DemographicsOrderByWithAggregationInput | DemographicsOrderByWithAggregationInput[]
    by: DemographicsScalarFieldEnum[] | DemographicsScalarFieldEnum
    having?: DemographicsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DemographicsCountAggregateInputType | true
    _avg?: DemographicsAvgAggregateInputType
    _sum?: DemographicsSumAggregateInputType
    _min?: DemographicsMinAggregateInputType
    _max?: DemographicsMaxAggregateInputType
  }

  export type DemographicsGroupByOutputType = {
    id: number
    userId: number
    academicYear: string | null
    yearsInProgram: string | null
    classesTaken: string | null
    otherScienceCourses: string | null
    age: number | null
    gender: string | null
    ethnicity: string | null
    educationLevel: string | null
    city: string | null
    state: string | null
    country: string | null
    createdAt: Date
    updatedAt: Date
    _count: DemographicsCountAggregateOutputType | null
    _avg: DemographicsAvgAggregateOutputType | null
    _sum: DemographicsSumAggregateOutputType | null
    _min: DemographicsMinAggregateOutputType | null
    _max: DemographicsMaxAggregateOutputType | null
  }

  type GetDemographicsGroupByPayload<T extends DemographicsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DemographicsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DemographicsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DemographicsGroupByOutputType[P]>
            : GetScalarType<T[P], DemographicsGroupByOutputType[P]>
        }
      >
    >


  export type DemographicsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    academicYear?: boolean
    yearsInProgram?: boolean
    classesTaken?: boolean
    otherScienceCourses?: boolean
    age?: boolean
    gender?: boolean
    ethnicity?: boolean
    educationLevel?: boolean
    city?: boolean
    state?: boolean
    country?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["demographics"]>

  export type DemographicsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    academicYear?: boolean
    yearsInProgram?: boolean
    classesTaken?: boolean
    otherScienceCourses?: boolean
    age?: boolean
    gender?: boolean
    ethnicity?: boolean
    educationLevel?: boolean
    city?: boolean
    state?: boolean
    country?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["demographics"]>

  export type DemographicsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    academicYear?: boolean
    yearsInProgram?: boolean
    classesTaken?: boolean
    otherScienceCourses?: boolean
    age?: boolean
    gender?: boolean
    ethnicity?: boolean
    educationLevel?: boolean
    city?: boolean
    state?: boolean
    country?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["demographics"]>

  export type DemographicsSelectScalar = {
    id?: boolean
    userId?: boolean
    academicYear?: boolean
    yearsInProgram?: boolean
    classesTaken?: boolean
    otherScienceCourses?: boolean
    age?: boolean
    gender?: boolean
    ethnicity?: boolean
    educationLevel?: boolean
    city?: boolean
    state?: boolean
    country?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type DemographicsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "academicYear" | "yearsInProgram" | "classesTaken" | "otherScienceCourses" | "age" | "gender" | "ethnicity" | "educationLevel" | "city" | "state" | "country" | "createdAt" | "updatedAt", ExtArgs["result"]["demographics"]>
  export type DemographicsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type DemographicsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type DemographicsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $DemographicsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Demographics"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userId: number
      academicYear: string | null
      yearsInProgram: string | null
      classesTaken: string | null
      otherScienceCourses: string | null
      age: number | null
      gender: string | null
      ethnicity: string | null
      educationLevel: string | null
      city: string | null
      state: string | null
      country: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["demographics"]>
    composites: {}
  }

  type DemographicsGetPayload<S extends boolean | null | undefined | DemographicsDefaultArgs> = $Result.GetResult<Prisma.$DemographicsPayload, S>

  type DemographicsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DemographicsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DemographicsCountAggregateInputType | true
    }

  export interface DemographicsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Demographics'], meta: { name: 'Demographics' } }
    /**
     * Find zero or one Demographics that matches the filter.
     * @param {DemographicsFindUniqueArgs} args - Arguments to find a Demographics
     * @example
     * // Get one Demographics
     * const demographics = await prisma.demographics.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DemographicsFindUniqueArgs>(args: SelectSubset<T, DemographicsFindUniqueArgs<ExtArgs>>): Prisma__DemographicsClient<$Result.GetResult<Prisma.$DemographicsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Demographics that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DemographicsFindUniqueOrThrowArgs} args - Arguments to find a Demographics
     * @example
     * // Get one Demographics
     * const demographics = await prisma.demographics.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DemographicsFindUniqueOrThrowArgs>(args: SelectSubset<T, DemographicsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DemographicsClient<$Result.GetResult<Prisma.$DemographicsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Demographics that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DemographicsFindFirstArgs} args - Arguments to find a Demographics
     * @example
     * // Get one Demographics
     * const demographics = await prisma.demographics.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DemographicsFindFirstArgs>(args?: SelectSubset<T, DemographicsFindFirstArgs<ExtArgs>>): Prisma__DemographicsClient<$Result.GetResult<Prisma.$DemographicsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Demographics that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DemographicsFindFirstOrThrowArgs} args - Arguments to find a Demographics
     * @example
     * // Get one Demographics
     * const demographics = await prisma.demographics.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DemographicsFindFirstOrThrowArgs>(args?: SelectSubset<T, DemographicsFindFirstOrThrowArgs<ExtArgs>>): Prisma__DemographicsClient<$Result.GetResult<Prisma.$DemographicsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Demographics that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DemographicsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Demographics
     * const demographics = await prisma.demographics.findMany()
     * 
     * // Get first 10 Demographics
     * const demographics = await prisma.demographics.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const demographicsWithIdOnly = await prisma.demographics.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DemographicsFindManyArgs>(args?: SelectSubset<T, DemographicsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DemographicsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Demographics.
     * @param {DemographicsCreateArgs} args - Arguments to create a Demographics.
     * @example
     * // Create one Demographics
     * const Demographics = await prisma.demographics.create({
     *   data: {
     *     // ... data to create a Demographics
     *   }
     * })
     * 
     */
    create<T extends DemographicsCreateArgs>(args: SelectSubset<T, DemographicsCreateArgs<ExtArgs>>): Prisma__DemographicsClient<$Result.GetResult<Prisma.$DemographicsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Demographics.
     * @param {DemographicsCreateManyArgs} args - Arguments to create many Demographics.
     * @example
     * // Create many Demographics
     * const demographics = await prisma.demographics.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DemographicsCreateManyArgs>(args?: SelectSubset<T, DemographicsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Demographics and returns the data saved in the database.
     * @param {DemographicsCreateManyAndReturnArgs} args - Arguments to create many Demographics.
     * @example
     * // Create many Demographics
     * const demographics = await prisma.demographics.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Demographics and only return the `id`
     * const demographicsWithIdOnly = await prisma.demographics.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DemographicsCreateManyAndReturnArgs>(args?: SelectSubset<T, DemographicsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DemographicsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Demographics.
     * @param {DemographicsDeleteArgs} args - Arguments to delete one Demographics.
     * @example
     * // Delete one Demographics
     * const Demographics = await prisma.demographics.delete({
     *   where: {
     *     // ... filter to delete one Demographics
     *   }
     * })
     * 
     */
    delete<T extends DemographicsDeleteArgs>(args: SelectSubset<T, DemographicsDeleteArgs<ExtArgs>>): Prisma__DemographicsClient<$Result.GetResult<Prisma.$DemographicsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Demographics.
     * @param {DemographicsUpdateArgs} args - Arguments to update one Demographics.
     * @example
     * // Update one Demographics
     * const demographics = await prisma.demographics.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DemographicsUpdateArgs>(args: SelectSubset<T, DemographicsUpdateArgs<ExtArgs>>): Prisma__DemographicsClient<$Result.GetResult<Prisma.$DemographicsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Demographics.
     * @param {DemographicsDeleteManyArgs} args - Arguments to filter Demographics to delete.
     * @example
     * // Delete a few Demographics
     * const { count } = await prisma.demographics.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DemographicsDeleteManyArgs>(args?: SelectSubset<T, DemographicsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Demographics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DemographicsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Demographics
     * const demographics = await prisma.demographics.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DemographicsUpdateManyArgs>(args: SelectSubset<T, DemographicsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Demographics and returns the data updated in the database.
     * @param {DemographicsUpdateManyAndReturnArgs} args - Arguments to update many Demographics.
     * @example
     * // Update many Demographics
     * const demographics = await prisma.demographics.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Demographics and only return the `id`
     * const demographicsWithIdOnly = await prisma.demographics.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends DemographicsUpdateManyAndReturnArgs>(args: SelectSubset<T, DemographicsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DemographicsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Demographics.
     * @param {DemographicsUpsertArgs} args - Arguments to update or create a Demographics.
     * @example
     * // Update or create a Demographics
     * const demographics = await prisma.demographics.upsert({
     *   create: {
     *     // ... data to create a Demographics
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Demographics we want to update
     *   }
     * })
     */
    upsert<T extends DemographicsUpsertArgs>(args: SelectSubset<T, DemographicsUpsertArgs<ExtArgs>>): Prisma__DemographicsClient<$Result.GetResult<Prisma.$DemographicsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Demographics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DemographicsCountArgs} args - Arguments to filter Demographics to count.
     * @example
     * // Count the number of Demographics
     * const count = await prisma.demographics.count({
     *   where: {
     *     // ... the filter for the Demographics we want to count
     *   }
     * })
    **/
    count<T extends DemographicsCountArgs>(
      args?: Subset<T, DemographicsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DemographicsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Demographics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DemographicsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DemographicsAggregateArgs>(args: Subset<T, DemographicsAggregateArgs>): Prisma.PrismaPromise<GetDemographicsAggregateType<T>>

    /**
     * Group by Demographics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DemographicsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DemographicsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DemographicsGroupByArgs['orderBy'] }
        : { orderBy?: DemographicsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DemographicsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDemographicsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Demographics model
   */
  readonly fields: DemographicsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Demographics.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DemographicsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Demographics model
   */
  interface DemographicsFieldRefs {
    readonly id: FieldRef<"Demographics", 'Int'>
    readonly userId: FieldRef<"Demographics", 'Int'>
    readonly academicYear: FieldRef<"Demographics", 'String'>
    readonly yearsInProgram: FieldRef<"Demographics", 'String'>
    readonly classesTaken: FieldRef<"Demographics", 'String'>
    readonly otherScienceCourses: FieldRef<"Demographics", 'String'>
    readonly age: FieldRef<"Demographics", 'Int'>
    readonly gender: FieldRef<"Demographics", 'String'>
    readonly ethnicity: FieldRef<"Demographics", 'String'>
    readonly educationLevel: FieldRef<"Demographics", 'String'>
    readonly city: FieldRef<"Demographics", 'String'>
    readonly state: FieldRef<"Demographics", 'String'>
    readonly country: FieldRef<"Demographics", 'String'>
    readonly createdAt: FieldRef<"Demographics", 'DateTime'>
    readonly updatedAt: FieldRef<"Demographics", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Demographics findUnique
   */
  export type DemographicsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Demographics
     */
    select?: DemographicsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Demographics
     */
    omit?: DemographicsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DemographicsInclude<ExtArgs> | null
    /**
     * Filter, which Demographics to fetch.
     */
    where: DemographicsWhereUniqueInput
  }

  /**
   * Demographics findUniqueOrThrow
   */
  export type DemographicsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Demographics
     */
    select?: DemographicsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Demographics
     */
    omit?: DemographicsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DemographicsInclude<ExtArgs> | null
    /**
     * Filter, which Demographics to fetch.
     */
    where: DemographicsWhereUniqueInput
  }

  /**
   * Demographics findFirst
   */
  export type DemographicsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Demographics
     */
    select?: DemographicsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Demographics
     */
    omit?: DemographicsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DemographicsInclude<ExtArgs> | null
    /**
     * Filter, which Demographics to fetch.
     */
    where?: DemographicsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Demographics to fetch.
     */
    orderBy?: DemographicsOrderByWithRelationInput | DemographicsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Demographics.
     */
    cursor?: DemographicsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Demographics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Demographics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Demographics.
     */
    distinct?: DemographicsScalarFieldEnum | DemographicsScalarFieldEnum[]
  }

  /**
   * Demographics findFirstOrThrow
   */
  export type DemographicsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Demographics
     */
    select?: DemographicsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Demographics
     */
    omit?: DemographicsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DemographicsInclude<ExtArgs> | null
    /**
     * Filter, which Demographics to fetch.
     */
    where?: DemographicsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Demographics to fetch.
     */
    orderBy?: DemographicsOrderByWithRelationInput | DemographicsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Demographics.
     */
    cursor?: DemographicsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Demographics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Demographics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Demographics.
     */
    distinct?: DemographicsScalarFieldEnum | DemographicsScalarFieldEnum[]
  }

  /**
   * Demographics findMany
   */
  export type DemographicsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Demographics
     */
    select?: DemographicsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Demographics
     */
    omit?: DemographicsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DemographicsInclude<ExtArgs> | null
    /**
     * Filter, which Demographics to fetch.
     */
    where?: DemographicsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Demographics to fetch.
     */
    orderBy?: DemographicsOrderByWithRelationInput | DemographicsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Demographics.
     */
    cursor?: DemographicsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Demographics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Demographics.
     */
    skip?: number
    distinct?: DemographicsScalarFieldEnum | DemographicsScalarFieldEnum[]
  }

  /**
   * Demographics create
   */
  export type DemographicsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Demographics
     */
    select?: DemographicsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Demographics
     */
    omit?: DemographicsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DemographicsInclude<ExtArgs> | null
    /**
     * The data needed to create a Demographics.
     */
    data: XOR<DemographicsCreateInput, DemographicsUncheckedCreateInput>
  }

  /**
   * Demographics createMany
   */
  export type DemographicsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Demographics.
     */
    data: DemographicsCreateManyInput | DemographicsCreateManyInput[]
  }

  /**
   * Demographics createManyAndReturn
   */
  export type DemographicsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Demographics
     */
    select?: DemographicsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Demographics
     */
    omit?: DemographicsOmit<ExtArgs> | null
    /**
     * The data used to create many Demographics.
     */
    data: DemographicsCreateManyInput | DemographicsCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DemographicsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Demographics update
   */
  export type DemographicsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Demographics
     */
    select?: DemographicsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Demographics
     */
    omit?: DemographicsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DemographicsInclude<ExtArgs> | null
    /**
     * The data needed to update a Demographics.
     */
    data: XOR<DemographicsUpdateInput, DemographicsUncheckedUpdateInput>
    /**
     * Choose, which Demographics to update.
     */
    where: DemographicsWhereUniqueInput
  }

  /**
   * Demographics updateMany
   */
  export type DemographicsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Demographics.
     */
    data: XOR<DemographicsUpdateManyMutationInput, DemographicsUncheckedUpdateManyInput>
    /**
     * Filter which Demographics to update
     */
    where?: DemographicsWhereInput
    /**
     * Limit how many Demographics to update.
     */
    limit?: number
  }

  /**
   * Demographics updateManyAndReturn
   */
  export type DemographicsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Demographics
     */
    select?: DemographicsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Demographics
     */
    omit?: DemographicsOmit<ExtArgs> | null
    /**
     * The data used to update Demographics.
     */
    data: XOR<DemographicsUpdateManyMutationInput, DemographicsUncheckedUpdateManyInput>
    /**
     * Filter which Demographics to update
     */
    where?: DemographicsWhereInput
    /**
     * Limit how many Demographics to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DemographicsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Demographics upsert
   */
  export type DemographicsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Demographics
     */
    select?: DemographicsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Demographics
     */
    omit?: DemographicsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DemographicsInclude<ExtArgs> | null
    /**
     * The filter to search for the Demographics to update in case it exists.
     */
    where: DemographicsWhereUniqueInput
    /**
     * In case the Demographics found by the `where` argument doesn't exist, create a new Demographics with this data.
     */
    create: XOR<DemographicsCreateInput, DemographicsUncheckedCreateInput>
    /**
     * In case the Demographics was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DemographicsUpdateInput, DemographicsUncheckedUpdateInput>
  }

  /**
   * Demographics delete
   */
  export type DemographicsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Demographics
     */
    select?: DemographicsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Demographics
     */
    omit?: DemographicsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DemographicsInclude<ExtArgs> | null
    /**
     * Filter which Demographics to delete.
     */
    where: DemographicsWhereUniqueInput
  }

  /**
   * Demographics deleteMany
   */
  export type DemographicsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Demographics to delete
     */
    where?: DemographicsWhereInput
    /**
     * Limit how many Demographics to delete.
     */
    limit?: number
  }

  /**
   * Demographics without action
   */
  export type DemographicsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Demographics
     */
    select?: DemographicsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Demographics
     */
    omit?: DemographicsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DemographicsInclude<ExtArgs> | null
  }


  /**
   * Model LoginLog
   */

  export type AggregateLoginLog = {
    _count: LoginLogCountAggregateOutputType | null
    _avg: LoginLogAvgAggregateOutputType | null
    _sum: LoginLogSumAggregateOutputType | null
    _min: LoginLogMinAggregateOutputType | null
    _max: LoginLogMaxAggregateOutputType | null
  }

  export type LoginLogAvgAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type LoginLogSumAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type LoginLogMinAggregateOutputType = {
    id: number | null
    userId: number | null
    loginTime: Date | null
    ipAddress: string | null
    userAgent: string | null
    success: boolean | null
    createdAt: Date | null
  }

  export type LoginLogMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    loginTime: Date | null
    ipAddress: string | null
    userAgent: string | null
    success: boolean | null
    createdAt: Date | null
  }

  export type LoginLogCountAggregateOutputType = {
    id: number
    userId: number
    loginTime: number
    ipAddress: number
    userAgent: number
    success: number
    createdAt: number
    _all: number
  }


  export type LoginLogAvgAggregateInputType = {
    id?: true
    userId?: true
  }

  export type LoginLogSumAggregateInputType = {
    id?: true
    userId?: true
  }

  export type LoginLogMinAggregateInputType = {
    id?: true
    userId?: true
    loginTime?: true
    ipAddress?: true
    userAgent?: true
    success?: true
    createdAt?: true
  }

  export type LoginLogMaxAggregateInputType = {
    id?: true
    userId?: true
    loginTime?: true
    ipAddress?: true
    userAgent?: true
    success?: true
    createdAt?: true
  }

  export type LoginLogCountAggregateInputType = {
    id?: true
    userId?: true
    loginTime?: true
    ipAddress?: true
    userAgent?: true
    success?: true
    createdAt?: true
    _all?: true
  }

  export type LoginLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LoginLog to aggregate.
     */
    where?: LoginLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LoginLogs to fetch.
     */
    orderBy?: LoginLogOrderByWithRelationInput | LoginLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LoginLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LoginLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LoginLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned LoginLogs
    **/
    _count?: true | LoginLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LoginLogAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LoginLogSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LoginLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LoginLogMaxAggregateInputType
  }

  export type GetLoginLogAggregateType<T extends LoginLogAggregateArgs> = {
        [P in keyof T & keyof AggregateLoginLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLoginLog[P]>
      : GetScalarType<T[P], AggregateLoginLog[P]>
  }




  export type LoginLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LoginLogWhereInput
    orderBy?: LoginLogOrderByWithAggregationInput | LoginLogOrderByWithAggregationInput[]
    by: LoginLogScalarFieldEnum[] | LoginLogScalarFieldEnum
    having?: LoginLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LoginLogCountAggregateInputType | true
    _avg?: LoginLogAvgAggregateInputType
    _sum?: LoginLogSumAggregateInputType
    _min?: LoginLogMinAggregateInputType
    _max?: LoginLogMaxAggregateInputType
  }

  export type LoginLogGroupByOutputType = {
    id: number
    userId: number
    loginTime: Date
    ipAddress: string | null
    userAgent: string | null
    success: boolean
    createdAt: Date
    _count: LoginLogCountAggregateOutputType | null
    _avg: LoginLogAvgAggregateOutputType | null
    _sum: LoginLogSumAggregateOutputType | null
    _min: LoginLogMinAggregateOutputType | null
    _max: LoginLogMaxAggregateOutputType | null
  }

  type GetLoginLogGroupByPayload<T extends LoginLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LoginLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LoginLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LoginLogGroupByOutputType[P]>
            : GetScalarType<T[P], LoginLogGroupByOutputType[P]>
        }
      >
    >


  export type LoginLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    loginTime?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    success?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["loginLog"]>

  export type LoginLogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    loginTime?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    success?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["loginLog"]>

  export type LoginLogSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    loginTime?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    success?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["loginLog"]>

  export type LoginLogSelectScalar = {
    id?: boolean
    userId?: boolean
    loginTime?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    success?: boolean
    createdAt?: boolean
  }

  export type LoginLogOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "loginTime" | "ipAddress" | "userAgent" | "success" | "createdAt", ExtArgs["result"]["loginLog"]>
  export type LoginLogInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type LoginLogIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type LoginLogIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $LoginLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "LoginLog"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userId: number
      loginTime: Date
      ipAddress: string | null
      userAgent: string | null
      success: boolean
      createdAt: Date
    }, ExtArgs["result"]["loginLog"]>
    composites: {}
  }

  type LoginLogGetPayload<S extends boolean | null | undefined | LoginLogDefaultArgs> = $Result.GetResult<Prisma.$LoginLogPayload, S>

  type LoginLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<LoginLogFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LoginLogCountAggregateInputType | true
    }

  export interface LoginLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['LoginLog'], meta: { name: 'LoginLog' } }
    /**
     * Find zero or one LoginLog that matches the filter.
     * @param {LoginLogFindUniqueArgs} args - Arguments to find a LoginLog
     * @example
     * // Get one LoginLog
     * const loginLog = await prisma.loginLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LoginLogFindUniqueArgs>(args: SelectSubset<T, LoginLogFindUniqueArgs<ExtArgs>>): Prisma__LoginLogClient<$Result.GetResult<Prisma.$LoginLogPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one LoginLog that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {LoginLogFindUniqueOrThrowArgs} args - Arguments to find a LoginLog
     * @example
     * // Get one LoginLog
     * const loginLog = await prisma.loginLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LoginLogFindUniqueOrThrowArgs>(args: SelectSubset<T, LoginLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LoginLogClient<$Result.GetResult<Prisma.$LoginLogPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first LoginLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LoginLogFindFirstArgs} args - Arguments to find a LoginLog
     * @example
     * // Get one LoginLog
     * const loginLog = await prisma.loginLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LoginLogFindFirstArgs>(args?: SelectSubset<T, LoginLogFindFirstArgs<ExtArgs>>): Prisma__LoginLogClient<$Result.GetResult<Prisma.$LoginLogPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first LoginLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LoginLogFindFirstOrThrowArgs} args - Arguments to find a LoginLog
     * @example
     * // Get one LoginLog
     * const loginLog = await prisma.loginLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LoginLogFindFirstOrThrowArgs>(args?: SelectSubset<T, LoginLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__LoginLogClient<$Result.GetResult<Prisma.$LoginLogPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more LoginLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LoginLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LoginLogs
     * const loginLogs = await prisma.loginLog.findMany()
     * 
     * // Get first 10 LoginLogs
     * const loginLogs = await prisma.loginLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const loginLogWithIdOnly = await prisma.loginLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LoginLogFindManyArgs>(args?: SelectSubset<T, LoginLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LoginLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a LoginLog.
     * @param {LoginLogCreateArgs} args - Arguments to create a LoginLog.
     * @example
     * // Create one LoginLog
     * const LoginLog = await prisma.loginLog.create({
     *   data: {
     *     // ... data to create a LoginLog
     *   }
     * })
     * 
     */
    create<T extends LoginLogCreateArgs>(args: SelectSubset<T, LoginLogCreateArgs<ExtArgs>>): Prisma__LoginLogClient<$Result.GetResult<Prisma.$LoginLogPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many LoginLogs.
     * @param {LoginLogCreateManyArgs} args - Arguments to create many LoginLogs.
     * @example
     * // Create many LoginLogs
     * const loginLog = await prisma.loginLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LoginLogCreateManyArgs>(args?: SelectSubset<T, LoginLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many LoginLogs and returns the data saved in the database.
     * @param {LoginLogCreateManyAndReturnArgs} args - Arguments to create many LoginLogs.
     * @example
     * // Create many LoginLogs
     * const loginLog = await prisma.loginLog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many LoginLogs and only return the `id`
     * const loginLogWithIdOnly = await prisma.loginLog.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LoginLogCreateManyAndReturnArgs>(args?: SelectSubset<T, LoginLogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LoginLogPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a LoginLog.
     * @param {LoginLogDeleteArgs} args - Arguments to delete one LoginLog.
     * @example
     * // Delete one LoginLog
     * const LoginLog = await prisma.loginLog.delete({
     *   where: {
     *     // ... filter to delete one LoginLog
     *   }
     * })
     * 
     */
    delete<T extends LoginLogDeleteArgs>(args: SelectSubset<T, LoginLogDeleteArgs<ExtArgs>>): Prisma__LoginLogClient<$Result.GetResult<Prisma.$LoginLogPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one LoginLog.
     * @param {LoginLogUpdateArgs} args - Arguments to update one LoginLog.
     * @example
     * // Update one LoginLog
     * const loginLog = await prisma.loginLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LoginLogUpdateArgs>(args: SelectSubset<T, LoginLogUpdateArgs<ExtArgs>>): Prisma__LoginLogClient<$Result.GetResult<Prisma.$LoginLogPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more LoginLogs.
     * @param {LoginLogDeleteManyArgs} args - Arguments to filter LoginLogs to delete.
     * @example
     * // Delete a few LoginLogs
     * const { count } = await prisma.loginLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LoginLogDeleteManyArgs>(args?: SelectSubset<T, LoginLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LoginLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LoginLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LoginLogs
     * const loginLog = await prisma.loginLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LoginLogUpdateManyArgs>(args: SelectSubset<T, LoginLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LoginLogs and returns the data updated in the database.
     * @param {LoginLogUpdateManyAndReturnArgs} args - Arguments to update many LoginLogs.
     * @example
     * // Update many LoginLogs
     * const loginLog = await prisma.loginLog.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more LoginLogs and only return the `id`
     * const loginLogWithIdOnly = await prisma.loginLog.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends LoginLogUpdateManyAndReturnArgs>(args: SelectSubset<T, LoginLogUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LoginLogPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one LoginLog.
     * @param {LoginLogUpsertArgs} args - Arguments to update or create a LoginLog.
     * @example
     * // Update or create a LoginLog
     * const loginLog = await prisma.loginLog.upsert({
     *   create: {
     *     // ... data to create a LoginLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LoginLog we want to update
     *   }
     * })
     */
    upsert<T extends LoginLogUpsertArgs>(args: SelectSubset<T, LoginLogUpsertArgs<ExtArgs>>): Prisma__LoginLogClient<$Result.GetResult<Prisma.$LoginLogPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of LoginLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LoginLogCountArgs} args - Arguments to filter LoginLogs to count.
     * @example
     * // Count the number of LoginLogs
     * const count = await prisma.loginLog.count({
     *   where: {
     *     // ... the filter for the LoginLogs we want to count
     *   }
     * })
    **/
    count<T extends LoginLogCountArgs>(
      args?: Subset<T, LoginLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LoginLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LoginLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LoginLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LoginLogAggregateArgs>(args: Subset<T, LoginLogAggregateArgs>): Prisma.PrismaPromise<GetLoginLogAggregateType<T>>

    /**
     * Group by LoginLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LoginLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LoginLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LoginLogGroupByArgs['orderBy'] }
        : { orderBy?: LoginLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LoginLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLoginLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the LoginLog model
   */
  readonly fields: LoginLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for LoginLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LoginLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the LoginLog model
   */
  interface LoginLogFieldRefs {
    readonly id: FieldRef<"LoginLog", 'Int'>
    readonly userId: FieldRef<"LoginLog", 'Int'>
    readonly loginTime: FieldRef<"LoginLog", 'DateTime'>
    readonly ipAddress: FieldRef<"LoginLog", 'String'>
    readonly userAgent: FieldRef<"LoginLog", 'String'>
    readonly success: FieldRef<"LoginLog", 'Boolean'>
    readonly createdAt: FieldRef<"LoginLog", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * LoginLog findUnique
   */
  export type LoginLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoginLog
     */
    select?: LoginLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LoginLog
     */
    omit?: LoginLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoginLogInclude<ExtArgs> | null
    /**
     * Filter, which LoginLog to fetch.
     */
    where: LoginLogWhereUniqueInput
  }

  /**
   * LoginLog findUniqueOrThrow
   */
  export type LoginLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoginLog
     */
    select?: LoginLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LoginLog
     */
    omit?: LoginLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoginLogInclude<ExtArgs> | null
    /**
     * Filter, which LoginLog to fetch.
     */
    where: LoginLogWhereUniqueInput
  }

  /**
   * LoginLog findFirst
   */
  export type LoginLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoginLog
     */
    select?: LoginLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LoginLog
     */
    omit?: LoginLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoginLogInclude<ExtArgs> | null
    /**
     * Filter, which LoginLog to fetch.
     */
    where?: LoginLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LoginLogs to fetch.
     */
    orderBy?: LoginLogOrderByWithRelationInput | LoginLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LoginLogs.
     */
    cursor?: LoginLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LoginLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LoginLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LoginLogs.
     */
    distinct?: LoginLogScalarFieldEnum | LoginLogScalarFieldEnum[]
  }

  /**
   * LoginLog findFirstOrThrow
   */
  export type LoginLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoginLog
     */
    select?: LoginLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LoginLog
     */
    omit?: LoginLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoginLogInclude<ExtArgs> | null
    /**
     * Filter, which LoginLog to fetch.
     */
    where?: LoginLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LoginLogs to fetch.
     */
    orderBy?: LoginLogOrderByWithRelationInput | LoginLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LoginLogs.
     */
    cursor?: LoginLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LoginLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LoginLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LoginLogs.
     */
    distinct?: LoginLogScalarFieldEnum | LoginLogScalarFieldEnum[]
  }

  /**
   * LoginLog findMany
   */
  export type LoginLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoginLog
     */
    select?: LoginLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LoginLog
     */
    omit?: LoginLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoginLogInclude<ExtArgs> | null
    /**
     * Filter, which LoginLogs to fetch.
     */
    where?: LoginLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LoginLogs to fetch.
     */
    orderBy?: LoginLogOrderByWithRelationInput | LoginLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing LoginLogs.
     */
    cursor?: LoginLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LoginLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LoginLogs.
     */
    skip?: number
    distinct?: LoginLogScalarFieldEnum | LoginLogScalarFieldEnum[]
  }

  /**
   * LoginLog create
   */
  export type LoginLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoginLog
     */
    select?: LoginLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LoginLog
     */
    omit?: LoginLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoginLogInclude<ExtArgs> | null
    /**
     * The data needed to create a LoginLog.
     */
    data: XOR<LoginLogCreateInput, LoginLogUncheckedCreateInput>
  }

  /**
   * LoginLog createMany
   */
  export type LoginLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many LoginLogs.
     */
    data: LoginLogCreateManyInput | LoginLogCreateManyInput[]
  }

  /**
   * LoginLog createManyAndReturn
   */
  export type LoginLogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoginLog
     */
    select?: LoginLogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the LoginLog
     */
    omit?: LoginLogOmit<ExtArgs> | null
    /**
     * The data used to create many LoginLogs.
     */
    data: LoginLogCreateManyInput | LoginLogCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoginLogIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * LoginLog update
   */
  export type LoginLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoginLog
     */
    select?: LoginLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LoginLog
     */
    omit?: LoginLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoginLogInclude<ExtArgs> | null
    /**
     * The data needed to update a LoginLog.
     */
    data: XOR<LoginLogUpdateInput, LoginLogUncheckedUpdateInput>
    /**
     * Choose, which LoginLog to update.
     */
    where: LoginLogWhereUniqueInput
  }

  /**
   * LoginLog updateMany
   */
  export type LoginLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update LoginLogs.
     */
    data: XOR<LoginLogUpdateManyMutationInput, LoginLogUncheckedUpdateManyInput>
    /**
     * Filter which LoginLogs to update
     */
    where?: LoginLogWhereInput
    /**
     * Limit how many LoginLogs to update.
     */
    limit?: number
  }

  /**
   * LoginLog updateManyAndReturn
   */
  export type LoginLogUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoginLog
     */
    select?: LoginLogSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the LoginLog
     */
    omit?: LoginLogOmit<ExtArgs> | null
    /**
     * The data used to update LoginLogs.
     */
    data: XOR<LoginLogUpdateManyMutationInput, LoginLogUncheckedUpdateManyInput>
    /**
     * Filter which LoginLogs to update
     */
    where?: LoginLogWhereInput
    /**
     * Limit how many LoginLogs to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoginLogIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * LoginLog upsert
   */
  export type LoginLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoginLog
     */
    select?: LoginLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LoginLog
     */
    omit?: LoginLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoginLogInclude<ExtArgs> | null
    /**
     * The filter to search for the LoginLog to update in case it exists.
     */
    where: LoginLogWhereUniqueInput
    /**
     * In case the LoginLog found by the `where` argument doesn't exist, create a new LoginLog with this data.
     */
    create: XOR<LoginLogCreateInput, LoginLogUncheckedCreateInput>
    /**
     * In case the LoginLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LoginLogUpdateInput, LoginLogUncheckedUpdateInput>
  }

  /**
   * LoginLog delete
   */
  export type LoginLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoginLog
     */
    select?: LoginLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LoginLog
     */
    omit?: LoginLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoginLogInclude<ExtArgs> | null
    /**
     * Filter which LoginLog to delete.
     */
    where: LoginLogWhereUniqueInput
  }

  /**
   * LoginLog deleteMany
   */
  export type LoginLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LoginLogs to delete
     */
    where?: LoginLogWhereInput
    /**
     * Limit how many LoginLogs to delete.
     */
    limit?: number
  }

  /**
   * LoginLog without action
   */
  export type LoginLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoginLog
     */
    select?: LoginLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LoginLog
     */
    omit?: LoginLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoginLogInclude<ExtArgs> | null
  }


  /**
   * Model AnalysisQuestion
   */

  export type AggregateAnalysisQuestion = {
    _count: AnalysisQuestionCountAggregateOutputType | null
    _avg: AnalysisQuestionAvgAggregateOutputType | null
    _sum: AnalysisQuestionSumAggregateOutputType | null
    _min: AnalysisQuestionMinAggregateOutputType | null
    _max: AnalysisQuestionMaxAggregateOutputType | null
  }

  export type AnalysisQuestionAvgAggregateOutputType = {
    order: number | null
  }

  export type AnalysisQuestionSumAggregateOutputType = {
    order: number | null
  }

  export type AnalysisQuestionMinAggregateOutputType = {
    id: string | null
    step: string | null
    text: string | null
    type: string | null
    options: string | null
    required: boolean | null
    order: number | null
    conditionalLogic: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AnalysisQuestionMaxAggregateOutputType = {
    id: string | null
    step: string | null
    text: string | null
    type: string | null
    options: string | null
    required: boolean | null
    order: number | null
    conditionalLogic: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AnalysisQuestionCountAggregateOutputType = {
    id: number
    step: number
    text: number
    type: number
    options: number
    required: number
    order: number
    conditionalLogic: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AnalysisQuestionAvgAggregateInputType = {
    order?: true
  }

  export type AnalysisQuestionSumAggregateInputType = {
    order?: true
  }

  export type AnalysisQuestionMinAggregateInputType = {
    id?: true
    step?: true
    text?: true
    type?: true
    options?: true
    required?: true
    order?: true
    conditionalLogic?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AnalysisQuestionMaxAggregateInputType = {
    id?: true
    step?: true
    text?: true
    type?: true
    options?: true
    required?: true
    order?: true
    conditionalLogic?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AnalysisQuestionCountAggregateInputType = {
    id?: true
    step?: true
    text?: true
    type?: true
    options?: true
    required?: true
    order?: true
    conditionalLogic?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AnalysisQuestionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AnalysisQuestion to aggregate.
     */
    where?: AnalysisQuestionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AnalysisQuestions to fetch.
     */
    orderBy?: AnalysisQuestionOrderByWithRelationInput | AnalysisQuestionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AnalysisQuestionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AnalysisQuestions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AnalysisQuestions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AnalysisQuestions
    **/
    _count?: true | AnalysisQuestionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AnalysisQuestionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AnalysisQuestionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AnalysisQuestionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AnalysisQuestionMaxAggregateInputType
  }

  export type GetAnalysisQuestionAggregateType<T extends AnalysisQuestionAggregateArgs> = {
        [P in keyof T & keyof AggregateAnalysisQuestion]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAnalysisQuestion[P]>
      : GetScalarType<T[P], AggregateAnalysisQuestion[P]>
  }




  export type AnalysisQuestionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AnalysisQuestionWhereInput
    orderBy?: AnalysisQuestionOrderByWithAggregationInput | AnalysisQuestionOrderByWithAggregationInput[]
    by: AnalysisQuestionScalarFieldEnum[] | AnalysisQuestionScalarFieldEnum
    having?: AnalysisQuestionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AnalysisQuestionCountAggregateInputType | true
    _avg?: AnalysisQuestionAvgAggregateInputType
    _sum?: AnalysisQuestionSumAggregateInputType
    _min?: AnalysisQuestionMinAggregateInputType
    _max?: AnalysisQuestionMaxAggregateInputType
  }

  export type AnalysisQuestionGroupByOutputType = {
    id: string
    step: string
    text: string
    type: string
    options: string | null
    required: boolean
    order: number
    conditionalLogic: string | null
    createdAt: Date
    updatedAt: Date
    _count: AnalysisQuestionCountAggregateOutputType | null
    _avg: AnalysisQuestionAvgAggregateOutputType | null
    _sum: AnalysisQuestionSumAggregateOutputType | null
    _min: AnalysisQuestionMinAggregateOutputType | null
    _max: AnalysisQuestionMaxAggregateOutputType | null
  }

  type GetAnalysisQuestionGroupByPayload<T extends AnalysisQuestionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AnalysisQuestionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AnalysisQuestionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AnalysisQuestionGroupByOutputType[P]>
            : GetScalarType<T[P], AnalysisQuestionGroupByOutputType[P]>
        }
      >
    >


  export type AnalysisQuestionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    step?: boolean
    text?: boolean
    type?: boolean
    options?: boolean
    required?: boolean
    order?: boolean
    conditionalLogic?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    HelpTopic?: boolean | AnalysisQuestion$HelpTopicArgs<ExtArgs>
    _count?: boolean | AnalysisQuestionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["analysisQuestion"]>

  export type AnalysisQuestionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    step?: boolean
    text?: boolean
    type?: boolean
    options?: boolean
    required?: boolean
    order?: boolean
    conditionalLogic?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["analysisQuestion"]>

  export type AnalysisQuestionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    step?: boolean
    text?: boolean
    type?: boolean
    options?: boolean
    required?: boolean
    order?: boolean
    conditionalLogic?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["analysisQuestion"]>

  export type AnalysisQuestionSelectScalar = {
    id?: boolean
    step?: boolean
    text?: boolean
    type?: boolean
    options?: boolean
    required?: boolean
    order?: boolean
    conditionalLogic?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AnalysisQuestionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "step" | "text" | "type" | "options" | "required" | "order" | "conditionalLogic" | "createdAt" | "updatedAt", ExtArgs["result"]["analysisQuestion"]>
  export type AnalysisQuestionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    HelpTopic?: boolean | AnalysisQuestion$HelpTopicArgs<ExtArgs>
    _count?: boolean | AnalysisQuestionCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type AnalysisQuestionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type AnalysisQuestionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $AnalysisQuestionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AnalysisQuestion"
    objects: {
      HelpTopic: Prisma.$HelpTopicPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      step: string
      text: string
      type: string
      options: string | null
      required: boolean
      order: number
      conditionalLogic: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["analysisQuestion"]>
    composites: {}
  }

  type AnalysisQuestionGetPayload<S extends boolean | null | undefined | AnalysisQuestionDefaultArgs> = $Result.GetResult<Prisma.$AnalysisQuestionPayload, S>

  type AnalysisQuestionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AnalysisQuestionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AnalysisQuestionCountAggregateInputType | true
    }

  export interface AnalysisQuestionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AnalysisQuestion'], meta: { name: 'AnalysisQuestion' } }
    /**
     * Find zero or one AnalysisQuestion that matches the filter.
     * @param {AnalysisQuestionFindUniqueArgs} args - Arguments to find a AnalysisQuestion
     * @example
     * // Get one AnalysisQuestion
     * const analysisQuestion = await prisma.analysisQuestion.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AnalysisQuestionFindUniqueArgs>(args: SelectSubset<T, AnalysisQuestionFindUniqueArgs<ExtArgs>>): Prisma__AnalysisQuestionClient<$Result.GetResult<Prisma.$AnalysisQuestionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AnalysisQuestion that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AnalysisQuestionFindUniqueOrThrowArgs} args - Arguments to find a AnalysisQuestion
     * @example
     * // Get one AnalysisQuestion
     * const analysisQuestion = await prisma.analysisQuestion.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AnalysisQuestionFindUniqueOrThrowArgs>(args: SelectSubset<T, AnalysisQuestionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AnalysisQuestionClient<$Result.GetResult<Prisma.$AnalysisQuestionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AnalysisQuestion that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnalysisQuestionFindFirstArgs} args - Arguments to find a AnalysisQuestion
     * @example
     * // Get one AnalysisQuestion
     * const analysisQuestion = await prisma.analysisQuestion.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AnalysisQuestionFindFirstArgs>(args?: SelectSubset<T, AnalysisQuestionFindFirstArgs<ExtArgs>>): Prisma__AnalysisQuestionClient<$Result.GetResult<Prisma.$AnalysisQuestionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AnalysisQuestion that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnalysisQuestionFindFirstOrThrowArgs} args - Arguments to find a AnalysisQuestion
     * @example
     * // Get one AnalysisQuestion
     * const analysisQuestion = await prisma.analysisQuestion.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AnalysisQuestionFindFirstOrThrowArgs>(args?: SelectSubset<T, AnalysisQuestionFindFirstOrThrowArgs<ExtArgs>>): Prisma__AnalysisQuestionClient<$Result.GetResult<Prisma.$AnalysisQuestionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AnalysisQuestions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnalysisQuestionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AnalysisQuestions
     * const analysisQuestions = await prisma.analysisQuestion.findMany()
     * 
     * // Get first 10 AnalysisQuestions
     * const analysisQuestions = await prisma.analysisQuestion.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const analysisQuestionWithIdOnly = await prisma.analysisQuestion.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AnalysisQuestionFindManyArgs>(args?: SelectSubset<T, AnalysisQuestionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AnalysisQuestionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AnalysisQuestion.
     * @param {AnalysisQuestionCreateArgs} args - Arguments to create a AnalysisQuestion.
     * @example
     * // Create one AnalysisQuestion
     * const AnalysisQuestion = await prisma.analysisQuestion.create({
     *   data: {
     *     // ... data to create a AnalysisQuestion
     *   }
     * })
     * 
     */
    create<T extends AnalysisQuestionCreateArgs>(args: SelectSubset<T, AnalysisQuestionCreateArgs<ExtArgs>>): Prisma__AnalysisQuestionClient<$Result.GetResult<Prisma.$AnalysisQuestionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AnalysisQuestions.
     * @param {AnalysisQuestionCreateManyArgs} args - Arguments to create many AnalysisQuestions.
     * @example
     * // Create many AnalysisQuestions
     * const analysisQuestion = await prisma.analysisQuestion.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AnalysisQuestionCreateManyArgs>(args?: SelectSubset<T, AnalysisQuestionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AnalysisQuestions and returns the data saved in the database.
     * @param {AnalysisQuestionCreateManyAndReturnArgs} args - Arguments to create many AnalysisQuestions.
     * @example
     * // Create many AnalysisQuestions
     * const analysisQuestion = await prisma.analysisQuestion.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AnalysisQuestions and only return the `id`
     * const analysisQuestionWithIdOnly = await prisma.analysisQuestion.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AnalysisQuestionCreateManyAndReturnArgs>(args?: SelectSubset<T, AnalysisQuestionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AnalysisQuestionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AnalysisQuestion.
     * @param {AnalysisQuestionDeleteArgs} args - Arguments to delete one AnalysisQuestion.
     * @example
     * // Delete one AnalysisQuestion
     * const AnalysisQuestion = await prisma.analysisQuestion.delete({
     *   where: {
     *     // ... filter to delete one AnalysisQuestion
     *   }
     * })
     * 
     */
    delete<T extends AnalysisQuestionDeleteArgs>(args: SelectSubset<T, AnalysisQuestionDeleteArgs<ExtArgs>>): Prisma__AnalysisQuestionClient<$Result.GetResult<Prisma.$AnalysisQuestionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AnalysisQuestion.
     * @param {AnalysisQuestionUpdateArgs} args - Arguments to update one AnalysisQuestion.
     * @example
     * // Update one AnalysisQuestion
     * const analysisQuestion = await prisma.analysisQuestion.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AnalysisQuestionUpdateArgs>(args: SelectSubset<T, AnalysisQuestionUpdateArgs<ExtArgs>>): Prisma__AnalysisQuestionClient<$Result.GetResult<Prisma.$AnalysisQuestionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AnalysisQuestions.
     * @param {AnalysisQuestionDeleteManyArgs} args - Arguments to filter AnalysisQuestions to delete.
     * @example
     * // Delete a few AnalysisQuestions
     * const { count } = await prisma.analysisQuestion.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AnalysisQuestionDeleteManyArgs>(args?: SelectSubset<T, AnalysisQuestionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AnalysisQuestions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnalysisQuestionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AnalysisQuestions
     * const analysisQuestion = await prisma.analysisQuestion.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AnalysisQuestionUpdateManyArgs>(args: SelectSubset<T, AnalysisQuestionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AnalysisQuestions and returns the data updated in the database.
     * @param {AnalysisQuestionUpdateManyAndReturnArgs} args - Arguments to update many AnalysisQuestions.
     * @example
     * // Update many AnalysisQuestions
     * const analysisQuestion = await prisma.analysisQuestion.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AnalysisQuestions and only return the `id`
     * const analysisQuestionWithIdOnly = await prisma.analysisQuestion.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AnalysisQuestionUpdateManyAndReturnArgs>(args: SelectSubset<T, AnalysisQuestionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AnalysisQuestionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AnalysisQuestion.
     * @param {AnalysisQuestionUpsertArgs} args - Arguments to update or create a AnalysisQuestion.
     * @example
     * // Update or create a AnalysisQuestion
     * const analysisQuestion = await prisma.analysisQuestion.upsert({
     *   create: {
     *     // ... data to create a AnalysisQuestion
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AnalysisQuestion we want to update
     *   }
     * })
     */
    upsert<T extends AnalysisQuestionUpsertArgs>(args: SelectSubset<T, AnalysisQuestionUpsertArgs<ExtArgs>>): Prisma__AnalysisQuestionClient<$Result.GetResult<Prisma.$AnalysisQuestionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AnalysisQuestions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnalysisQuestionCountArgs} args - Arguments to filter AnalysisQuestions to count.
     * @example
     * // Count the number of AnalysisQuestions
     * const count = await prisma.analysisQuestion.count({
     *   where: {
     *     // ... the filter for the AnalysisQuestions we want to count
     *   }
     * })
    **/
    count<T extends AnalysisQuestionCountArgs>(
      args?: Subset<T, AnalysisQuestionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AnalysisQuestionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AnalysisQuestion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnalysisQuestionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AnalysisQuestionAggregateArgs>(args: Subset<T, AnalysisQuestionAggregateArgs>): Prisma.PrismaPromise<GetAnalysisQuestionAggregateType<T>>

    /**
     * Group by AnalysisQuestion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnalysisQuestionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AnalysisQuestionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AnalysisQuestionGroupByArgs['orderBy'] }
        : { orderBy?: AnalysisQuestionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AnalysisQuestionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAnalysisQuestionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AnalysisQuestion model
   */
  readonly fields: AnalysisQuestionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AnalysisQuestion.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AnalysisQuestionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    HelpTopic<T extends AnalysisQuestion$HelpTopicArgs<ExtArgs> = {}>(args?: Subset<T, AnalysisQuestion$HelpTopicArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HelpTopicPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AnalysisQuestion model
   */
  interface AnalysisQuestionFieldRefs {
    readonly id: FieldRef<"AnalysisQuestion", 'String'>
    readonly step: FieldRef<"AnalysisQuestion", 'String'>
    readonly text: FieldRef<"AnalysisQuestion", 'String'>
    readonly type: FieldRef<"AnalysisQuestion", 'String'>
    readonly options: FieldRef<"AnalysisQuestion", 'String'>
    readonly required: FieldRef<"AnalysisQuestion", 'Boolean'>
    readonly order: FieldRef<"AnalysisQuestion", 'Int'>
    readonly conditionalLogic: FieldRef<"AnalysisQuestion", 'String'>
    readonly createdAt: FieldRef<"AnalysisQuestion", 'DateTime'>
    readonly updatedAt: FieldRef<"AnalysisQuestion", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AnalysisQuestion findUnique
   */
  export type AnalysisQuestionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnalysisQuestion
     */
    select?: AnalysisQuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AnalysisQuestion
     */
    omit?: AnalysisQuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnalysisQuestionInclude<ExtArgs> | null
    /**
     * Filter, which AnalysisQuestion to fetch.
     */
    where: AnalysisQuestionWhereUniqueInput
  }

  /**
   * AnalysisQuestion findUniqueOrThrow
   */
  export type AnalysisQuestionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnalysisQuestion
     */
    select?: AnalysisQuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AnalysisQuestion
     */
    omit?: AnalysisQuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnalysisQuestionInclude<ExtArgs> | null
    /**
     * Filter, which AnalysisQuestion to fetch.
     */
    where: AnalysisQuestionWhereUniqueInput
  }

  /**
   * AnalysisQuestion findFirst
   */
  export type AnalysisQuestionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnalysisQuestion
     */
    select?: AnalysisQuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AnalysisQuestion
     */
    omit?: AnalysisQuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnalysisQuestionInclude<ExtArgs> | null
    /**
     * Filter, which AnalysisQuestion to fetch.
     */
    where?: AnalysisQuestionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AnalysisQuestions to fetch.
     */
    orderBy?: AnalysisQuestionOrderByWithRelationInput | AnalysisQuestionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AnalysisQuestions.
     */
    cursor?: AnalysisQuestionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AnalysisQuestions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AnalysisQuestions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AnalysisQuestions.
     */
    distinct?: AnalysisQuestionScalarFieldEnum | AnalysisQuestionScalarFieldEnum[]
  }

  /**
   * AnalysisQuestion findFirstOrThrow
   */
  export type AnalysisQuestionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnalysisQuestion
     */
    select?: AnalysisQuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AnalysisQuestion
     */
    omit?: AnalysisQuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnalysisQuestionInclude<ExtArgs> | null
    /**
     * Filter, which AnalysisQuestion to fetch.
     */
    where?: AnalysisQuestionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AnalysisQuestions to fetch.
     */
    orderBy?: AnalysisQuestionOrderByWithRelationInput | AnalysisQuestionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AnalysisQuestions.
     */
    cursor?: AnalysisQuestionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AnalysisQuestions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AnalysisQuestions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AnalysisQuestions.
     */
    distinct?: AnalysisQuestionScalarFieldEnum | AnalysisQuestionScalarFieldEnum[]
  }

  /**
   * AnalysisQuestion findMany
   */
  export type AnalysisQuestionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnalysisQuestion
     */
    select?: AnalysisQuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AnalysisQuestion
     */
    omit?: AnalysisQuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnalysisQuestionInclude<ExtArgs> | null
    /**
     * Filter, which AnalysisQuestions to fetch.
     */
    where?: AnalysisQuestionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AnalysisQuestions to fetch.
     */
    orderBy?: AnalysisQuestionOrderByWithRelationInput | AnalysisQuestionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AnalysisQuestions.
     */
    cursor?: AnalysisQuestionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AnalysisQuestions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AnalysisQuestions.
     */
    skip?: number
    distinct?: AnalysisQuestionScalarFieldEnum | AnalysisQuestionScalarFieldEnum[]
  }

  /**
   * AnalysisQuestion create
   */
  export type AnalysisQuestionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnalysisQuestion
     */
    select?: AnalysisQuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AnalysisQuestion
     */
    omit?: AnalysisQuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnalysisQuestionInclude<ExtArgs> | null
    /**
     * The data needed to create a AnalysisQuestion.
     */
    data: XOR<AnalysisQuestionCreateInput, AnalysisQuestionUncheckedCreateInput>
  }

  /**
   * AnalysisQuestion createMany
   */
  export type AnalysisQuestionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AnalysisQuestions.
     */
    data: AnalysisQuestionCreateManyInput | AnalysisQuestionCreateManyInput[]
  }

  /**
   * AnalysisQuestion createManyAndReturn
   */
  export type AnalysisQuestionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnalysisQuestion
     */
    select?: AnalysisQuestionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AnalysisQuestion
     */
    omit?: AnalysisQuestionOmit<ExtArgs> | null
    /**
     * The data used to create many AnalysisQuestions.
     */
    data: AnalysisQuestionCreateManyInput | AnalysisQuestionCreateManyInput[]
  }

  /**
   * AnalysisQuestion update
   */
  export type AnalysisQuestionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnalysisQuestion
     */
    select?: AnalysisQuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AnalysisQuestion
     */
    omit?: AnalysisQuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnalysisQuestionInclude<ExtArgs> | null
    /**
     * The data needed to update a AnalysisQuestion.
     */
    data: XOR<AnalysisQuestionUpdateInput, AnalysisQuestionUncheckedUpdateInput>
    /**
     * Choose, which AnalysisQuestion to update.
     */
    where: AnalysisQuestionWhereUniqueInput
  }

  /**
   * AnalysisQuestion updateMany
   */
  export type AnalysisQuestionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AnalysisQuestions.
     */
    data: XOR<AnalysisQuestionUpdateManyMutationInput, AnalysisQuestionUncheckedUpdateManyInput>
    /**
     * Filter which AnalysisQuestions to update
     */
    where?: AnalysisQuestionWhereInput
    /**
     * Limit how many AnalysisQuestions to update.
     */
    limit?: number
  }

  /**
   * AnalysisQuestion updateManyAndReturn
   */
  export type AnalysisQuestionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnalysisQuestion
     */
    select?: AnalysisQuestionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AnalysisQuestion
     */
    omit?: AnalysisQuestionOmit<ExtArgs> | null
    /**
     * The data used to update AnalysisQuestions.
     */
    data: XOR<AnalysisQuestionUpdateManyMutationInput, AnalysisQuestionUncheckedUpdateManyInput>
    /**
     * Filter which AnalysisQuestions to update
     */
    where?: AnalysisQuestionWhereInput
    /**
     * Limit how many AnalysisQuestions to update.
     */
    limit?: number
  }

  /**
   * AnalysisQuestion upsert
   */
  export type AnalysisQuestionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnalysisQuestion
     */
    select?: AnalysisQuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AnalysisQuestion
     */
    omit?: AnalysisQuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnalysisQuestionInclude<ExtArgs> | null
    /**
     * The filter to search for the AnalysisQuestion to update in case it exists.
     */
    where: AnalysisQuestionWhereUniqueInput
    /**
     * In case the AnalysisQuestion found by the `where` argument doesn't exist, create a new AnalysisQuestion with this data.
     */
    create: XOR<AnalysisQuestionCreateInput, AnalysisQuestionUncheckedCreateInput>
    /**
     * In case the AnalysisQuestion was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AnalysisQuestionUpdateInput, AnalysisQuestionUncheckedUpdateInput>
  }

  /**
   * AnalysisQuestion delete
   */
  export type AnalysisQuestionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnalysisQuestion
     */
    select?: AnalysisQuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AnalysisQuestion
     */
    omit?: AnalysisQuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnalysisQuestionInclude<ExtArgs> | null
    /**
     * Filter which AnalysisQuestion to delete.
     */
    where: AnalysisQuestionWhereUniqueInput
  }

  /**
   * AnalysisQuestion deleteMany
   */
  export type AnalysisQuestionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AnalysisQuestions to delete
     */
    where?: AnalysisQuestionWhereInput
    /**
     * Limit how many AnalysisQuestions to delete.
     */
    limit?: number
  }

  /**
   * AnalysisQuestion.HelpTopic
   */
  export type AnalysisQuestion$HelpTopicArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HelpTopic
     */
    select?: HelpTopicSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HelpTopic
     */
    omit?: HelpTopicOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HelpTopicInclude<ExtArgs> | null
    where?: HelpTopicWhereInput
    orderBy?: HelpTopicOrderByWithRelationInput | HelpTopicOrderByWithRelationInput[]
    cursor?: HelpTopicWhereUniqueInput
    take?: number
    skip?: number
    distinct?: HelpTopicScalarFieldEnum | HelpTopicScalarFieldEnum[]
  }

  /**
   * AnalysisQuestion without action
   */
  export type AnalysisQuestionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnalysisQuestion
     */
    select?: AnalysisQuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AnalysisQuestion
     */
    omit?: AnalysisQuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnalysisQuestionInclude<ExtArgs> | null
  }


  /**
   * Model CommonFeedback
   */

  export type AggregateCommonFeedback = {
    _count: CommonFeedbackCountAggregateOutputType | null
    _avg: CommonFeedbackAvgAggregateOutputType | null
    _sum: CommonFeedbackSumAggregateOutputType | null
    _min: CommonFeedbackMinAggregateOutputType | null
    _max: CommonFeedbackMaxAggregateOutputType | null
  }

  export type CommonFeedbackAvgAggregateOutputType = {
    id: number | null
  }

  export type CommonFeedbackSumAggregateOutputType = {
    id: number | null
  }

  export type CommonFeedbackMinAggregateOutputType = {
    id: number | null
    questionId: string | null
    title: string | null
    text: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CommonFeedbackMaxAggregateOutputType = {
    id: number | null
    questionId: string | null
    title: string | null
    text: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CommonFeedbackCountAggregateOutputType = {
    id: number
    questionId: number
    title: number
    text: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CommonFeedbackAvgAggregateInputType = {
    id?: true
  }

  export type CommonFeedbackSumAggregateInputType = {
    id?: true
  }

  export type CommonFeedbackMinAggregateInputType = {
    id?: true
    questionId?: true
    title?: true
    text?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CommonFeedbackMaxAggregateInputType = {
    id?: true
    questionId?: true
    title?: true
    text?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CommonFeedbackCountAggregateInputType = {
    id?: true
    questionId?: true
    title?: true
    text?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CommonFeedbackAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CommonFeedback to aggregate.
     */
    where?: CommonFeedbackWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CommonFeedbacks to fetch.
     */
    orderBy?: CommonFeedbackOrderByWithRelationInput | CommonFeedbackOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CommonFeedbackWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CommonFeedbacks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CommonFeedbacks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CommonFeedbacks
    **/
    _count?: true | CommonFeedbackCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CommonFeedbackAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CommonFeedbackSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CommonFeedbackMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CommonFeedbackMaxAggregateInputType
  }

  export type GetCommonFeedbackAggregateType<T extends CommonFeedbackAggregateArgs> = {
        [P in keyof T & keyof AggregateCommonFeedback]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCommonFeedback[P]>
      : GetScalarType<T[P], AggregateCommonFeedback[P]>
  }




  export type CommonFeedbackGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommonFeedbackWhereInput
    orderBy?: CommonFeedbackOrderByWithAggregationInput | CommonFeedbackOrderByWithAggregationInput[]
    by: CommonFeedbackScalarFieldEnum[] | CommonFeedbackScalarFieldEnum
    having?: CommonFeedbackScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CommonFeedbackCountAggregateInputType | true
    _avg?: CommonFeedbackAvgAggregateInputType
    _sum?: CommonFeedbackSumAggregateInputType
    _min?: CommonFeedbackMinAggregateInputType
    _max?: CommonFeedbackMaxAggregateInputType
  }

  export type CommonFeedbackGroupByOutputType = {
    id: number
    questionId: string
    title: string
    text: string
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: CommonFeedbackCountAggregateOutputType | null
    _avg: CommonFeedbackAvgAggregateOutputType | null
    _sum: CommonFeedbackSumAggregateOutputType | null
    _min: CommonFeedbackMinAggregateOutputType | null
    _max: CommonFeedbackMaxAggregateOutputType | null
  }

  type GetCommonFeedbackGroupByPayload<T extends CommonFeedbackGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CommonFeedbackGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CommonFeedbackGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CommonFeedbackGroupByOutputType[P]>
            : GetScalarType<T[P], CommonFeedbackGroupByOutputType[P]>
        }
      >
    >


  export type CommonFeedbackSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    questionId?: boolean
    title?: boolean
    text?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["commonFeedback"]>

  export type CommonFeedbackSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    questionId?: boolean
    title?: boolean
    text?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["commonFeedback"]>

  export type CommonFeedbackSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    questionId?: boolean
    title?: boolean
    text?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["commonFeedback"]>

  export type CommonFeedbackSelectScalar = {
    id?: boolean
    questionId?: boolean
    title?: boolean
    text?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CommonFeedbackOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "questionId" | "title" | "text" | "isActive" | "createdAt" | "updatedAt", ExtArgs["result"]["commonFeedback"]>

  export type $CommonFeedbackPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CommonFeedback"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      questionId: string
      title: string
      text: string
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["commonFeedback"]>
    composites: {}
  }

  type CommonFeedbackGetPayload<S extends boolean | null | undefined | CommonFeedbackDefaultArgs> = $Result.GetResult<Prisma.$CommonFeedbackPayload, S>

  type CommonFeedbackCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CommonFeedbackFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CommonFeedbackCountAggregateInputType | true
    }

  export interface CommonFeedbackDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CommonFeedback'], meta: { name: 'CommonFeedback' } }
    /**
     * Find zero or one CommonFeedback that matches the filter.
     * @param {CommonFeedbackFindUniqueArgs} args - Arguments to find a CommonFeedback
     * @example
     * // Get one CommonFeedback
     * const commonFeedback = await prisma.commonFeedback.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CommonFeedbackFindUniqueArgs>(args: SelectSubset<T, CommonFeedbackFindUniqueArgs<ExtArgs>>): Prisma__CommonFeedbackClient<$Result.GetResult<Prisma.$CommonFeedbackPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CommonFeedback that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CommonFeedbackFindUniqueOrThrowArgs} args - Arguments to find a CommonFeedback
     * @example
     * // Get one CommonFeedback
     * const commonFeedback = await prisma.commonFeedback.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CommonFeedbackFindUniqueOrThrowArgs>(args: SelectSubset<T, CommonFeedbackFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CommonFeedbackClient<$Result.GetResult<Prisma.$CommonFeedbackPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CommonFeedback that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommonFeedbackFindFirstArgs} args - Arguments to find a CommonFeedback
     * @example
     * // Get one CommonFeedback
     * const commonFeedback = await prisma.commonFeedback.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CommonFeedbackFindFirstArgs>(args?: SelectSubset<T, CommonFeedbackFindFirstArgs<ExtArgs>>): Prisma__CommonFeedbackClient<$Result.GetResult<Prisma.$CommonFeedbackPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CommonFeedback that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommonFeedbackFindFirstOrThrowArgs} args - Arguments to find a CommonFeedback
     * @example
     * // Get one CommonFeedback
     * const commonFeedback = await prisma.commonFeedback.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CommonFeedbackFindFirstOrThrowArgs>(args?: SelectSubset<T, CommonFeedbackFindFirstOrThrowArgs<ExtArgs>>): Prisma__CommonFeedbackClient<$Result.GetResult<Prisma.$CommonFeedbackPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CommonFeedbacks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommonFeedbackFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CommonFeedbacks
     * const commonFeedbacks = await prisma.commonFeedback.findMany()
     * 
     * // Get first 10 CommonFeedbacks
     * const commonFeedbacks = await prisma.commonFeedback.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const commonFeedbackWithIdOnly = await prisma.commonFeedback.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CommonFeedbackFindManyArgs>(args?: SelectSubset<T, CommonFeedbackFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommonFeedbackPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CommonFeedback.
     * @param {CommonFeedbackCreateArgs} args - Arguments to create a CommonFeedback.
     * @example
     * // Create one CommonFeedback
     * const CommonFeedback = await prisma.commonFeedback.create({
     *   data: {
     *     // ... data to create a CommonFeedback
     *   }
     * })
     * 
     */
    create<T extends CommonFeedbackCreateArgs>(args: SelectSubset<T, CommonFeedbackCreateArgs<ExtArgs>>): Prisma__CommonFeedbackClient<$Result.GetResult<Prisma.$CommonFeedbackPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CommonFeedbacks.
     * @param {CommonFeedbackCreateManyArgs} args - Arguments to create many CommonFeedbacks.
     * @example
     * // Create many CommonFeedbacks
     * const commonFeedback = await prisma.commonFeedback.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CommonFeedbackCreateManyArgs>(args?: SelectSubset<T, CommonFeedbackCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CommonFeedbacks and returns the data saved in the database.
     * @param {CommonFeedbackCreateManyAndReturnArgs} args - Arguments to create many CommonFeedbacks.
     * @example
     * // Create many CommonFeedbacks
     * const commonFeedback = await prisma.commonFeedback.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CommonFeedbacks and only return the `id`
     * const commonFeedbackWithIdOnly = await prisma.commonFeedback.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CommonFeedbackCreateManyAndReturnArgs>(args?: SelectSubset<T, CommonFeedbackCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommonFeedbackPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CommonFeedback.
     * @param {CommonFeedbackDeleteArgs} args - Arguments to delete one CommonFeedback.
     * @example
     * // Delete one CommonFeedback
     * const CommonFeedback = await prisma.commonFeedback.delete({
     *   where: {
     *     // ... filter to delete one CommonFeedback
     *   }
     * })
     * 
     */
    delete<T extends CommonFeedbackDeleteArgs>(args: SelectSubset<T, CommonFeedbackDeleteArgs<ExtArgs>>): Prisma__CommonFeedbackClient<$Result.GetResult<Prisma.$CommonFeedbackPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CommonFeedback.
     * @param {CommonFeedbackUpdateArgs} args - Arguments to update one CommonFeedback.
     * @example
     * // Update one CommonFeedback
     * const commonFeedback = await prisma.commonFeedback.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CommonFeedbackUpdateArgs>(args: SelectSubset<T, CommonFeedbackUpdateArgs<ExtArgs>>): Prisma__CommonFeedbackClient<$Result.GetResult<Prisma.$CommonFeedbackPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CommonFeedbacks.
     * @param {CommonFeedbackDeleteManyArgs} args - Arguments to filter CommonFeedbacks to delete.
     * @example
     * // Delete a few CommonFeedbacks
     * const { count } = await prisma.commonFeedback.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CommonFeedbackDeleteManyArgs>(args?: SelectSubset<T, CommonFeedbackDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CommonFeedbacks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommonFeedbackUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CommonFeedbacks
     * const commonFeedback = await prisma.commonFeedback.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CommonFeedbackUpdateManyArgs>(args: SelectSubset<T, CommonFeedbackUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CommonFeedbacks and returns the data updated in the database.
     * @param {CommonFeedbackUpdateManyAndReturnArgs} args - Arguments to update many CommonFeedbacks.
     * @example
     * // Update many CommonFeedbacks
     * const commonFeedback = await prisma.commonFeedback.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CommonFeedbacks and only return the `id`
     * const commonFeedbackWithIdOnly = await prisma.commonFeedback.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CommonFeedbackUpdateManyAndReturnArgs>(args: SelectSubset<T, CommonFeedbackUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommonFeedbackPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CommonFeedback.
     * @param {CommonFeedbackUpsertArgs} args - Arguments to update or create a CommonFeedback.
     * @example
     * // Update or create a CommonFeedback
     * const commonFeedback = await prisma.commonFeedback.upsert({
     *   create: {
     *     // ... data to create a CommonFeedback
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CommonFeedback we want to update
     *   }
     * })
     */
    upsert<T extends CommonFeedbackUpsertArgs>(args: SelectSubset<T, CommonFeedbackUpsertArgs<ExtArgs>>): Prisma__CommonFeedbackClient<$Result.GetResult<Prisma.$CommonFeedbackPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CommonFeedbacks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommonFeedbackCountArgs} args - Arguments to filter CommonFeedbacks to count.
     * @example
     * // Count the number of CommonFeedbacks
     * const count = await prisma.commonFeedback.count({
     *   where: {
     *     // ... the filter for the CommonFeedbacks we want to count
     *   }
     * })
    **/
    count<T extends CommonFeedbackCountArgs>(
      args?: Subset<T, CommonFeedbackCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CommonFeedbackCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CommonFeedback.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommonFeedbackAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CommonFeedbackAggregateArgs>(args: Subset<T, CommonFeedbackAggregateArgs>): Prisma.PrismaPromise<GetCommonFeedbackAggregateType<T>>

    /**
     * Group by CommonFeedback.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommonFeedbackGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CommonFeedbackGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CommonFeedbackGroupByArgs['orderBy'] }
        : { orderBy?: CommonFeedbackGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CommonFeedbackGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCommonFeedbackGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CommonFeedback model
   */
  readonly fields: CommonFeedbackFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CommonFeedback.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CommonFeedbackClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CommonFeedback model
   */
  interface CommonFeedbackFieldRefs {
    readonly id: FieldRef<"CommonFeedback", 'Int'>
    readonly questionId: FieldRef<"CommonFeedback", 'String'>
    readonly title: FieldRef<"CommonFeedback", 'String'>
    readonly text: FieldRef<"CommonFeedback", 'String'>
    readonly isActive: FieldRef<"CommonFeedback", 'Boolean'>
    readonly createdAt: FieldRef<"CommonFeedback", 'DateTime'>
    readonly updatedAt: FieldRef<"CommonFeedback", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CommonFeedback findUnique
   */
  export type CommonFeedbackFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommonFeedback
     */
    select?: CommonFeedbackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CommonFeedback
     */
    omit?: CommonFeedbackOmit<ExtArgs> | null
    /**
     * Filter, which CommonFeedback to fetch.
     */
    where: CommonFeedbackWhereUniqueInput
  }

  /**
   * CommonFeedback findUniqueOrThrow
   */
  export type CommonFeedbackFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommonFeedback
     */
    select?: CommonFeedbackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CommonFeedback
     */
    omit?: CommonFeedbackOmit<ExtArgs> | null
    /**
     * Filter, which CommonFeedback to fetch.
     */
    where: CommonFeedbackWhereUniqueInput
  }

  /**
   * CommonFeedback findFirst
   */
  export type CommonFeedbackFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommonFeedback
     */
    select?: CommonFeedbackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CommonFeedback
     */
    omit?: CommonFeedbackOmit<ExtArgs> | null
    /**
     * Filter, which CommonFeedback to fetch.
     */
    where?: CommonFeedbackWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CommonFeedbacks to fetch.
     */
    orderBy?: CommonFeedbackOrderByWithRelationInput | CommonFeedbackOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CommonFeedbacks.
     */
    cursor?: CommonFeedbackWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CommonFeedbacks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CommonFeedbacks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CommonFeedbacks.
     */
    distinct?: CommonFeedbackScalarFieldEnum | CommonFeedbackScalarFieldEnum[]
  }

  /**
   * CommonFeedback findFirstOrThrow
   */
  export type CommonFeedbackFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommonFeedback
     */
    select?: CommonFeedbackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CommonFeedback
     */
    omit?: CommonFeedbackOmit<ExtArgs> | null
    /**
     * Filter, which CommonFeedback to fetch.
     */
    where?: CommonFeedbackWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CommonFeedbacks to fetch.
     */
    orderBy?: CommonFeedbackOrderByWithRelationInput | CommonFeedbackOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CommonFeedbacks.
     */
    cursor?: CommonFeedbackWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CommonFeedbacks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CommonFeedbacks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CommonFeedbacks.
     */
    distinct?: CommonFeedbackScalarFieldEnum | CommonFeedbackScalarFieldEnum[]
  }

  /**
   * CommonFeedback findMany
   */
  export type CommonFeedbackFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommonFeedback
     */
    select?: CommonFeedbackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CommonFeedback
     */
    omit?: CommonFeedbackOmit<ExtArgs> | null
    /**
     * Filter, which CommonFeedbacks to fetch.
     */
    where?: CommonFeedbackWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CommonFeedbacks to fetch.
     */
    orderBy?: CommonFeedbackOrderByWithRelationInput | CommonFeedbackOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CommonFeedbacks.
     */
    cursor?: CommonFeedbackWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CommonFeedbacks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CommonFeedbacks.
     */
    skip?: number
    distinct?: CommonFeedbackScalarFieldEnum | CommonFeedbackScalarFieldEnum[]
  }

  /**
   * CommonFeedback create
   */
  export type CommonFeedbackCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommonFeedback
     */
    select?: CommonFeedbackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CommonFeedback
     */
    omit?: CommonFeedbackOmit<ExtArgs> | null
    /**
     * The data needed to create a CommonFeedback.
     */
    data: XOR<CommonFeedbackCreateInput, CommonFeedbackUncheckedCreateInput>
  }

  /**
   * CommonFeedback createMany
   */
  export type CommonFeedbackCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CommonFeedbacks.
     */
    data: CommonFeedbackCreateManyInput | CommonFeedbackCreateManyInput[]
  }

  /**
   * CommonFeedback createManyAndReturn
   */
  export type CommonFeedbackCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommonFeedback
     */
    select?: CommonFeedbackSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CommonFeedback
     */
    omit?: CommonFeedbackOmit<ExtArgs> | null
    /**
     * The data used to create many CommonFeedbacks.
     */
    data: CommonFeedbackCreateManyInput | CommonFeedbackCreateManyInput[]
  }

  /**
   * CommonFeedback update
   */
  export type CommonFeedbackUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommonFeedback
     */
    select?: CommonFeedbackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CommonFeedback
     */
    omit?: CommonFeedbackOmit<ExtArgs> | null
    /**
     * The data needed to update a CommonFeedback.
     */
    data: XOR<CommonFeedbackUpdateInput, CommonFeedbackUncheckedUpdateInput>
    /**
     * Choose, which CommonFeedback to update.
     */
    where: CommonFeedbackWhereUniqueInput
  }

  /**
   * CommonFeedback updateMany
   */
  export type CommonFeedbackUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CommonFeedbacks.
     */
    data: XOR<CommonFeedbackUpdateManyMutationInput, CommonFeedbackUncheckedUpdateManyInput>
    /**
     * Filter which CommonFeedbacks to update
     */
    where?: CommonFeedbackWhereInput
    /**
     * Limit how many CommonFeedbacks to update.
     */
    limit?: number
  }

  /**
   * CommonFeedback updateManyAndReturn
   */
  export type CommonFeedbackUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommonFeedback
     */
    select?: CommonFeedbackSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CommonFeedback
     */
    omit?: CommonFeedbackOmit<ExtArgs> | null
    /**
     * The data used to update CommonFeedbacks.
     */
    data: XOR<CommonFeedbackUpdateManyMutationInput, CommonFeedbackUncheckedUpdateManyInput>
    /**
     * Filter which CommonFeedbacks to update
     */
    where?: CommonFeedbackWhereInput
    /**
     * Limit how many CommonFeedbacks to update.
     */
    limit?: number
  }

  /**
   * CommonFeedback upsert
   */
  export type CommonFeedbackUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommonFeedback
     */
    select?: CommonFeedbackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CommonFeedback
     */
    omit?: CommonFeedbackOmit<ExtArgs> | null
    /**
     * The filter to search for the CommonFeedback to update in case it exists.
     */
    where: CommonFeedbackWhereUniqueInput
    /**
     * In case the CommonFeedback found by the `where` argument doesn't exist, create a new CommonFeedback with this data.
     */
    create: XOR<CommonFeedbackCreateInput, CommonFeedbackUncheckedCreateInput>
    /**
     * In case the CommonFeedback was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CommonFeedbackUpdateInput, CommonFeedbackUncheckedUpdateInput>
  }

  /**
   * CommonFeedback delete
   */
  export type CommonFeedbackDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommonFeedback
     */
    select?: CommonFeedbackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CommonFeedback
     */
    omit?: CommonFeedbackOmit<ExtArgs> | null
    /**
     * Filter which CommonFeedback to delete.
     */
    where: CommonFeedbackWhereUniqueInput
  }

  /**
   * CommonFeedback deleteMany
   */
  export type CommonFeedbackDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CommonFeedbacks to delete
     */
    where?: CommonFeedbackWhereInput
    /**
     * Limit how many CommonFeedbacks to delete.
     */
    limit?: number
  }

  /**
   * CommonFeedback without action
   */
  export type CommonFeedbackDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommonFeedback
     */
    select?: CommonFeedbackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CommonFeedback
     */
    omit?: CommonFeedbackOmit<ExtArgs> | null
  }


  /**
   * Model UploadedFile
   */

  export type AggregateUploadedFile = {
    _count: UploadedFileCountAggregateOutputType | null
    _avg: UploadedFileAvgAggregateOutputType | null
    _sum: UploadedFileSumAggregateOutputType | null
    _min: UploadedFileMinAggregateOutputType | null
    _max: UploadedFileMaxAggregateOutputType | null
  }

  export type UploadedFileAvgAggregateOutputType = {
    id: number | null
    progress: number | null
    assignedToId: number | null
    uploadedById: number | null
  }

  export type UploadedFileSumAggregateOutputType = {
    id: number | null
    progress: number | null
    assignedToId: number | null
    uploadedById: number | null
  }

  export type UploadedFileMinAggregateOutputType = {
    id: number | null
    filename: string | null
    originalName: string | null
    cloneName: string | null
    size: string | null
    uploadDate: string | null
    status: string | null
    progress: number | null
    analysisData: string | null
    assignedToId: number | null
    uploadedById: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UploadedFileMaxAggregateOutputType = {
    id: number | null
    filename: string | null
    originalName: string | null
    cloneName: string | null
    size: string | null
    uploadDate: string | null
    status: string | null
    progress: number | null
    analysisData: string | null
    assignedToId: number | null
    uploadedById: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UploadedFileCountAggregateOutputType = {
    id: number
    filename: number
    originalName: number
    cloneName: number
    size: number
    uploadDate: number
    status: number
    progress: number
    analysisData: number
    assignedToId: number
    uploadedById: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UploadedFileAvgAggregateInputType = {
    id?: true
    progress?: true
    assignedToId?: true
    uploadedById?: true
  }

  export type UploadedFileSumAggregateInputType = {
    id?: true
    progress?: true
    assignedToId?: true
    uploadedById?: true
  }

  export type UploadedFileMinAggregateInputType = {
    id?: true
    filename?: true
    originalName?: true
    cloneName?: true
    size?: true
    uploadDate?: true
    status?: true
    progress?: true
    analysisData?: true
    assignedToId?: true
    uploadedById?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UploadedFileMaxAggregateInputType = {
    id?: true
    filename?: true
    originalName?: true
    cloneName?: true
    size?: true
    uploadDate?: true
    status?: true
    progress?: true
    analysisData?: true
    assignedToId?: true
    uploadedById?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UploadedFileCountAggregateInputType = {
    id?: true
    filename?: true
    originalName?: true
    cloneName?: true
    size?: true
    uploadDate?: true
    status?: true
    progress?: true
    analysisData?: true
    assignedToId?: true
    uploadedById?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UploadedFileAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UploadedFile to aggregate.
     */
    where?: UploadedFileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UploadedFiles to fetch.
     */
    orderBy?: UploadedFileOrderByWithRelationInput | UploadedFileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UploadedFileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UploadedFiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UploadedFiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UploadedFiles
    **/
    _count?: true | UploadedFileCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UploadedFileAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UploadedFileSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UploadedFileMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UploadedFileMaxAggregateInputType
  }

  export type GetUploadedFileAggregateType<T extends UploadedFileAggregateArgs> = {
        [P in keyof T & keyof AggregateUploadedFile]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUploadedFile[P]>
      : GetScalarType<T[P], AggregateUploadedFile[P]>
  }




  export type UploadedFileGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UploadedFileWhereInput
    orderBy?: UploadedFileOrderByWithAggregationInput | UploadedFileOrderByWithAggregationInput[]
    by: UploadedFileScalarFieldEnum[] | UploadedFileScalarFieldEnum
    having?: UploadedFileScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UploadedFileCountAggregateInputType | true
    _avg?: UploadedFileAvgAggregateInputType
    _sum?: UploadedFileSumAggregateInputType
    _min?: UploadedFileMinAggregateInputType
    _max?: UploadedFileMaxAggregateInputType
  }

  export type UploadedFileGroupByOutputType = {
    id: number
    filename: string
    originalName: string
    cloneName: string
    size: string
    uploadDate: string
    status: string
    progress: number
    analysisData: string | null
    assignedToId: number | null
    uploadedById: number
    createdAt: Date
    updatedAt: Date
    _count: UploadedFileCountAggregateOutputType | null
    _avg: UploadedFileAvgAggregateOutputType | null
    _sum: UploadedFileSumAggregateOutputType | null
    _min: UploadedFileMinAggregateOutputType | null
    _max: UploadedFileMaxAggregateOutputType | null
  }

  type GetUploadedFileGroupByPayload<T extends UploadedFileGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UploadedFileGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UploadedFileGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UploadedFileGroupByOutputType[P]>
            : GetScalarType<T[P], UploadedFileGroupByOutputType[P]>
        }
      >
    >


  export type UploadedFileSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    filename?: boolean
    originalName?: boolean
    cloneName?: boolean
    size?: boolean
    uploadDate?: boolean
    status?: boolean
    progress?: boolean
    analysisData?: boolean
    assignedToId?: boolean
    uploadedById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    assignedTo?: boolean | UploadedFile$assignedToArgs<ExtArgs>
    uploadedBy?: boolean | UserDefaultArgs<ExtArgs>
    messages?: boolean | UploadedFile$messagesArgs<ExtArgs>
    cloneDiscussions?: boolean | UploadedFile$cloneDiscussionsArgs<ExtArgs>
    _count?: boolean | UploadedFileCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["uploadedFile"]>

  export type UploadedFileSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    filename?: boolean
    originalName?: boolean
    cloneName?: boolean
    size?: boolean
    uploadDate?: boolean
    status?: boolean
    progress?: boolean
    analysisData?: boolean
    assignedToId?: boolean
    uploadedById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    assignedTo?: boolean | UploadedFile$assignedToArgs<ExtArgs>
    uploadedBy?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["uploadedFile"]>

  export type UploadedFileSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    filename?: boolean
    originalName?: boolean
    cloneName?: boolean
    size?: boolean
    uploadDate?: boolean
    status?: boolean
    progress?: boolean
    analysisData?: boolean
    assignedToId?: boolean
    uploadedById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    assignedTo?: boolean | UploadedFile$assignedToArgs<ExtArgs>
    uploadedBy?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["uploadedFile"]>

  export type UploadedFileSelectScalar = {
    id?: boolean
    filename?: boolean
    originalName?: boolean
    cloneName?: boolean
    size?: boolean
    uploadDate?: boolean
    status?: boolean
    progress?: boolean
    analysisData?: boolean
    assignedToId?: boolean
    uploadedById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UploadedFileOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "filename" | "originalName" | "cloneName" | "size" | "uploadDate" | "status" | "progress" | "analysisData" | "assignedToId" | "uploadedById" | "createdAt" | "updatedAt", ExtArgs["result"]["uploadedFile"]>
  export type UploadedFileInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    assignedTo?: boolean | UploadedFile$assignedToArgs<ExtArgs>
    uploadedBy?: boolean | UserDefaultArgs<ExtArgs>
    messages?: boolean | UploadedFile$messagesArgs<ExtArgs>
    cloneDiscussions?: boolean | UploadedFile$cloneDiscussionsArgs<ExtArgs>
    _count?: boolean | UploadedFileCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UploadedFileIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    assignedTo?: boolean | UploadedFile$assignedToArgs<ExtArgs>
    uploadedBy?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type UploadedFileIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    assignedTo?: boolean | UploadedFile$assignedToArgs<ExtArgs>
    uploadedBy?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $UploadedFilePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UploadedFile"
    objects: {
      assignedTo: Prisma.$UserPayload<ExtArgs> | null
      uploadedBy: Prisma.$UserPayload<ExtArgs>
      messages: Prisma.$MessagePayload<ExtArgs>[]
      cloneDiscussions: Prisma.$CloneDiscussionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      filename: string
      originalName: string
      cloneName: string
      size: string
      uploadDate: string
      status: string
      progress: number
      analysisData: string | null
      assignedToId: number | null
      uploadedById: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["uploadedFile"]>
    composites: {}
  }

  type UploadedFileGetPayload<S extends boolean | null | undefined | UploadedFileDefaultArgs> = $Result.GetResult<Prisma.$UploadedFilePayload, S>

  type UploadedFileCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UploadedFileFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UploadedFileCountAggregateInputType | true
    }

  export interface UploadedFileDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UploadedFile'], meta: { name: 'UploadedFile' } }
    /**
     * Find zero or one UploadedFile that matches the filter.
     * @param {UploadedFileFindUniqueArgs} args - Arguments to find a UploadedFile
     * @example
     * // Get one UploadedFile
     * const uploadedFile = await prisma.uploadedFile.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UploadedFileFindUniqueArgs>(args: SelectSubset<T, UploadedFileFindUniqueArgs<ExtArgs>>): Prisma__UploadedFileClient<$Result.GetResult<Prisma.$UploadedFilePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UploadedFile that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UploadedFileFindUniqueOrThrowArgs} args - Arguments to find a UploadedFile
     * @example
     * // Get one UploadedFile
     * const uploadedFile = await prisma.uploadedFile.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UploadedFileFindUniqueOrThrowArgs>(args: SelectSubset<T, UploadedFileFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UploadedFileClient<$Result.GetResult<Prisma.$UploadedFilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UploadedFile that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UploadedFileFindFirstArgs} args - Arguments to find a UploadedFile
     * @example
     * // Get one UploadedFile
     * const uploadedFile = await prisma.uploadedFile.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UploadedFileFindFirstArgs>(args?: SelectSubset<T, UploadedFileFindFirstArgs<ExtArgs>>): Prisma__UploadedFileClient<$Result.GetResult<Prisma.$UploadedFilePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UploadedFile that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UploadedFileFindFirstOrThrowArgs} args - Arguments to find a UploadedFile
     * @example
     * // Get one UploadedFile
     * const uploadedFile = await prisma.uploadedFile.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UploadedFileFindFirstOrThrowArgs>(args?: SelectSubset<T, UploadedFileFindFirstOrThrowArgs<ExtArgs>>): Prisma__UploadedFileClient<$Result.GetResult<Prisma.$UploadedFilePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UploadedFiles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UploadedFileFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UploadedFiles
     * const uploadedFiles = await prisma.uploadedFile.findMany()
     * 
     * // Get first 10 UploadedFiles
     * const uploadedFiles = await prisma.uploadedFile.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const uploadedFileWithIdOnly = await prisma.uploadedFile.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UploadedFileFindManyArgs>(args?: SelectSubset<T, UploadedFileFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UploadedFilePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UploadedFile.
     * @param {UploadedFileCreateArgs} args - Arguments to create a UploadedFile.
     * @example
     * // Create one UploadedFile
     * const UploadedFile = await prisma.uploadedFile.create({
     *   data: {
     *     // ... data to create a UploadedFile
     *   }
     * })
     * 
     */
    create<T extends UploadedFileCreateArgs>(args: SelectSubset<T, UploadedFileCreateArgs<ExtArgs>>): Prisma__UploadedFileClient<$Result.GetResult<Prisma.$UploadedFilePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UploadedFiles.
     * @param {UploadedFileCreateManyArgs} args - Arguments to create many UploadedFiles.
     * @example
     * // Create many UploadedFiles
     * const uploadedFile = await prisma.uploadedFile.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UploadedFileCreateManyArgs>(args?: SelectSubset<T, UploadedFileCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UploadedFiles and returns the data saved in the database.
     * @param {UploadedFileCreateManyAndReturnArgs} args - Arguments to create many UploadedFiles.
     * @example
     * // Create many UploadedFiles
     * const uploadedFile = await prisma.uploadedFile.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UploadedFiles and only return the `id`
     * const uploadedFileWithIdOnly = await prisma.uploadedFile.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UploadedFileCreateManyAndReturnArgs>(args?: SelectSubset<T, UploadedFileCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UploadedFilePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a UploadedFile.
     * @param {UploadedFileDeleteArgs} args - Arguments to delete one UploadedFile.
     * @example
     * // Delete one UploadedFile
     * const UploadedFile = await prisma.uploadedFile.delete({
     *   where: {
     *     // ... filter to delete one UploadedFile
     *   }
     * })
     * 
     */
    delete<T extends UploadedFileDeleteArgs>(args: SelectSubset<T, UploadedFileDeleteArgs<ExtArgs>>): Prisma__UploadedFileClient<$Result.GetResult<Prisma.$UploadedFilePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UploadedFile.
     * @param {UploadedFileUpdateArgs} args - Arguments to update one UploadedFile.
     * @example
     * // Update one UploadedFile
     * const uploadedFile = await prisma.uploadedFile.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UploadedFileUpdateArgs>(args: SelectSubset<T, UploadedFileUpdateArgs<ExtArgs>>): Prisma__UploadedFileClient<$Result.GetResult<Prisma.$UploadedFilePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UploadedFiles.
     * @param {UploadedFileDeleteManyArgs} args - Arguments to filter UploadedFiles to delete.
     * @example
     * // Delete a few UploadedFiles
     * const { count } = await prisma.uploadedFile.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UploadedFileDeleteManyArgs>(args?: SelectSubset<T, UploadedFileDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UploadedFiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UploadedFileUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UploadedFiles
     * const uploadedFile = await prisma.uploadedFile.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UploadedFileUpdateManyArgs>(args: SelectSubset<T, UploadedFileUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UploadedFiles and returns the data updated in the database.
     * @param {UploadedFileUpdateManyAndReturnArgs} args - Arguments to update many UploadedFiles.
     * @example
     * // Update many UploadedFiles
     * const uploadedFile = await prisma.uploadedFile.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more UploadedFiles and only return the `id`
     * const uploadedFileWithIdOnly = await prisma.uploadedFile.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UploadedFileUpdateManyAndReturnArgs>(args: SelectSubset<T, UploadedFileUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UploadedFilePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one UploadedFile.
     * @param {UploadedFileUpsertArgs} args - Arguments to update or create a UploadedFile.
     * @example
     * // Update or create a UploadedFile
     * const uploadedFile = await prisma.uploadedFile.upsert({
     *   create: {
     *     // ... data to create a UploadedFile
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UploadedFile we want to update
     *   }
     * })
     */
    upsert<T extends UploadedFileUpsertArgs>(args: SelectSubset<T, UploadedFileUpsertArgs<ExtArgs>>): Prisma__UploadedFileClient<$Result.GetResult<Prisma.$UploadedFilePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of UploadedFiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UploadedFileCountArgs} args - Arguments to filter UploadedFiles to count.
     * @example
     * // Count the number of UploadedFiles
     * const count = await prisma.uploadedFile.count({
     *   where: {
     *     // ... the filter for the UploadedFiles we want to count
     *   }
     * })
    **/
    count<T extends UploadedFileCountArgs>(
      args?: Subset<T, UploadedFileCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UploadedFileCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UploadedFile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UploadedFileAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UploadedFileAggregateArgs>(args: Subset<T, UploadedFileAggregateArgs>): Prisma.PrismaPromise<GetUploadedFileAggregateType<T>>

    /**
     * Group by UploadedFile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UploadedFileGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UploadedFileGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UploadedFileGroupByArgs['orderBy'] }
        : { orderBy?: UploadedFileGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UploadedFileGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUploadedFileGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UploadedFile model
   */
  readonly fields: UploadedFileFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UploadedFile.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UploadedFileClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    assignedTo<T extends UploadedFile$assignedToArgs<ExtArgs> = {}>(args?: Subset<T, UploadedFile$assignedToArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    uploadedBy<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    messages<T extends UploadedFile$messagesArgs<ExtArgs> = {}>(args?: Subset<T, UploadedFile$messagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    cloneDiscussions<T extends UploadedFile$cloneDiscussionsArgs<ExtArgs> = {}>(args?: Subset<T, UploadedFile$cloneDiscussionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CloneDiscussionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UploadedFile model
   */
  interface UploadedFileFieldRefs {
    readonly id: FieldRef<"UploadedFile", 'Int'>
    readonly filename: FieldRef<"UploadedFile", 'String'>
    readonly originalName: FieldRef<"UploadedFile", 'String'>
    readonly cloneName: FieldRef<"UploadedFile", 'String'>
    readonly size: FieldRef<"UploadedFile", 'String'>
    readonly uploadDate: FieldRef<"UploadedFile", 'String'>
    readonly status: FieldRef<"UploadedFile", 'String'>
    readonly progress: FieldRef<"UploadedFile", 'Int'>
    readonly analysisData: FieldRef<"UploadedFile", 'String'>
    readonly assignedToId: FieldRef<"UploadedFile", 'Int'>
    readonly uploadedById: FieldRef<"UploadedFile", 'Int'>
    readonly createdAt: FieldRef<"UploadedFile", 'DateTime'>
    readonly updatedAt: FieldRef<"UploadedFile", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * UploadedFile findUnique
   */
  export type UploadedFileFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UploadedFile
     */
    select?: UploadedFileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UploadedFile
     */
    omit?: UploadedFileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UploadedFileInclude<ExtArgs> | null
    /**
     * Filter, which UploadedFile to fetch.
     */
    where: UploadedFileWhereUniqueInput
  }

  /**
   * UploadedFile findUniqueOrThrow
   */
  export type UploadedFileFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UploadedFile
     */
    select?: UploadedFileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UploadedFile
     */
    omit?: UploadedFileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UploadedFileInclude<ExtArgs> | null
    /**
     * Filter, which UploadedFile to fetch.
     */
    where: UploadedFileWhereUniqueInput
  }

  /**
   * UploadedFile findFirst
   */
  export type UploadedFileFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UploadedFile
     */
    select?: UploadedFileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UploadedFile
     */
    omit?: UploadedFileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UploadedFileInclude<ExtArgs> | null
    /**
     * Filter, which UploadedFile to fetch.
     */
    where?: UploadedFileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UploadedFiles to fetch.
     */
    orderBy?: UploadedFileOrderByWithRelationInput | UploadedFileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UploadedFiles.
     */
    cursor?: UploadedFileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UploadedFiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UploadedFiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UploadedFiles.
     */
    distinct?: UploadedFileScalarFieldEnum | UploadedFileScalarFieldEnum[]
  }

  /**
   * UploadedFile findFirstOrThrow
   */
  export type UploadedFileFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UploadedFile
     */
    select?: UploadedFileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UploadedFile
     */
    omit?: UploadedFileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UploadedFileInclude<ExtArgs> | null
    /**
     * Filter, which UploadedFile to fetch.
     */
    where?: UploadedFileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UploadedFiles to fetch.
     */
    orderBy?: UploadedFileOrderByWithRelationInput | UploadedFileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UploadedFiles.
     */
    cursor?: UploadedFileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UploadedFiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UploadedFiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UploadedFiles.
     */
    distinct?: UploadedFileScalarFieldEnum | UploadedFileScalarFieldEnum[]
  }

  /**
   * UploadedFile findMany
   */
  export type UploadedFileFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UploadedFile
     */
    select?: UploadedFileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UploadedFile
     */
    omit?: UploadedFileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UploadedFileInclude<ExtArgs> | null
    /**
     * Filter, which UploadedFiles to fetch.
     */
    where?: UploadedFileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UploadedFiles to fetch.
     */
    orderBy?: UploadedFileOrderByWithRelationInput | UploadedFileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UploadedFiles.
     */
    cursor?: UploadedFileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UploadedFiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UploadedFiles.
     */
    skip?: number
    distinct?: UploadedFileScalarFieldEnum | UploadedFileScalarFieldEnum[]
  }

  /**
   * UploadedFile create
   */
  export type UploadedFileCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UploadedFile
     */
    select?: UploadedFileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UploadedFile
     */
    omit?: UploadedFileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UploadedFileInclude<ExtArgs> | null
    /**
     * The data needed to create a UploadedFile.
     */
    data: XOR<UploadedFileCreateInput, UploadedFileUncheckedCreateInput>
  }

  /**
   * UploadedFile createMany
   */
  export type UploadedFileCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UploadedFiles.
     */
    data: UploadedFileCreateManyInput | UploadedFileCreateManyInput[]
  }

  /**
   * UploadedFile createManyAndReturn
   */
  export type UploadedFileCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UploadedFile
     */
    select?: UploadedFileSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UploadedFile
     */
    omit?: UploadedFileOmit<ExtArgs> | null
    /**
     * The data used to create many UploadedFiles.
     */
    data: UploadedFileCreateManyInput | UploadedFileCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UploadedFileIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UploadedFile update
   */
  export type UploadedFileUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UploadedFile
     */
    select?: UploadedFileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UploadedFile
     */
    omit?: UploadedFileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UploadedFileInclude<ExtArgs> | null
    /**
     * The data needed to update a UploadedFile.
     */
    data: XOR<UploadedFileUpdateInput, UploadedFileUncheckedUpdateInput>
    /**
     * Choose, which UploadedFile to update.
     */
    where: UploadedFileWhereUniqueInput
  }

  /**
   * UploadedFile updateMany
   */
  export type UploadedFileUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UploadedFiles.
     */
    data: XOR<UploadedFileUpdateManyMutationInput, UploadedFileUncheckedUpdateManyInput>
    /**
     * Filter which UploadedFiles to update
     */
    where?: UploadedFileWhereInput
    /**
     * Limit how many UploadedFiles to update.
     */
    limit?: number
  }

  /**
   * UploadedFile updateManyAndReturn
   */
  export type UploadedFileUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UploadedFile
     */
    select?: UploadedFileSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UploadedFile
     */
    omit?: UploadedFileOmit<ExtArgs> | null
    /**
     * The data used to update UploadedFiles.
     */
    data: XOR<UploadedFileUpdateManyMutationInput, UploadedFileUncheckedUpdateManyInput>
    /**
     * Filter which UploadedFiles to update
     */
    where?: UploadedFileWhereInput
    /**
     * Limit how many UploadedFiles to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UploadedFileIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * UploadedFile upsert
   */
  export type UploadedFileUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UploadedFile
     */
    select?: UploadedFileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UploadedFile
     */
    omit?: UploadedFileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UploadedFileInclude<ExtArgs> | null
    /**
     * The filter to search for the UploadedFile to update in case it exists.
     */
    where: UploadedFileWhereUniqueInput
    /**
     * In case the UploadedFile found by the `where` argument doesn't exist, create a new UploadedFile with this data.
     */
    create: XOR<UploadedFileCreateInput, UploadedFileUncheckedCreateInput>
    /**
     * In case the UploadedFile was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UploadedFileUpdateInput, UploadedFileUncheckedUpdateInput>
  }

  /**
   * UploadedFile delete
   */
  export type UploadedFileDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UploadedFile
     */
    select?: UploadedFileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UploadedFile
     */
    omit?: UploadedFileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UploadedFileInclude<ExtArgs> | null
    /**
     * Filter which UploadedFile to delete.
     */
    where: UploadedFileWhereUniqueInput
  }

  /**
   * UploadedFile deleteMany
   */
  export type UploadedFileDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UploadedFiles to delete
     */
    where?: UploadedFileWhereInput
    /**
     * Limit how many UploadedFiles to delete.
     */
    limit?: number
  }

  /**
   * UploadedFile.assignedTo
   */
  export type UploadedFile$assignedToArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * UploadedFile.messages
   */
  export type UploadedFile$messagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    where?: MessageWhereInput
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    cursor?: MessageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * UploadedFile.cloneDiscussions
   */
  export type UploadedFile$cloneDiscussionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CloneDiscussion
     */
    select?: CloneDiscussionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CloneDiscussion
     */
    omit?: CloneDiscussionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CloneDiscussionInclude<ExtArgs> | null
    where?: CloneDiscussionWhereInput
    orderBy?: CloneDiscussionOrderByWithRelationInput | CloneDiscussionOrderByWithRelationInput[]
    cursor?: CloneDiscussionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CloneDiscussionScalarFieldEnum | CloneDiscussionScalarFieldEnum[]
  }

  /**
   * UploadedFile without action
   */
  export type UploadedFileDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UploadedFile
     */
    select?: UploadedFileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UploadedFile
     */
    omit?: UploadedFileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UploadedFileInclude<ExtArgs> | null
  }


  /**
   * Model CloneDiscussion
   */

  export type AggregateCloneDiscussion = {
    _count: CloneDiscussionCountAggregateOutputType | null
    _avg: CloneDiscussionAvgAggregateOutputType | null
    _sum: CloneDiscussionSumAggregateOutputType | null
    _min: CloneDiscussionMinAggregateOutputType | null
    _max: CloneDiscussionMaxAggregateOutputType | null
  }

  export type CloneDiscussionAvgAggregateOutputType = {
    id: number | null
    studentId: number | null
    cloneId: number | null
    practiceCloneId: number | null
  }

  export type CloneDiscussionSumAggregateOutputType = {
    id: number | null
    studentId: number | null
    cloneId: number | null
    practiceCloneId: number | null
  }

  export type CloneDiscussionMinAggregateOutputType = {
    id: number | null
    studentId: number | null
    cloneId: number | null
    practiceCloneId: number | null
    title: string | null
    status: string | null
    createdAt: Date | null
    updatedAt: Date | null
    lastMessageAt: Date | null
  }

  export type CloneDiscussionMaxAggregateOutputType = {
    id: number | null
    studentId: number | null
    cloneId: number | null
    practiceCloneId: number | null
    title: string | null
    status: string | null
    createdAt: Date | null
    updatedAt: Date | null
    lastMessageAt: Date | null
  }

  export type CloneDiscussionCountAggregateOutputType = {
    id: number
    studentId: number
    cloneId: number
    practiceCloneId: number
    title: number
    status: number
    createdAt: number
    updatedAt: number
    lastMessageAt: number
    _all: number
  }


  export type CloneDiscussionAvgAggregateInputType = {
    id?: true
    studentId?: true
    cloneId?: true
    practiceCloneId?: true
  }

  export type CloneDiscussionSumAggregateInputType = {
    id?: true
    studentId?: true
    cloneId?: true
    practiceCloneId?: true
  }

  export type CloneDiscussionMinAggregateInputType = {
    id?: true
    studentId?: true
    cloneId?: true
    practiceCloneId?: true
    title?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    lastMessageAt?: true
  }

  export type CloneDiscussionMaxAggregateInputType = {
    id?: true
    studentId?: true
    cloneId?: true
    practiceCloneId?: true
    title?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    lastMessageAt?: true
  }

  export type CloneDiscussionCountAggregateInputType = {
    id?: true
    studentId?: true
    cloneId?: true
    practiceCloneId?: true
    title?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    lastMessageAt?: true
    _all?: true
  }

  export type CloneDiscussionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CloneDiscussion to aggregate.
     */
    where?: CloneDiscussionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CloneDiscussions to fetch.
     */
    orderBy?: CloneDiscussionOrderByWithRelationInput | CloneDiscussionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CloneDiscussionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CloneDiscussions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CloneDiscussions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CloneDiscussions
    **/
    _count?: true | CloneDiscussionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CloneDiscussionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CloneDiscussionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CloneDiscussionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CloneDiscussionMaxAggregateInputType
  }

  export type GetCloneDiscussionAggregateType<T extends CloneDiscussionAggregateArgs> = {
        [P in keyof T & keyof AggregateCloneDiscussion]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCloneDiscussion[P]>
      : GetScalarType<T[P], AggregateCloneDiscussion[P]>
  }




  export type CloneDiscussionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CloneDiscussionWhereInput
    orderBy?: CloneDiscussionOrderByWithAggregationInput | CloneDiscussionOrderByWithAggregationInput[]
    by: CloneDiscussionScalarFieldEnum[] | CloneDiscussionScalarFieldEnum
    having?: CloneDiscussionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CloneDiscussionCountAggregateInputType | true
    _avg?: CloneDiscussionAvgAggregateInputType
    _sum?: CloneDiscussionSumAggregateInputType
    _min?: CloneDiscussionMinAggregateInputType
    _max?: CloneDiscussionMaxAggregateInputType
  }

  export type CloneDiscussionGroupByOutputType = {
    id: number
    studentId: number
    cloneId: number | null
    practiceCloneId: number | null
    title: string
    status: string
    createdAt: Date
    updatedAt: Date
    lastMessageAt: Date
    _count: CloneDiscussionCountAggregateOutputType | null
    _avg: CloneDiscussionAvgAggregateOutputType | null
    _sum: CloneDiscussionSumAggregateOutputType | null
    _min: CloneDiscussionMinAggregateOutputType | null
    _max: CloneDiscussionMaxAggregateOutputType | null
  }

  type GetCloneDiscussionGroupByPayload<T extends CloneDiscussionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CloneDiscussionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CloneDiscussionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CloneDiscussionGroupByOutputType[P]>
            : GetScalarType<T[P], CloneDiscussionGroupByOutputType[P]>
        }
      >
    >


  export type CloneDiscussionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    studentId?: boolean
    cloneId?: boolean
    practiceCloneId?: boolean
    title?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    lastMessageAt?: boolean
    student?: boolean | UserDefaultArgs<ExtArgs>
    clone?: boolean | CloneDiscussion$cloneArgs<ExtArgs>
    practiceClone?: boolean | CloneDiscussion$practiceCloneArgs<ExtArgs>
    messages?: boolean | CloneDiscussion$messagesArgs<ExtArgs>
    _count?: boolean | CloneDiscussionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cloneDiscussion"]>

  export type CloneDiscussionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    studentId?: boolean
    cloneId?: boolean
    practiceCloneId?: boolean
    title?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    lastMessageAt?: boolean
    student?: boolean | UserDefaultArgs<ExtArgs>
    clone?: boolean | CloneDiscussion$cloneArgs<ExtArgs>
    practiceClone?: boolean | CloneDiscussion$practiceCloneArgs<ExtArgs>
  }, ExtArgs["result"]["cloneDiscussion"]>

  export type CloneDiscussionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    studentId?: boolean
    cloneId?: boolean
    practiceCloneId?: boolean
    title?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    lastMessageAt?: boolean
    student?: boolean | UserDefaultArgs<ExtArgs>
    clone?: boolean | CloneDiscussion$cloneArgs<ExtArgs>
    practiceClone?: boolean | CloneDiscussion$practiceCloneArgs<ExtArgs>
  }, ExtArgs["result"]["cloneDiscussion"]>

  export type CloneDiscussionSelectScalar = {
    id?: boolean
    studentId?: boolean
    cloneId?: boolean
    practiceCloneId?: boolean
    title?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    lastMessageAt?: boolean
  }

  export type CloneDiscussionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "studentId" | "cloneId" | "practiceCloneId" | "title" | "status" | "createdAt" | "updatedAt" | "lastMessageAt", ExtArgs["result"]["cloneDiscussion"]>
  export type CloneDiscussionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    student?: boolean | UserDefaultArgs<ExtArgs>
    clone?: boolean | CloneDiscussion$cloneArgs<ExtArgs>
    practiceClone?: boolean | CloneDiscussion$practiceCloneArgs<ExtArgs>
    messages?: boolean | CloneDiscussion$messagesArgs<ExtArgs>
    _count?: boolean | CloneDiscussionCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CloneDiscussionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    student?: boolean | UserDefaultArgs<ExtArgs>
    clone?: boolean | CloneDiscussion$cloneArgs<ExtArgs>
    practiceClone?: boolean | CloneDiscussion$practiceCloneArgs<ExtArgs>
  }
  export type CloneDiscussionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    student?: boolean | UserDefaultArgs<ExtArgs>
    clone?: boolean | CloneDiscussion$cloneArgs<ExtArgs>
    practiceClone?: boolean | CloneDiscussion$practiceCloneArgs<ExtArgs>
  }

  export type $CloneDiscussionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CloneDiscussion"
    objects: {
      student: Prisma.$UserPayload<ExtArgs>
      clone: Prisma.$UploadedFilePayload<ExtArgs> | null
      practiceClone: Prisma.$PracticeClonePayload<ExtArgs> | null
      messages: Prisma.$DiscussionMessagePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      studentId: number
      cloneId: number | null
      practiceCloneId: number | null
      title: string
      status: string
      createdAt: Date
      updatedAt: Date
      lastMessageAt: Date
    }, ExtArgs["result"]["cloneDiscussion"]>
    composites: {}
  }

  type CloneDiscussionGetPayload<S extends boolean | null | undefined | CloneDiscussionDefaultArgs> = $Result.GetResult<Prisma.$CloneDiscussionPayload, S>

  type CloneDiscussionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CloneDiscussionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CloneDiscussionCountAggregateInputType | true
    }

  export interface CloneDiscussionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CloneDiscussion'], meta: { name: 'CloneDiscussion' } }
    /**
     * Find zero or one CloneDiscussion that matches the filter.
     * @param {CloneDiscussionFindUniqueArgs} args - Arguments to find a CloneDiscussion
     * @example
     * // Get one CloneDiscussion
     * const cloneDiscussion = await prisma.cloneDiscussion.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CloneDiscussionFindUniqueArgs>(args: SelectSubset<T, CloneDiscussionFindUniqueArgs<ExtArgs>>): Prisma__CloneDiscussionClient<$Result.GetResult<Prisma.$CloneDiscussionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CloneDiscussion that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CloneDiscussionFindUniqueOrThrowArgs} args - Arguments to find a CloneDiscussion
     * @example
     * // Get one CloneDiscussion
     * const cloneDiscussion = await prisma.cloneDiscussion.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CloneDiscussionFindUniqueOrThrowArgs>(args: SelectSubset<T, CloneDiscussionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CloneDiscussionClient<$Result.GetResult<Prisma.$CloneDiscussionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CloneDiscussion that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CloneDiscussionFindFirstArgs} args - Arguments to find a CloneDiscussion
     * @example
     * // Get one CloneDiscussion
     * const cloneDiscussion = await prisma.cloneDiscussion.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CloneDiscussionFindFirstArgs>(args?: SelectSubset<T, CloneDiscussionFindFirstArgs<ExtArgs>>): Prisma__CloneDiscussionClient<$Result.GetResult<Prisma.$CloneDiscussionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CloneDiscussion that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CloneDiscussionFindFirstOrThrowArgs} args - Arguments to find a CloneDiscussion
     * @example
     * // Get one CloneDiscussion
     * const cloneDiscussion = await prisma.cloneDiscussion.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CloneDiscussionFindFirstOrThrowArgs>(args?: SelectSubset<T, CloneDiscussionFindFirstOrThrowArgs<ExtArgs>>): Prisma__CloneDiscussionClient<$Result.GetResult<Prisma.$CloneDiscussionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CloneDiscussions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CloneDiscussionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CloneDiscussions
     * const cloneDiscussions = await prisma.cloneDiscussion.findMany()
     * 
     * // Get first 10 CloneDiscussions
     * const cloneDiscussions = await prisma.cloneDiscussion.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const cloneDiscussionWithIdOnly = await prisma.cloneDiscussion.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CloneDiscussionFindManyArgs>(args?: SelectSubset<T, CloneDiscussionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CloneDiscussionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CloneDiscussion.
     * @param {CloneDiscussionCreateArgs} args - Arguments to create a CloneDiscussion.
     * @example
     * // Create one CloneDiscussion
     * const CloneDiscussion = await prisma.cloneDiscussion.create({
     *   data: {
     *     // ... data to create a CloneDiscussion
     *   }
     * })
     * 
     */
    create<T extends CloneDiscussionCreateArgs>(args: SelectSubset<T, CloneDiscussionCreateArgs<ExtArgs>>): Prisma__CloneDiscussionClient<$Result.GetResult<Prisma.$CloneDiscussionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CloneDiscussions.
     * @param {CloneDiscussionCreateManyArgs} args - Arguments to create many CloneDiscussions.
     * @example
     * // Create many CloneDiscussions
     * const cloneDiscussion = await prisma.cloneDiscussion.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CloneDiscussionCreateManyArgs>(args?: SelectSubset<T, CloneDiscussionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CloneDiscussions and returns the data saved in the database.
     * @param {CloneDiscussionCreateManyAndReturnArgs} args - Arguments to create many CloneDiscussions.
     * @example
     * // Create many CloneDiscussions
     * const cloneDiscussion = await prisma.cloneDiscussion.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CloneDiscussions and only return the `id`
     * const cloneDiscussionWithIdOnly = await prisma.cloneDiscussion.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CloneDiscussionCreateManyAndReturnArgs>(args?: SelectSubset<T, CloneDiscussionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CloneDiscussionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CloneDiscussion.
     * @param {CloneDiscussionDeleteArgs} args - Arguments to delete one CloneDiscussion.
     * @example
     * // Delete one CloneDiscussion
     * const CloneDiscussion = await prisma.cloneDiscussion.delete({
     *   where: {
     *     // ... filter to delete one CloneDiscussion
     *   }
     * })
     * 
     */
    delete<T extends CloneDiscussionDeleteArgs>(args: SelectSubset<T, CloneDiscussionDeleteArgs<ExtArgs>>): Prisma__CloneDiscussionClient<$Result.GetResult<Prisma.$CloneDiscussionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CloneDiscussion.
     * @param {CloneDiscussionUpdateArgs} args - Arguments to update one CloneDiscussion.
     * @example
     * // Update one CloneDiscussion
     * const cloneDiscussion = await prisma.cloneDiscussion.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CloneDiscussionUpdateArgs>(args: SelectSubset<T, CloneDiscussionUpdateArgs<ExtArgs>>): Prisma__CloneDiscussionClient<$Result.GetResult<Prisma.$CloneDiscussionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CloneDiscussions.
     * @param {CloneDiscussionDeleteManyArgs} args - Arguments to filter CloneDiscussions to delete.
     * @example
     * // Delete a few CloneDiscussions
     * const { count } = await prisma.cloneDiscussion.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CloneDiscussionDeleteManyArgs>(args?: SelectSubset<T, CloneDiscussionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CloneDiscussions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CloneDiscussionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CloneDiscussions
     * const cloneDiscussion = await prisma.cloneDiscussion.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CloneDiscussionUpdateManyArgs>(args: SelectSubset<T, CloneDiscussionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CloneDiscussions and returns the data updated in the database.
     * @param {CloneDiscussionUpdateManyAndReturnArgs} args - Arguments to update many CloneDiscussions.
     * @example
     * // Update many CloneDiscussions
     * const cloneDiscussion = await prisma.cloneDiscussion.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CloneDiscussions and only return the `id`
     * const cloneDiscussionWithIdOnly = await prisma.cloneDiscussion.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CloneDiscussionUpdateManyAndReturnArgs>(args: SelectSubset<T, CloneDiscussionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CloneDiscussionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CloneDiscussion.
     * @param {CloneDiscussionUpsertArgs} args - Arguments to update or create a CloneDiscussion.
     * @example
     * // Update or create a CloneDiscussion
     * const cloneDiscussion = await prisma.cloneDiscussion.upsert({
     *   create: {
     *     // ... data to create a CloneDiscussion
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CloneDiscussion we want to update
     *   }
     * })
     */
    upsert<T extends CloneDiscussionUpsertArgs>(args: SelectSubset<T, CloneDiscussionUpsertArgs<ExtArgs>>): Prisma__CloneDiscussionClient<$Result.GetResult<Prisma.$CloneDiscussionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CloneDiscussions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CloneDiscussionCountArgs} args - Arguments to filter CloneDiscussions to count.
     * @example
     * // Count the number of CloneDiscussions
     * const count = await prisma.cloneDiscussion.count({
     *   where: {
     *     // ... the filter for the CloneDiscussions we want to count
     *   }
     * })
    **/
    count<T extends CloneDiscussionCountArgs>(
      args?: Subset<T, CloneDiscussionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CloneDiscussionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CloneDiscussion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CloneDiscussionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CloneDiscussionAggregateArgs>(args: Subset<T, CloneDiscussionAggregateArgs>): Prisma.PrismaPromise<GetCloneDiscussionAggregateType<T>>

    /**
     * Group by CloneDiscussion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CloneDiscussionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CloneDiscussionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CloneDiscussionGroupByArgs['orderBy'] }
        : { orderBy?: CloneDiscussionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CloneDiscussionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCloneDiscussionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CloneDiscussion model
   */
  readonly fields: CloneDiscussionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CloneDiscussion.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CloneDiscussionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    student<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    clone<T extends CloneDiscussion$cloneArgs<ExtArgs> = {}>(args?: Subset<T, CloneDiscussion$cloneArgs<ExtArgs>>): Prisma__UploadedFileClient<$Result.GetResult<Prisma.$UploadedFilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    practiceClone<T extends CloneDiscussion$practiceCloneArgs<ExtArgs> = {}>(args?: Subset<T, CloneDiscussion$practiceCloneArgs<ExtArgs>>): Prisma__PracticeCloneClient<$Result.GetResult<Prisma.$PracticeClonePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    messages<T extends CloneDiscussion$messagesArgs<ExtArgs> = {}>(args?: Subset<T, CloneDiscussion$messagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DiscussionMessagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CloneDiscussion model
   */
  interface CloneDiscussionFieldRefs {
    readonly id: FieldRef<"CloneDiscussion", 'Int'>
    readonly studentId: FieldRef<"CloneDiscussion", 'Int'>
    readonly cloneId: FieldRef<"CloneDiscussion", 'Int'>
    readonly practiceCloneId: FieldRef<"CloneDiscussion", 'Int'>
    readonly title: FieldRef<"CloneDiscussion", 'String'>
    readonly status: FieldRef<"CloneDiscussion", 'String'>
    readonly createdAt: FieldRef<"CloneDiscussion", 'DateTime'>
    readonly updatedAt: FieldRef<"CloneDiscussion", 'DateTime'>
    readonly lastMessageAt: FieldRef<"CloneDiscussion", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CloneDiscussion findUnique
   */
  export type CloneDiscussionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CloneDiscussion
     */
    select?: CloneDiscussionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CloneDiscussion
     */
    omit?: CloneDiscussionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CloneDiscussionInclude<ExtArgs> | null
    /**
     * Filter, which CloneDiscussion to fetch.
     */
    where: CloneDiscussionWhereUniqueInput
  }

  /**
   * CloneDiscussion findUniqueOrThrow
   */
  export type CloneDiscussionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CloneDiscussion
     */
    select?: CloneDiscussionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CloneDiscussion
     */
    omit?: CloneDiscussionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CloneDiscussionInclude<ExtArgs> | null
    /**
     * Filter, which CloneDiscussion to fetch.
     */
    where: CloneDiscussionWhereUniqueInput
  }

  /**
   * CloneDiscussion findFirst
   */
  export type CloneDiscussionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CloneDiscussion
     */
    select?: CloneDiscussionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CloneDiscussion
     */
    omit?: CloneDiscussionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CloneDiscussionInclude<ExtArgs> | null
    /**
     * Filter, which CloneDiscussion to fetch.
     */
    where?: CloneDiscussionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CloneDiscussions to fetch.
     */
    orderBy?: CloneDiscussionOrderByWithRelationInput | CloneDiscussionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CloneDiscussions.
     */
    cursor?: CloneDiscussionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CloneDiscussions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CloneDiscussions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CloneDiscussions.
     */
    distinct?: CloneDiscussionScalarFieldEnum | CloneDiscussionScalarFieldEnum[]
  }

  /**
   * CloneDiscussion findFirstOrThrow
   */
  export type CloneDiscussionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CloneDiscussion
     */
    select?: CloneDiscussionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CloneDiscussion
     */
    omit?: CloneDiscussionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CloneDiscussionInclude<ExtArgs> | null
    /**
     * Filter, which CloneDiscussion to fetch.
     */
    where?: CloneDiscussionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CloneDiscussions to fetch.
     */
    orderBy?: CloneDiscussionOrderByWithRelationInput | CloneDiscussionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CloneDiscussions.
     */
    cursor?: CloneDiscussionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CloneDiscussions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CloneDiscussions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CloneDiscussions.
     */
    distinct?: CloneDiscussionScalarFieldEnum | CloneDiscussionScalarFieldEnum[]
  }

  /**
   * CloneDiscussion findMany
   */
  export type CloneDiscussionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CloneDiscussion
     */
    select?: CloneDiscussionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CloneDiscussion
     */
    omit?: CloneDiscussionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CloneDiscussionInclude<ExtArgs> | null
    /**
     * Filter, which CloneDiscussions to fetch.
     */
    where?: CloneDiscussionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CloneDiscussions to fetch.
     */
    orderBy?: CloneDiscussionOrderByWithRelationInput | CloneDiscussionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CloneDiscussions.
     */
    cursor?: CloneDiscussionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CloneDiscussions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CloneDiscussions.
     */
    skip?: number
    distinct?: CloneDiscussionScalarFieldEnum | CloneDiscussionScalarFieldEnum[]
  }

  /**
   * CloneDiscussion create
   */
  export type CloneDiscussionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CloneDiscussion
     */
    select?: CloneDiscussionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CloneDiscussion
     */
    omit?: CloneDiscussionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CloneDiscussionInclude<ExtArgs> | null
    /**
     * The data needed to create a CloneDiscussion.
     */
    data: XOR<CloneDiscussionCreateInput, CloneDiscussionUncheckedCreateInput>
  }

  /**
   * CloneDiscussion createMany
   */
  export type CloneDiscussionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CloneDiscussions.
     */
    data: CloneDiscussionCreateManyInput | CloneDiscussionCreateManyInput[]
  }

  /**
   * CloneDiscussion createManyAndReturn
   */
  export type CloneDiscussionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CloneDiscussion
     */
    select?: CloneDiscussionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CloneDiscussion
     */
    omit?: CloneDiscussionOmit<ExtArgs> | null
    /**
     * The data used to create many CloneDiscussions.
     */
    data: CloneDiscussionCreateManyInput | CloneDiscussionCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CloneDiscussionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CloneDiscussion update
   */
  export type CloneDiscussionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CloneDiscussion
     */
    select?: CloneDiscussionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CloneDiscussion
     */
    omit?: CloneDiscussionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CloneDiscussionInclude<ExtArgs> | null
    /**
     * The data needed to update a CloneDiscussion.
     */
    data: XOR<CloneDiscussionUpdateInput, CloneDiscussionUncheckedUpdateInput>
    /**
     * Choose, which CloneDiscussion to update.
     */
    where: CloneDiscussionWhereUniqueInput
  }

  /**
   * CloneDiscussion updateMany
   */
  export type CloneDiscussionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CloneDiscussions.
     */
    data: XOR<CloneDiscussionUpdateManyMutationInput, CloneDiscussionUncheckedUpdateManyInput>
    /**
     * Filter which CloneDiscussions to update
     */
    where?: CloneDiscussionWhereInput
    /**
     * Limit how many CloneDiscussions to update.
     */
    limit?: number
  }

  /**
   * CloneDiscussion updateManyAndReturn
   */
  export type CloneDiscussionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CloneDiscussion
     */
    select?: CloneDiscussionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CloneDiscussion
     */
    omit?: CloneDiscussionOmit<ExtArgs> | null
    /**
     * The data used to update CloneDiscussions.
     */
    data: XOR<CloneDiscussionUpdateManyMutationInput, CloneDiscussionUncheckedUpdateManyInput>
    /**
     * Filter which CloneDiscussions to update
     */
    where?: CloneDiscussionWhereInput
    /**
     * Limit how many CloneDiscussions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CloneDiscussionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * CloneDiscussion upsert
   */
  export type CloneDiscussionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CloneDiscussion
     */
    select?: CloneDiscussionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CloneDiscussion
     */
    omit?: CloneDiscussionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CloneDiscussionInclude<ExtArgs> | null
    /**
     * The filter to search for the CloneDiscussion to update in case it exists.
     */
    where: CloneDiscussionWhereUniqueInput
    /**
     * In case the CloneDiscussion found by the `where` argument doesn't exist, create a new CloneDiscussion with this data.
     */
    create: XOR<CloneDiscussionCreateInput, CloneDiscussionUncheckedCreateInput>
    /**
     * In case the CloneDiscussion was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CloneDiscussionUpdateInput, CloneDiscussionUncheckedUpdateInput>
  }

  /**
   * CloneDiscussion delete
   */
  export type CloneDiscussionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CloneDiscussion
     */
    select?: CloneDiscussionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CloneDiscussion
     */
    omit?: CloneDiscussionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CloneDiscussionInclude<ExtArgs> | null
    /**
     * Filter which CloneDiscussion to delete.
     */
    where: CloneDiscussionWhereUniqueInput
  }

  /**
   * CloneDiscussion deleteMany
   */
  export type CloneDiscussionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CloneDiscussions to delete
     */
    where?: CloneDiscussionWhereInput
    /**
     * Limit how many CloneDiscussions to delete.
     */
    limit?: number
  }

  /**
   * CloneDiscussion.clone
   */
  export type CloneDiscussion$cloneArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UploadedFile
     */
    select?: UploadedFileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UploadedFile
     */
    omit?: UploadedFileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UploadedFileInclude<ExtArgs> | null
    where?: UploadedFileWhereInput
  }

  /**
   * CloneDiscussion.practiceClone
   */
  export type CloneDiscussion$practiceCloneArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PracticeClone
     */
    select?: PracticeCloneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PracticeClone
     */
    omit?: PracticeCloneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PracticeCloneInclude<ExtArgs> | null
    where?: PracticeCloneWhereInput
  }

  /**
   * CloneDiscussion.messages
   */
  export type CloneDiscussion$messagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DiscussionMessage
     */
    select?: DiscussionMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DiscussionMessage
     */
    omit?: DiscussionMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DiscussionMessageInclude<ExtArgs> | null
    where?: DiscussionMessageWhereInput
    orderBy?: DiscussionMessageOrderByWithRelationInput | DiscussionMessageOrderByWithRelationInput[]
    cursor?: DiscussionMessageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DiscussionMessageScalarFieldEnum | DiscussionMessageScalarFieldEnum[]
  }

  /**
   * CloneDiscussion without action
   */
  export type CloneDiscussionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CloneDiscussion
     */
    select?: CloneDiscussionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CloneDiscussion
     */
    omit?: CloneDiscussionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CloneDiscussionInclude<ExtArgs> | null
  }


  /**
   * Model DiscussionMessage
   */

  export type AggregateDiscussionMessage = {
    _count: DiscussionMessageCountAggregateOutputType | null
    _avg: DiscussionMessageAvgAggregateOutputType | null
    _sum: DiscussionMessageSumAggregateOutputType | null
    _min: DiscussionMessageMinAggregateOutputType | null
    _max: DiscussionMessageMaxAggregateOutputType | null
  }

  export type DiscussionMessageAvgAggregateOutputType = {
    id: number | null
    discussionId: number | null
    senderId: number | null
  }

  export type DiscussionMessageSumAggregateOutputType = {
    id: number | null
    discussionId: number | null
    senderId: number | null
  }

  export type DiscussionMessageMinAggregateOutputType = {
    id: number | null
    discussionId: number | null
    senderId: number | null
    content: string | null
    messageType: string | null
    readBy: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DiscussionMessageMaxAggregateOutputType = {
    id: number | null
    discussionId: number | null
    senderId: number | null
    content: string | null
    messageType: string | null
    readBy: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DiscussionMessageCountAggregateOutputType = {
    id: number
    discussionId: number
    senderId: number
    content: number
    messageType: number
    readBy: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type DiscussionMessageAvgAggregateInputType = {
    id?: true
    discussionId?: true
    senderId?: true
  }

  export type DiscussionMessageSumAggregateInputType = {
    id?: true
    discussionId?: true
    senderId?: true
  }

  export type DiscussionMessageMinAggregateInputType = {
    id?: true
    discussionId?: true
    senderId?: true
    content?: true
    messageType?: true
    readBy?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DiscussionMessageMaxAggregateInputType = {
    id?: true
    discussionId?: true
    senderId?: true
    content?: true
    messageType?: true
    readBy?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DiscussionMessageCountAggregateInputType = {
    id?: true
    discussionId?: true
    senderId?: true
    content?: true
    messageType?: true
    readBy?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type DiscussionMessageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DiscussionMessage to aggregate.
     */
    where?: DiscussionMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DiscussionMessages to fetch.
     */
    orderBy?: DiscussionMessageOrderByWithRelationInput | DiscussionMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DiscussionMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DiscussionMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DiscussionMessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DiscussionMessages
    **/
    _count?: true | DiscussionMessageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DiscussionMessageAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DiscussionMessageSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DiscussionMessageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DiscussionMessageMaxAggregateInputType
  }

  export type GetDiscussionMessageAggregateType<T extends DiscussionMessageAggregateArgs> = {
        [P in keyof T & keyof AggregateDiscussionMessage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDiscussionMessage[P]>
      : GetScalarType<T[P], AggregateDiscussionMessage[P]>
  }




  export type DiscussionMessageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DiscussionMessageWhereInput
    orderBy?: DiscussionMessageOrderByWithAggregationInput | DiscussionMessageOrderByWithAggregationInput[]
    by: DiscussionMessageScalarFieldEnum[] | DiscussionMessageScalarFieldEnum
    having?: DiscussionMessageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DiscussionMessageCountAggregateInputType | true
    _avg?: DiscussionMessageAvgAggregateInputType
    _sum?: DiscussionMessageSumAggregateInputType
    _min?: DiscussionMessageMinAggregateInputType
    _max?: DiscussionMessageMaxAggregateInputType
  }

  export type DiscussionMessageGroupByOutputType = {
    id: number
    discussionId: number
    senderId: number
    content: string
    messageType: string
    readBy: string | null
    createdAt: Date
    updatedAt: Date
    _count: DiscussionMessageCountAggregateOutputType | null
    _avg: DiscussionMessageAvgAggregateOutputType | null
    _sum: DiscussionMessageSumAggregateOutputType | null
    _min: DiscussionMessageMinAggregateOutputType | null
    _max: DiscussionMessageMaxAggregateOutputType | null
  }

  type GetDiscussionMessageGroupByPayload<T extends DiscussionMessageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DiscussionMessageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DiscussionMessageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DiscussionMessageGroupByOutputType[P]>
            : GetScalarType<T[P], DiscussionMessageGroupByOutputType[P]>
        }
      >
    >


  export type DiscussionMessageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    discussionId?: boolean
    senderId?: boolean
    content?: boolean
    messageType?: boolean
    readBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    discussion?: boolean | CloneDiscussionDefaultArgs<ExtArgs>
    sender?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["discussionMessage"]>

  export type DiscussionMessageSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    discussionId?: boolean
    senderId?: boolean
    content?: boolean
    messageType?: boolean
    readBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    discussion?: boolean | CloneDiscussionDefaultArgs<ExtArgs>
    sender?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["discussionMessage"]>

  export type DiscussionMessageSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    discussionId?: boolean
    senderId?: boolean
    content?: boolean
    messageType?: boolean
    readBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    discussion?: boolean | CloneDiscussionDefaultArgs<ExtArgs>
    sender?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["discussionMessage"]>

  export type DiscussionMessageSelectScalar = {
    id?: boolean
    discussionId?: boolean
    senderId?: boolean
    content?: boolean
    messageType?: boolean
    readBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type DiscussionMessageOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "discussionId" | "senderId" | "content" | "messageType" | "readBy" | "createdAt" | "updatedAt", ExtArgs["result"]["discussionMessage"]>
  export type DiscussionMessageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    discussion?: boolean | CloneDiscussionDefaultArgs<ExtArgs>
    sender?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type DiscussionMessageIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    discussion?: boolean | CloneDiscussionDefaultArgs<ExtArgs>
    sender?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type DiscussionMessageIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    discussion?: boolean | CloneDiscussionDefaultArgs<ExtArgs>
    sender?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $DiscussionMessagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DiscussionMessage"
    objects: {
      discussion: Prisma.$CloneDiscussionPayload<ExtArgs>
      sender: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      discussionId: number
      senderId: number
      content: string
      messageType: string
      readBy: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["discussionMessage"]>
    composites: {}
  }

  type DiscussionMessageGetPayload<S extends boolean | null | undefined | DiscussionMessageDefaultArgs> = $Result.GetResult<Prisma.$DiscussionMessagePayload, S>

  type DiscussionMessageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DiscussionMessageFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DiscussionMessageCountAggregateInputType | true
    }

  export interface DiscussionMessageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DiscussionMessage'], meta: { name: 'DiscussionMessage' } }
    /**
     * Find zero or one DiscussionMessage that matches the filter.
     * @param {DiscussionMessageFindUniqueArgs} args - Arguments to find a DiscussionMessage
     * @example
     * // Get one DiscussionMessage
     * const discussionMessage = await prisma.discussionMessage.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DiscussionMessageFindUniqueArgs>(args: SelectSubset<T, DiscussionMessageFindUniqueArgs<ExtArgs>>): Prisma__DiscussionMessageClient<$Result.GetResult<Prisma.$DiscussionMessagePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one DiscussionMessage that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DiscussionMessageFindUniqueOrThrowArgs} args - Arguments to find a DiscussionMessage
     * @example
     * // Get one DiscussionMessage
     * const discussionMessage = await prisma.discussionMessage.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DiscussionMessageFindUniqueOrThrowArgs>(args: SelectSubset<T, DiscussionMessageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DiscussionMessageClient<$Result.GetResult<Prisma.$DiscussionMessagePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DiscussionMessage that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DiscussionMessageFindFirstArgs} args - Arguments to find a DiscussionMessage
     * @example
     * // Get one DiscussionMessage
     * const discussionMessage = await prisma.discussionMessage.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DiscussionMessageFindFirstArgs>(args?: SelectSubset<T, DiscussionMessageFindFirstArgs<ExtArgs>>): Prisma__DiscussionMessageClient<$Result.GetResult<Prisma.$DiscussionMessagePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DiscussionMessage that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DiscussionMessageFindFirstOrThrowArgs} args - Arguments to find a DiscussionMessage
     * @example
     * // Get one DiscussionMessage
     * const discussionMessage = await prisma.discussionMessage.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DiscussionMessageFindFirstOrThrowArgs>(args?: SelectSubset<T, DiscussionMessageFindFirstOrThrowArgs<ExtArgs>>): Prisma__DiscussionMessageClient<$Result.GetResult<Prisma.$DiscussionMessagePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more DiscussionMessages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DiscussionMessageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DiscussionMessages
     * const discussionMessages = await prisma.discussionMessage.findMany()
     * 
     * // Get first 10 DiscussionMessages
     * const discussionMessages = await prisma.discussionMessage.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const discussionMessageWithIdOnly = await prisma.discussionMessage.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DiscussionMessageFindManyArgs>(args?: SelectSubset<T, DiscussionMessageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DiscussionMessagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a DiscussionMessage.
     * @param {DiscussionMessageCreateArgs} args - Arguments to create a DiscussionMessage.
     * @example
     * // Create one DiscussionMessage
     * const DiscussionMessage = await prisma.discussionMessage.create({
     *   data: {
     *     // ... data to create a DiscussionMessage
     *   }
     * })
     * 
     */
    create<T extends DiscussionMessageCreateArgs>(args: SelectSubset<T, DiscussionMessageCreateArgs<ExtArgs>>): Prisma__DiscussionMessageClient<$Result.GetResult<Prisma.$DiscussionMessagePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many DiscussionMessages.
     * @param {DiscussionMessageCreateManyArgs} args - Arguments to create many DiscussionMessages.
     * @example
     * // Create many DiscussionMessages
     * const discussionMessage = await prisma.discussionMessage.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DiscussionMessageCreateManyArgs>(args?: SelectSubset<T, DiscussionMessageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many DiscussionMessages and returns the data saved in the database.
     * @param {DiscussionMessageCreateManyAndReturnArgs} args - Arguments to create many DiscussionMessages.
     * @example
     * // Create many DiscussionMessages
     * const discussionMessage = await prisma.discussionMessage.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many DiscussionMessages and only return the `id`
     * const discussionMessageWithIdOnly = await prisma.discussionMessage.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DiscussionMessageCreateManyAndReturnArgs>(args?: SelectSubset<T, DiscussionMessageCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DiscussionMessagePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a DiscussionMessage.
     * @param {DiscussionMessageDeleteArgs} args - Arguments to delete one DiscussionMessage.
     * @example
     * // Delete one DiscussionMessage
     * const DiscussionMessage = await prisma.discussionMessage.delete({
     *   where: {
     *     // ... filter to delete one DiscussionMessage
     *   }
     * })
     * 
     */
    delete<T extends DiscussionMessageDeleteArgs>(args: SelectSubset<T, DiscussionMessageDeleteArgs<ExtArgs>>): Prisma__DiscussionMessageClient<$Result.GetResult<Prisma.$DiscussionMessagePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one DiscussionMessage.
     * @param {DiscussionMessageUpdateArgs} args - Arguments to update one DiscussionMessage.
     * @example
     * // Update one DiscussionMessage
     * const discussionMessage = await prisma.discussionMessage.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DiscussionMessageUpdateArgs>(args: SelectSubset<T, DiscussionMessageUpdateArgs<ExtArgs>>): Prisma__DiscussionMessageClient<$Result.GetResult<Prisma.$DiscussionMessagePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more DiscussionMessages.
     * @param {DiscussionMessageDeleteManyArgs} args - Arguments to filter DiscussionMessages to delete.
     * @example
     * // Delete a few DiscussionMessages
     * const { count } = await prisma.discussionMessage.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DiscussionMessageDeleteManyArgs>(args?: SelectSubset<T, DiscussionMessageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DiscussionMessages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DiscussionMessageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DiscussionMessages
     * const discussionMessage = await prisma.discussionMessage.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DiscussionMessageUpdateManyArgs>(args: SelectSubset<T, DiscussionMessageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DiscussionMessages and returns the data updated in the database.
     * @param {DiscussionMessageUpdateManyAndReturnArgs} args - Arguments to update many DiscussionMessages.
     * @example
     * // Update many DiscussionMessages
     * const discussionMessage = await prisma.discussionMessage.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more DiscussionMessages and only return the `id`
     * const discussionMessageWithIdOnly = await prisma.discussionMessage.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends DiscussionMessageUpdateManyAndReturnArgs>(args: SelectSubset<T, DiscussionMessageUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DiscussionMessagePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one DiscussionMessage.
     * @param {DiscussionMessageUpsertArgs} args - Arguments to update or create a DiscussionMessage.
     * @example
     * // Update or create a DiscussionMessage
     * const discussionMessage = await prisma.discussionMessage.upsert({
     *   create: {
     *     // ... data to create a DiscussionMessage
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DiscussionMessage we want to update
     *   }
     * })
     */
    upsert<T extends DiscussionMessageUpsertArgs>(args: SelectSubset<T, DiscussionMessageUpsertArgs<ExtArgs>>): Prisma__DiscussionMessageClient<$Result.GetResult<Prisma.$DiscussionMessagePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of DiscussionMessages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DiscussionMessageCountArgs} args - Arguments to filter DiscussionMessages to count.
     * @example
     * // Count the number of DiscussionMessages
     * const count = await prisma.discussionMessage.count({
     *   where: {
     *     // ... the filter for the DiscussionMessages we want to count
     *   }
     * })
    **/
    count<T extends DiscussionMessageCountArgs>(
      args?: Subset<T, DiscussionMessageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DiscussionMessageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DiscussionMessage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DiscussionMessageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DiscussionMessageAggregateArgs>(args: Subset<T, DiscussionMessageAggregateArgs>): Prisma.PrismaPromise<GetDiscussionMessageAggregateType<T>>

    /**
     * Group by DiscussionMessage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DiscussionMessageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DiscussionMessageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DiscussionMessageGroupByArgs['orderBy'] }
        : { orderBy?: DiscussionMessageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DiscussionMessageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDiscussionMessageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DiscussionMessage model
   */
  readonly fields: DiscussionMessageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DiscussionMessage.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DiscussionMessageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    discussion<T extends CloneDiscussionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CloneDiscussionDefaultArgs<ExtArgs>>): Prisma__CloneDiscussionClient<$Result.GetResult<Prisma.$CloneDiscussionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    sender<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DiscussionMessage model
   */
  interface DiscussionMessageFieldRefs {
    readonly id: FieldRef<"DiscussionMessage", 'Int'>
    readonly discussionId: FieldRef<"DiscussionMessage", 'Int'>
    readonly senderId: FieldRef<"DiscussionMessage", 'Int'>
    readonly content: FieldRef<"DiscussionMessage", 'String'>
    readonly messageType: FieldRef<"DiscussionMessage", 'String'>
    readonly readBy: FieldRef<"DiscussionMessage", 'String'>
    readonly createdAt: FieldRef<"DiscussionMessage", 'DateTime'>
    readonly updatedAt: FieldRef<"DiscussionMessage", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * DiscussionMessage findUnique
   */
  export type DiscussionMessageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DiscussionMessage
     */
    select?: DiscussionMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DiscussionMessage
     */
    omit?: DiscussionMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DiscussionMessageInclude<ExtArgs> | null
    /**
     * Filter, which DiscussionMessage to fetch.
     */
    where: DiscussionMessageWhereUniqueInput
  }

  /**
   * DiscussionMessage findUniqueOrThrow
   */
  export type DiscussionMessageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DiscussionMessage
     */
    select?: DiscussionMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DiscussionMessage
     */
    omit?: DiscussionMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DiscussionMessageInclude<ExtArgs> | null
    /**
     * Filter, which DiscussionMessage to fetch.
     */
    where: DiscussionMessageWhereUniqueInput
  }

  /**
   * DiscussionMessage findFirst
   */
  export type DiscussionMessageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DiscussionMessage
     */
    select?: DiscussionMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DiscussionMessage
     */
    omit?: DiscussionMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DiscussionMessageInclude<ExtArgs> | null
    /**
     * Filter, which DiscussionMessage to fetch.
     */
    where?: DiscussionMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DiscussionMessages to fetch.
     */
    orderBy?: DiscussionMessageOrderByWithRelationInput | DiscussionMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DiscussionMessages.
     */
    cursor?: DiscussionMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DiscussionMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DiscussionMessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DiscussionMessages.
     */
    distinct?: DiscussionMessageScalarFieldEnum | DiscussionMessageScalarFieldEnum[]
  }

  /**
   * DiscussionMessage findFirstOrThrow
   */
  export type DiscussionMessageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DiscussionMessage
     */
    select?: DiscussionMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DiscussionMessage
     */
    omit?: DiscussionMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DiscussionMessageInclude<ExtArgs> | null
    /**
     * Filter, which DiscussionMessage to fetch.
     */
    where?: DiscussionMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DiscussionMessages to fetch.
     */
    orderBy?: DiscussionMessageOrderByWithRelationInput | DiscussionMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DiscussionMessages.
     */
    cursor?: DiscussionMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DiscussionMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DiscussionMessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DiscussionMessages.
     */
    distinct?: DiscussionMessageScalarFieldEnum | DiscussionMessageScalarFieldEnum[]
  }

  /**
   * DiscussionMessage findMany
   */
  export type DiscussionMessageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DiscussionMessage
     */
    select?: DiscussionMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DiscussionMessage
     */
    omit?: DiscussionMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DiscussionMessageInclude<ExtArgs> | null
    /**
     * Filter, which DiscussionMessages to fetch.
     */
    where?: DiscussionMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DiscussionMessages to fetch.
     */
    orderBy?: DiscussionMessageOrderByWithRelationInput | DiscussionMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DiscussionMessages.
     */
    cursor?: DiscussionMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DiscussionMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DiscussionMessages.
     */
    skip?: number
    distinct?: DiscussionMessageScalarFieldEnum | DiscussionMessageScalarFieldEnum[]
  }

  /**
   * DiscussionMessage create
   */
  export type DiscussionMessageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DiscussionMessage
     */
    select?: DiscussionMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DiscussionMessage
     */
    omit?: DiscussionMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DiscussionMessageInclude<ExtArgs> | null
    /**
     * The data needed to create a DiscussionMessage.
     */
    data: XOR<DiscussionMessageCreateInput, DiscussionMessageUncheckedCreateInput>
  }

  /**
   * DiscussionMessage createMany
   */
  export type DiscussionMessageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DiscussionMessages.
     */
    data: DiscussionMessageCreateManyInput | DiscussionMessageCreateManyInput[]
  }

  /**
   * DiscussionMessage createManyAndReturn
   */
  export type DiscussionMessageCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DiscussionMessage
     */
    select?: DiscussionMessageSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DiscussionMessage
     */
    omit?: DiscussionMessageOmit<ExtArgs> | null
    /**
     * The data used to create many DiscussionMessages.
     */
    data: DiscussionMessageCreateManyInput | DiscussionMessageCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DiscussionMessageIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * DiscussionMessage update
   */
  export type DiscussionMessageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DiscussionMessage
     */
    select?: DiscussionMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DiscussionMessage
     */
    omit?: DiscussionMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DiscussionMessageInclude<ExtArgs> | null
    /**
     * The data needed to update a DiscussionMessage.
     */
    data: XOR<DiscussionMessageUpdateInput, DiscussionMessageUncheckedUpdateInput>
    /**
     * Choose, which DiscussionMessage to update.
     */
    where: DiscussionMessageWhereUniqueInput
  }

  /**
   * DiscussionMessage updateMany
   */
  export type DiscussionMessageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DiscussionMessages.
     */
    data: XOR<DiscussionMessageUpdateManyMutationInput, DiscussionMessageUncheckedUpdateManyInput>
    /**
     * Filter which DiscussionMessages to update
     */
    where?: DiscussionMessageWhereInput
    /**
     * Limit how many DiscussionMessages to update.
     */
    limit?: number
  }

  /**
   * DiscussionMessage updateManyAndReturn
   */
  export type DiscussionMessageUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DiscussionMessage
     */
    select?: DiscussionMessageSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DiscussionMessage
     */
    omit?: DiscussionMessageOmit<ExtArgs> | null
    /**
     * The data used to update DiscussionMessages.
     */
    data: XOR<DiscussionMessageUpdateManyMutationInput, DiscussionMessageUncheckedUpdateManyInput>
    /**
     * Filter which DiscussionMessages to update
     */
    where?: DiscussionMessageWhereInput
    /**
     * Limit how many DiscussionMessages to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DiscussionMessageIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * DiscussionMessage upsert
   */
  export type DiscussionMessageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DiscussionMessage
     */
    select?: DiscussionMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DiscussionMessage
     */
    omit?: DiscussionMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DiscussionMessageInclude<ExtArgs> | null
    /**
     * The filter to search for the DiscussionMessage to update in case it exists.
     */
    where: DiscussionMessageWhereUniqueInput
    /**
     * In case the DiscussionMessage found by the `where` argument doesn't exist, create a new DiscussionMessage with this data.
     */
    create: XOR<DiscussionMessageCreateInput, DiscussionMessageUncheckedCreateInput>
    /**
     * In case the DiscussionMessage was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DiscussionMessageUpdateInput, DiscussionMessageUncheckedUpdateInput>
  }

  /**
   * DiscussionMessage delete
   */
  export type DiscussionMessageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DiscussionMessage
     */
    select?: DiscussionMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DiscussionMessage
     */
    omit?: DiscussionMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DiscussionMessageInclude<ExtArgs> | null
    /**
     * Filter which DiscussionMessage to delete.
     */
    where: DiscussionMessageWhereUniqueInput
  }

  /**
   * DiscussionMessage deleteMany
   */
  export type DiscussionMessageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DiscussionMessages to delete
     */
    where?: DiscussionMessageWhereInput
    /**
     * Limit how many DiscussionMessages to delete.
     */
    limit?: number
  }

  /**
   * DiscussionMessage without action
   */
  export type DiscussionMessageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DiscussionMessage
     */
    select?: DiscussionMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DiscussionMessage
     */
    omit?: DiscussionMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DiscussionMessageInclude<ExtArgs> | null
  }


  /**
   * Model Message
   */

  export type AggregateMessage = {
    _count: MessageCountAggregateOutputType | null
    _avg: MessageAvgAggregateOutputType | null
    _sum: MessageSumAggregateOutputType | null
    _min: MessageMinAggregateOutputType | null
    _max: MessageMaxAggregateOutputType | null
  }

  export type MessageAvgAggregateOutputType = {
    id: number | null
    senderId: number | null
    recipientId: number | null
    cloneId: number | null
    cloneProgress: number | null
  }

  export type MessageSumAggregateOutputType = {
    id: number | null
    senderId: number | null
    recipientId: number | null
    cloneId: number | null
    cloneProgress: number | null
  }

  export type MessageMinAggregateOutputType = {
    id: number | null
    subject: string | null
    content: string | null
    messageType: string | null
    isRead: boolean | null
    senderId: number | null
    recipientId: number | null
    cloneId: number | null
    cloneProgress: number | null
    currentStep: string | null
    createdAt: Date | null
    updatedAt: Date | null
    isGroupMessage: boolean | null
    groupParticipants: string | null
  }

  export type MessageMaxAggregateOutputType = {
    id: number | null
    subject: string | null
    content: string | null
    messageType: string | null
    isRead: boolean | null
    senderId: number | null
    recipientId: number | null
    cloneId: number | null
    cloneProgress: number | null
    currentStep: string | null
    createdAt: Date | null
    updatedAt: Date | null
    isGroupMessage: boolean | null
    groupParticipants: string | null
  }

  export type MessageCountAggregateOutputType = {
    id: number
    subject: number
    content: number
    messageType: number
    isRead: number
    senderId: number
    recipientId: number
    cloneId: number
    cloneProgress: number
    currentStep: number
    createdAt: number
    updatedAt: number
    isGroupMessage: number
    groupParticipants: number
    _all: number
  }


  export type MessageAvgAggregateInputType = {
    id?: true
    senderId?: true
    recipientId?: true
    cloneId?: true
    cloneProgress?: true
  }

  export type MessageSumAggregateInputType = {
    id?: true
    senderId?: true
    recipientId?: true
    cloneId?: true
    cloneProgress?: true
  }

  export type MessageMinAggregateInputType = {
    id?: true
    subject?: true
    content?: true
    messageType?: true
    isRead?: true
    senderId?: true
    recipientId?: true
    cloneId?: true
    cloneProgress?: true
    currentStep?: true
    createdAt?: true
    updatedAt?: true
    isGroupMessage?: true
    groupParticipants?: true
  }

  export type MessageMaxAggregateInputType = {
    id?: true
    subject?: true
    content?: true
    messageType?: true
    isRead?: true
    senderId?: true
    recipientId?: true
    cloneId?: true
    cloneProgress?: true
    currentStep?: true
    createdAt?: true
    updatedAt?: true
    isGroupMessage?: true
    groupParticipants?: true
  }

  export type MessageCountAggregateInputType = {
    id?: true
    subject?: true
    content?: true
    messageType?: true
    isRead?: true
    senderId?: true
    recipientId?: true
    cloneId?: true
    cloneProgress?: true
    currentStep?: true
    createdAt?: true
    updatedAt?: true
    isGroupMessage?: true
    groupParticipants?: true
    _all?: true
  }

  export type MessageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Message to aggregate.
     */
    where?: MessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Messages to fetch.
     */
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Messages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Messages
    **/
    _count?: true | MessageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MessageAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MessageSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MessageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MessageMaxAggregateInputType
  }

  export type GetMessageAggregateType<T extends MessageAggregateArgs> = {
        [P in keyof T & keyof AggregateMessage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMessage[P]>
      : GetScalarType<T[P], AggregateMessage[P]>
  }




  export type MessageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MessageWhereInput
    orderBy?: MessageOrderByWithAggregationInput | MessageOrderByWithAggregationInput[]
    by: MessageScalarFieldEnum[] | MessageScalarFieldEnum
    having?: MessageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MessageCountAggregateInputType | true
    _avg?: MessageAvgAggregateInputType
    _sum?: MessageSumAggregateInputType
    _min?: MessageMinAggregateInputType
    _max?: MessageMaxAggregateInputType
  }

  export type MessageGroupByOutputType = {
    id: number
    subject: string
    content: string
    messageType: string
    isRead: boolean
    senderId: number
    recipientId: number
    cloneId: number | null
    cloneProgress: number | null
    currentStep: string | null
    createdAt: Date
    updatedAt: Date
    isGroupMessage: boolean | null
    groupParticipants: string | null
    _count: MessageCountAggregateOutputType | null
    _avg: MessageAvgAggregateOutputType | null
    _sum: MessageSumAggregateOutputType | null
    _min: MessageMinAggregateOutputType | null
    _max: MessageMaxAggregateOutputType | null
  }

  type GetMessageGroupByPayload<T extends MessageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MessageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MessageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MessageGroupByOutputType[P]>
            : GetScalarType<T[P], MessageGroupByOutputType[P]>
        }
      >
    >


  export type MessageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    subject?: boolean
    content?: boolean
    messageType?: boolean
    isRead?: boolean
    senderId?: boolean
    recipientId?: boolean
    cloneId?: boolean
    cloneProgress?: boolean
    currentStep?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    isGroupMessage?: boolean
    groupParticipants?: boolean
    sender?: boolean | UserDefaultArgs<ExtArgs>
    recipient?: boolean | UserDefaultArgs<ExtArgs>
    clone?: boolean | Message$cloneArgs<ExtArgs>
  }, ExtArgs["result"]["message"]>

  export type MessageSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    subject?: boolean
    content?: boolean
    messageType?: boolean
    isRead?: boolean
    senderId?: boolean
    recipientId?: boolean
    cloneId?: boolean
    cloneProgress?: boolean
    currentStep?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    isGroupMessage?: boolean
    groupParticipants?: boolean
    sender?: boolean | UserDefaultArgs<ExtArgs>
    recipient?: boolean | UserDefaultArgs<ExtArgs>
    clone?: boolean | Message$cloneArgs<ExtArgs>
  }, ExtArgs["result"]["message"]>

  export type MessageSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    subject?: boolean
    content?: boolean
    messageType?: boolean
    isRead?: boolean
    senderId?: boolean
    recipientId?: boolean
    cloneId?: boolean
    cloneProgress?: boolean
    currentStep?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    isGroupMessage?: boolean
    groupParticipants?: boolean
    sender?: boolean | UserDefaultArgs<ExtArgs>
    recipient?: boolean | UserDefaultArgs<ExtArgs>
    clone?: boolean | Message$cloneArgs<ExtArgs>
  }, ExtArgs["result"]["message"]>

  export type MessageSelectScalar = {
    id?: boolean
    subject?: boolean
    content?: boolean
    messageType?: boolean
    isRead?: boolean
    senderId?: boolean
    recipientId?: boolean
    cloneId?: boolean
    cloneProgress?: boolean
    currentStep?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    isGroupMessage?: boolean
    groupParticipants?: boolean
  }

  export type MessageOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "subject" | "content" | "messageType" | "isRead" | "senderId" | "recipientId" | "cloneId" | "cloneProgress" | "currentStep" | "createdAt" | "updatedAt" | "isGroupMessage" | "groupParticipants", ExtArgs["result"]["message"]>
  export type MessageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sender?: boolean | UserDefaultArgs<ExtArgs>
    recipient?: boolean | UserDefaultArgs<ExtArgs>
    clone?: boolean | Message$cloneArgs<ExtArgs>
  }
  export type MessageIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sender?: boolean | UserDefaultArgs<ExtArgs>
    recipient?: boolean | UserDefaultArgs<ExtArgs>
    clone?: boolean | Message$cloneArgs<ExtArgs>
  }
  export type MessageIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sender?: boolean | UserDefaultArgs<ExtArgs>
    recipient?: boolean | UserDefaultArgs<ExtArgs>
    clone?: boolean | Message$cloneArgs<ExtArgs>
  }

  export type $MessagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Message"
    objects: {
      sender: Prisma.$UserPayload<ExtArgs>
      recipient: Prisma.$UserPayload<ExtArgs>
      clone: Prisma.$UploadedFilePayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      subject: string
      content: string
      messageType: string
      isRead: boolean
      senderId: number
      recipientId: number
      cloneId: number | null
      cloneProgress: number | null
      currentStep: string | null
      createdAt: Date
      updatedAt: Date
      isGroupMessage: boolean | null
      groupParticipants: string | null
    }, ExtArgs["result"]["message"]>
    composites: {}
  }

  type MessageGetPayload<S extends boolean | null | undefined | MessageDefaultArgs> = $Result.GetResult<Prisma.$MessagePayload, S>

  type MessageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MessageFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MessageCountAggregateInputType | true
    }

  export interface MessageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Message'], meta: { name: 'Message' } }
    /**
     * Find zero or one Message that matches the filter.
     * @param {MessageFindUniqueArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MessageFindUniqueArgs>(args: SelectSubset<T, MessageFindUniqueArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Message that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MessageFindUniqueOrThrowArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MessageFindUniqueOrThrowArgs>(args: SelectSubset<T, MessageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Message that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageFindFirstArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MessageFindFirstArgs>(args?: SelectSubset<T, MessageFindFirstArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Message that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageFindFirstOrThrowArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MessageFindFirstOrThrowArgs>(args?: SelectSubset<T, MessageFindFirstOrThrowArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Messages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Messages
     * const messages = await prisma.message.findMany()
     * 
     * // Get first 10 Messages
     * const messages = await prisma.message.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const messageWithIdOnly = await prisma.message.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MessageFindManyArgs>(args?: SelectSubset<T, MessageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Message.
     * @param {MessageCreateArgs} args - Arguments to create a Message.
     * @example
     * // Create one Message
     * const Message = await prisma.message.create({
     *   data: {
     *     // ... data to create a Message
     *   }
     * })
     * 
     */
    create<T extends MessageCreateArgs>(args: SelectSubset<T, MessageCreateArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Messages.
     * @param {MessageCreateManyArgs} args - Arguments to create many Messages.
     * @example
     * // Create many Messages
     * const message = await prisma.message.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MessageCreateManyArgs>(args?: SelectSubset<T, MessageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Messages and returns the data saved in the database.
     * @param {MessageCreateManyAndReturnArgs} args - Arguments to create many Messages.
     * @example
     * // Create many Messages
     * const message = await prisma.message.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Messages and only return the `id`
     * const messageWithIdOnly = await prisma.message.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MessageCreateManyAndReturnArgs>(args?: SelectSubset<T, MessageCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Message.
     * @param {MessageDeleteArgs} args - Arguments to delete one Message.
     * @example
     * // Delete one Message
     * const Message = await prisma.message.delete({
     *   where: {
     *     // ... filter to delete one Message
     *   }
     * })
     * 
     */
    delete<T extends MessageDeleteArgs>(args: SelectSubset<T, MessageDeleteArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Message.
     * @param {MessageUpdateArgs} args - Arguments to update one Message.
     * @example
     * // Update one Message
     * const message = await prisma.message.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MessageUpdateArgs>(args: SelectSubset<T, MessageUpdateArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Messages.
     * @param {MessageDeleteManyArgs} args - Arguments to filter Messages to delete.
     * @example
     * // Delete a few Messages
     * const { count } = await prisma.message.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MessageDeleteManyArgs>(args?: SelectSubset<T, MessageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Messages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Messages
     * const message = await prisma.message.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MessageUpdateManyArgs>(args: SelectSubset<T, MessageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Messages and returns the data updated in the database.
     * @param {MessageUpdateManyAndReturnArgs} args - Arguments to update many Messages.
     * @example
     * // Update many Messages
     * const message = await prisma.message.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Messages and only return the `id`
     * const messageWithIdOnly = await prisma.message.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MessageUpdateManyAndReturnArgs>(args: SelectSubset<T, MessageUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Message.
     * @param {MessageUpsertArgs} args - Arguments to update or create a Message.
     * @example
     * // Update or create a Message
     * const message = await prisma.message.upsert({
     *   create: {
     *     // ... data to create a Message
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Message we want to update
     *   }
     * })
     */
    upsert<T extends MessageUpsertArgs>(args: SelectSubset<T, MessageUpsertArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Messages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageCountArgs} args - Arguments to filter Messages to count.
     * @example
     * // Count the number of Messages
     * const count = await prisma.message.count({
     *   where: {
     *     // ... the filter for the Messages we want to count
     *   }
     * })
    **/
    count<T extends MessageCountArgs>(
      args?: Subset<T, MessageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MessageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Message.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MessageAggregateArgs>(args: Subset<T, MessageAggregateArgs>): Prisma.PrismaPromise<GetMessageAggregateType<T>>

    /**
     * Group by Message.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MessageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MessageGroupByArgs['orderBy'] }
        : { orderBy?: MessageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MessageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMessageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Message model
   */
  readonly fields: MessageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Message.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MessageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    sender<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    recipient<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    clone<T extends Message$cloneArgs<ExtArgs> = {}>(args?: Subset<T, Message$cloneArgs<ExtArgs>>): Prisma__UploadedFileClient<$Result.GetResult<Prisma.$UploadedFilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Message model
   */
  interface MessageFieldRefs {
    readonly id: FieldRef<"Message", 'Int'>
    readonly subject: FieldRef<"Message", 'String'>
    readonly content: FieldRef<"Message", 'String'>
    readonly messageType: FieldRef<"Message", 'String'>
    readonly isRead: FieldRef<"Message", 'Boolean'>
    readonly senderId: FieldRef<"Message", 'Int'>
    readonly recipientId: FieldRef<"Message", 'Int'>
    readonly cloneId: FieldRef<"Message", 'Int'>
    readonly cloneProgress: FieldRef<"Message", 'Int'>
    readonly currentStep: FieldRef<"Message", 'String'>
    readonly createdAt: FieldRef<"Message", 'DateTime'>
    readonly updatedAt: FieldRef<"Message", 'DateTime'>
    readonly isGroupMessage: FieldRef<"Message", 'Boolean'>
    readonly groupParticipants: FieldRef<"Message", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Message findUnique
   */
  export type MessageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter, which Message to fetch.
     */
    where: MessageWhereUniqueInput
  }

  /**
   * Message findUniqueOrThrow
   */
  export type MessageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter, which Message to fetch.
     */
    where: MessageWhereUniqueInput
  }

  /**
   * Message findFirst
   */
  export type MessageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter, which Message to fetch.
     */
    where?: MessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Messages to fetch.
     */
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Messages.
     */
    cursor?: MessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Messages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Messages.
     */
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * Message findFirstOrThrow
   */
  export type MessageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter, which Message to fetch.
     */
    where?: MessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Messages to fetch.
     */
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Messages.
     */
    cursor?: MessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Messages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Messages.
     */
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * Message findMany
   */
  export type MessageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter, which Messages to fetch.
     */
    where?: MessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Messages to fetch.
     */
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Messages.
     */
    cursor?: MessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Messages.
     */
    skip?: number
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * Message create
   */
  export type MessageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * The data needed to create a Message.
     */
    data: XOR<MessageCreateInput, MessageUncheckedCreateInput>
  }

  /**
   * Message createMany
   */
  export type MessageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Messages.
     */
    data: MessageCreateManyInput | MessageCreateManyInput[]
  }

  /**
   * Message createManyAndReturn
   */
  export type MessageCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * The data used to create many Messages.
     */
    data: MessageCreateManyInput | MessageCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Message update
   */
  export type MessageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * The data needed to update a Message.
     */
    data: XOR<MessageUpdateInput, MessageUncheckedUpdateInput>
    /**
     * Choose, which Message to update.
     */
    where: MessageWhereUniqueInput
  }

  /**
   * Message updateMany
   */
  export type MessageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Messages.
     */
    data: XOR<MessageUpdateManyMutationInput, MessageUncheckedUpdateManyInput>
    /**
     * Filter which Messages to update
     */
    where?: MessageWhereInput
    /**
     * Limit how many Messages to update.
     */
    limit?: number
  }

  /**
   * Message updateManyAndReturn
   */
  export type MessageUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * The data used to update Messages.
     */
    data: XOR<MessageUpdateManyMutationInput, MessageUncheckedUpdateManyInput>
    /**
     * Filter which Messages to update
     */
    where?: MessageWhereInput
    /**
     * Limit how many Messages to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Message upsert
   */
  export type MessageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * The filter to search for the Message to update in case it exists.
     */
    where: MessageWhereUniqueInput
    /**
     * In case the Message found by the `where` argument doesn't exist, create a new Message with this data.
     */
    create: XOR<MessageCreateInput, MessageUncheckedCreateInput>
    /**
     * In case the Message was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MessageUpdateInput, MessageUncheckedUpdateInput>
  }

  /**
   * Message delete
   */
  export type MessageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter which Message to delete.
     */
    where: MessageWhereUniqueInput
  }

  /**
   * Message deleteMany
   */
  export type MessageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Messages to delete
     */
    where?: MessageWhereInput
    /**
     * Limit how many Messages to delete.
     */
    limit?: number
  }

  /**
   * Message.clone
   */
  export type Message$cloneArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UploadedFile
     */
    select?: UploadedFileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UploadedFile
     */
    omit?: UploadedFileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UploadedFileInclude<ExtArgs> | null
    where?: UploadedFileWhereInput
  }

  /**
   * Message without action
   */
  export type MessageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
  }


  /**
   * Model PracticeClone
   */

  export type AggregatePracticeClone = {
    _count: PracticeCloneCountAggregateOutputType | null
    _avg: PracticeCloneAvgAggregateOutputType | null
    _sum: PracticeCloneSumAggregateOutputType | null
    _min: PracticeCloneMinAggregateOutputType | null
    _max: PracticeCloneMaxAggregateOutputType | null
  }

  export type PracticeCloneAvgAggregateOutputType = {
    id: number | null
  }

  export type PracticeCloneSumAggregateOutputType = {
    id: number | null
  }

  export type PracticeCloneMinAggregateOutputType = {
    id: number | null
    cloneName: string | null
    filename: string | null
    originalName: string | null
    description: string | null
    isActive: boolean | null
    uploadDate: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PracticeCloneMaxAggregateOutputType = {
    id: number | null
    cloneName: string | null
    filename: string | null
    originalName: string | null
    description: string | null
    isActive: boolean | null
    uploadDate: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PracticeCloneCountAggregateOutputType = {
    id: number
    cloneName: number
    filename: number
    originalName: number
    description: number
    isActive: number
    uploadDate: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PracticeCloneAvgAggregateInputType = {
    id?: true
  }

  export type PracticeCloneSumAggregateInputType = {
    id?: true
  }

  export type PracticeCloneMinAggregateInputType = {
    id?: true
    cloneName?: true
    filename?: true
    originalName?: true
    description?: true
    isActive?: true
    uploadDate?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PracticeCloneMaxAggregateInputType = {
    id?: true
    cloneName?: true
    filename?: true
    originalName?: true
    description?: true
    isActive?: true
    uploadDate?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PracticeCloneCountAggregateInputType = {
    id?: true
    cloneName?: true
    filename?: true
    originalName?: true
    description?: true
    isActive?: true
    uploadDate?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PracticeCloneAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PracticeClone to aggregate.
     */
    where?: PracticeCloneWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PracticeClones to fetch.
     */
    orderBy?: PracticeCloneOrderByWithRelationInput | PracticeCloneOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PracticeCloneWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PracticeClones from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PracticeClones.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PracticeClones
    **/
    _count?: true | PracticeCloneCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PracticeCloneAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PracticeCloneSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PracticeCloneMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PracticeCloneMaxAggregateInputType
  }

  export type GetPracticeCloneAggregateType<T extends PracticeCloneAggregateArgs> = {
        [P in keyof T & keyof AggregatePracticeClone]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePracticeClone[P]>
      : GetScalarType<T[P], AggregatePracticeClone[P]>
  }




  export type PracticeCloneGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PracticeCloneWhereInput
    orderBy?: PracticeCloneOrderByWithAggregationInput | PracticeCloneOrderByWithAggregationInput[]
    by: PracticeCloneScalarFieldEnum[] | PracticeCloneScalarFieldEnum
    having?: PracticeCloneScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PracticeCloneCountAggregateInputType | true
    _avg?: PracticeCloneAvgAggregateInputType
    _sum?: PracticeCloneSumAggregateInputType
    _min?: PracticeCloneMinAggregateInputType
    _max?: PracticeCloneMaxAggregateInputType
  }

  export type PracticeCloneGroupByOutputType = {
    id: number
    cloneName: string
    filename: string
    originalName: string
    description: string | null
    isActive: boolean
    uploadDate: Date
    createdAt: Date
    updatedAt: Date
    _count: PracticeCloneCountAggregateOutputType | null
    _avg: PracticeCloneAvgAggregateOutputType | null
    _sum: PracticeCloneSumAggregateOutputType | null
    _min: PracticeCloneMinAggregateOutputType | null
    _max: PracticeCloneMaxAggregateOutputType | null
  }

  type GetPracticeCloneGroupByPayload<T extends PracticeCloneGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PracticeCloneGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PracticeCloneGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PracticeCloneGroupByOutputType[P]>
            : GetScalarType<T[P], PracticeCloneGroupByOutputType[P]>
        }
      >
    >


  export type PracticeCloneSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    cloneName?: boolean
    filename?: boolean
    originalName?: boolean
    description?: boolean
    isActive?: boolean
    uploadDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    practiceAnswers?: boolean | PracticeClone$practiceAnswersArgs<ExtArgs>
    userProgress?: boolean | PracticeClone$userProgressArgs<ExtArgs>
    cloneDiscussions?: boolean | PracticeClone$cloneDiscussionsArgs<ExtArgs>
    _count?: boolean | PracticeCloneCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["practiceClone"]>

  export type PracticeCloneSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    cloneName?: boolean
    filename?: boolean
    originalName?: boolean
    description?: boolean
    isActive?: boolean
    uploadDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["practiceClone"]>

  export type PracticeCloneSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    cloneName?: boolean
    filename?: boolean
    originalName?: boolean
    description?: boolean
    isActive?: boolean
    uploadDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["practiceClone"]>

  export type PracticeCloneSelectScalar = {
    id?: boolean
    cloneName?: boolean
    filename?: boolean
    originalName?: boolean
    description?: boolean
    isActive?: boolean
    uploadDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PracticeCloneOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "cloneName" | "filename" | "originalName" | "description" | "isActive" | "uploadDate" | "createdAt" | "updatedAt", ExtArgs["result"]["practiceClone"]>
  export type PracticeCloneInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    practiceAnswers?: boolean | PracticeClone$practiceAnswersArgs<ExtArgs>
    userProgress?: boolean | PracticeClone$userProgressArgs<ExtArgs>
    cloneDiscussions?: boolean | PracticeClone$cloneDiscussionsArgs<ExtArgs>
    _count?: boolean | PracticeCloneCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PracticeCloneIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type PracticeCloneIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $PracticeClonePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PracticeClone"
    objects: {
      practiceAnswers: Prisma.$PracticeAnswerPayload<ExtArgs>[]
      userProgress: Prisma.$UserPracticeProgressPayload<ExtArgs>[]
      cloneDiscussions: Prisma.$CloneDiscussionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      cloneName: string
      filename: string
      originalName: string
      description: string | null
      isActive: boolean
      uploadDate: Date
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["practiceClone"]>
    composites: {}
  }

  type PracticeCloneGetPayload<S extends boolean | null | undefined | PracticeCloneDefaultArgs> = $Result.GetResult<Prisma.$PracticeClonePayload, S>

  type PracticeCloneCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PracticeCloneFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PracticeCloneCountAggregateInputType | true
    }

  export interface PracticeCloneDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PracticeClone'], meta: { name: 'PracticeClone' } }
    /**
     * Find zero or one PracticeClone that matches the filter.
     * @param {PracticeCloneFindUniqueArgs} args - Arguments to find a PracticeClone
     * @example
     * // Get one PracticeClone
     * const practiceClone = await prisma.practiceClone.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PracticeCloneFindUniqueArgs>(args: SelectSubset<T, PracticeCloneFindUniqueArgs<ExtArgs>>): Prisma__PracticeCloneClient<$Result.GetResult<Prisma.$PracticeClonePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PracticeClone that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PracticeCloneFindUniqueOrThrowArgs} args - Arguments to find a PracticeClone
     * @example
     * // Get one PracticeClone
     * const practiceClone = await prisma.practiceClone.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PracticeCloneFindUniqueOrThrowArgs>(args: SelectSubset<T, PracticeCloneFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PracticeCloneClient<$Result.GetResult<Prisma.$PracticeClonePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PracticeClone that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PracticeCloneFindFirstArgs} args - Arguments to find a PracticeClone
     * @example
     * // Get one PracticeClone
     * const practiceClone = await prisma.practiceClone.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PracticeCloneFindFirstArgs>(args?: SelectSubset<T, PracticeCloneFindFirstArgs<ExtArgs>>): Prisma__PracticeCloneClient<$Result.GetResult<Prisma.$PracticeClonePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PracticeClone that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PracticeCloneFindFirstOrThrowArgs} args - Arguments to find a PracticeClone
     * @example
     * // Get one PracticeClone
     * const practiceClone = await prisma.practiceClone.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PracticeCloneFindFirstOrThrowArgs>(args?: SelectSubset<T, PracticeCloneFindFirstOrThrowArgs<ExtArgs>>): Prisma__PracticeCloneClient<$Result.GetResult<Prisma.$PracticeClonePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PracticeClones that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PracticeCloneFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PracticeClones
     * const practiceClones = await prisma.practiceClone.findMany()
     * 
     * // Get first 10 PracticeClones
     * const practiceClones = await prisma.practiceClone.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const practiceCloneWithIdOnly = await prisma.practiceClone.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PracticeCloneFindManyArgs>(args?: SelectSubset<T, PracticeCloneFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PracticeClonePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PracticeClone.
     * @param {PracticeCloneCreateArgs} args - Arguments to create a PracticeClone.
     * @example
     * // Create one PracticeClone
     * const PracticeClone = await prisma.practiceClone.create({
     *   data: {
     *     // ... data to create a PracticeClone
     *   }
     * })
     * 
     */
    create<T extends PracticeCloneCreateArgs>(args: SelectSubset<T, PracticeCloneCreateArgs<ExtArgs>>): Prisma__PracticeCloneClient<$Result.GetResult<Prisma.$PracticeClonePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PracticeClones.
     * @param {PracticeCloneCreateManyArgs} args - Arguments to create many PracticeClones.
     * @example
     * // Create many PracticeClones
     * const practiceClone = await prisma.practiceClone.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PracticeCloneCreateManyArgs>(args?: SelectSubset<T, PracticeCloneCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PracticeClones and returns the data saved in the database.
     * @param {PracticeCloneCreateManyAndReturnArgs} args - Arguments to create many PracticeClones.
     * @example
     * // Create many PracticeClones
     * const practiceClone = await prisma.practiceClone.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PracticeClones and only return the `id`
     * const practiceCloneWithIdOnly = await prisma.practiceClone.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PracticeCloneCreateManyAndReturnArgs>(args?: SelectSubset<T, PracticeCloneCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PracticeClonePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PracticeClone.
     * @param {PracticeCloneDeleteArgs} args - Arguments to delete one PracticeClone.
     * @example
     * // Delete one PracticeClone
     * const PracticeClone = await prisma.practiceClone.delete({
     *   where: {
     *     // ... filter to delete one PracticeClone
     *   }
     * })
     * 
     */
    delete<T extends PracticeCloneDeleteArgs>(args: SelectSubset<T, PracticeCloneDeleteArgs<ExtArgs>>): Prisma__PracticeCloneClient<$Result.GetResult<Prisma.$PracticeClonePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PracticeClone.
     * @param {PracticeCloneUpdateArgs} args - Arguments to update one PracticeClone.
     * @example
     * // Update one PracticeClone
     * const practiceClone = await prisma.practiceClone.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PracticeCloneUpdateArgs>(args: SelectSubset<T, PracticeCloneUpdateArgs<ExtArgs>>): Prisma__PracticeCloneClient<$Result.GetResult<Prisma.$PracticeClonePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PracticeClones.
     * @param {PracticeCloneDeleteManyArgs} args - Arguments to filter PracticeClones to delete.
     * @example
     * // Delete a few PracticeClones
     * const { count } = await prisma.practiceClone.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PracticeCloneDeleteManyArgs>(args?: SelectSubset<T, PracticeCloneDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PracticeClones.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PracticeCloneUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PracticeClones
     * const practiceClone = await prisma.practiceClone.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PracticeCloneUpdateManyArgs>(args: SelectSubset<T, PracticeCloneUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PracticeClones and returns the data updated in the database.
     * @param {PracticeCloneUpdateManyAndReturnArgs} args - Arguments to update many PracticeClones.
     * @example
     * // Update many PracticeClones
     * const practiceClone = await prisma.practiceClone.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PracticeClones and only return the `id`
     * const practiceCloneWithIdOnly = await prisma.practiceClone.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PracticeCloneUpdateManyAndReturnArgs>(args: SelectSubset<T, PracticeCloneUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PracticeClonePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PracticeClone.
     * @param {PracticeCloneUpsertArgs} args - Arguments to update or create a PracticeClone.
     * @example
     * // Update or create a PracticeClone
     * const practiceClone = await prisma.practiceClone.upsert({
     *   create: {
     *     // ... data to create a PracticeClone
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PracticeClone we want to update
     *   }
     * })
     */
    upsert<T extends PracticeCloneUpsertArgs>(args: SelectSubset<T, PracticeCloneUpsertArgs<ExtArgs>>): Prisma__PracticeCloneClient<$Result.GetResult<Prisma.$PracticeClonePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PracticeClones.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PracticeCloneCountArgs} args - Arguments to filter PracticeClones to count.
     * @example
     * // Count the number of PracticeClones
     * const count = await prisma.practiceClone.count({
     *   where: {
     *     // ... the filter for the PracticeClones we want to count
     *   }
     * })
    **/
    count<T extends PracticeCloneCountArgs>(
      args?: Subset<T, PracticeCloneCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PracticeCloneCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PracticeClone.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PracticeCloneAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PracticeCloneAggregateArgs>(args: Subset<T, PracticeCloneAggregateArgs>): Prisma.PrismaPromise<GetPracticeCloneAggregateType<T>>

    /**
     * Group by PracticeClone.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PracticeCloneGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PracticeCloneGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PracticeCloneGroupByArgs['orderBy'] }
        : { orderBy?: PracticeCloneGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PracticeCloneGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPracticeCloneGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PracticeClone model
   */
  readonly fields: PracticeCloneFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PracticeClone.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PracticeCloneClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    practiceAnswers<T extends PracticeClone$practiceAnswersArgs<ExtArgs> = {}>(args?: Subset<T, PracticeClone$practiceAnswersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PracticeAnswerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    userProgress<T extends PracticeClone$userProgressArgs<ExtArgs> = {}>(args?: Subset<T, PracticeClone$userProgressArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPracticeProgressPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    cloneDiscussions<T extends PracticeClone$cloneDiscussionsArgs<ExtArgs> = {}>(args?: Subset<T, PracticeClone$cloneDiscussionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CloneDiscussionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PracticeClone model
   */
  interface PracticeCloneFieldRefs {
    readonly id: FieldRef<"PracticeClone", 'Int'>
    readonly cloneName: FieldRef<"PracticeClone", 'String'>
    readonly filename: FieldRef<"PracticeClone", 'String'>
    readonly originalName: FieldRef<"PracticeClone", 'String'>
    readonly description: FieldRef<"PracticeClone", 'String'>
    readonly isActive: FieldRef<"PracticeClone", 'Boolean'>
    readonly uploadDate: FieldRef<"PracticeClone", 'DateTime'>
    readonly createdAt: FieldRef<"PracticeClone", 'DateTime'>
    readonly updatedAt: FieldRef<"PracticeClone", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PracticeClone findUnique
   */
  export type PracticeCloneFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PracticeClone
     */
    select?: PracticeCloneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PracticeClone
     */
    omit?: PracticeCloneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PracticeCloneInclude<ExtArgs> | null
    /**
     * Filter, which PracticeClone to fetch.
     */
    where: PracticeCloneWhereUniqueInput
  }

  /**
   * PracticeClone findUniqueOrThrow
   */
  export type PracticeCloneFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PracticeClone
     */
    select?: PracticeCloneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PracticeClone
     */
    omit?: PracticeCloneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PracticeCloneInclude<ExtArgs> | null
    /**
     * Filter, which PracticeClone to fetch.
     */
    where: PracticeCloneWhereUniqueInput
  }

  /**
   * PracticeClone findFirst
   */
  export type PracticeCloneFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PracticeClone
     */
    select?: PracticeCloneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PracticeClone
     */
    omit?: PracticeCloneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PracticeCloneInclude<ExtArgs> | null
    /**
     * Filter, which PracticeClone to fetch.
     */
    where?: PracticeCloneWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PracticeClones to fetch.
     */
    orderBy?: PracticeCloneOrderByWithRelationInput | PracticeCloneOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PracticeClones.
     */
    cursor?: PracticeCloneWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PracticeClones from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PracticeClones.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PracticeClones.
     */
    distinct?: PracticeCloneScalarFieldEnum | PracticeCloneScalarFieldEnum[]
  }

  /**
   * PracticeClone findFirstOrThrow
   */
  export type PracticeCloneFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PracticeClone
     */
    select?: PracticeCloneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PracticeClone
     */
    omit?: PracticeCloneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PracticeCloneInclude<ExtArgs> | null
    /**
     * Filter, which PracticeClone to fetch.
     */
    where?: PracticeCloneWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PracticeClones to fetch.
     */
    orderBy?: PracticeCloneOrderByWithRelationInput | PracticeCloneOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PracticeClones.
     */
    cursor?: PracticeCloneWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PracticeClones from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PracticeClones.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PracticeClones.
     */
    distinct?: PracticeCloneScalarFieldEnum | PracticeCloneScalarFieldEnum[]
  }

  /**
   * PracticeClone findMany
   */
  export type PracticeCloneFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PracticeClone
     */
    select?: PracticeCloneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PracticeClone
     */
    omit?: PracticeCloneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PracticeCloneInclude<ExtArgs> | null
    /**
     * Filter, which PracticeClones to fetch.
     */
    where?: PracticeCloneWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PracticeClones to fetch.
     */
    orderBy?: PracticeCloneOrderByWithRelationInput | PracticeCloneOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PracticeClones.
     */
    cursor?: PracticeCloneWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PracticeClones from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PracticeClones.
     */
    skip?: number
    distinct?: PracticeCloneScalarFieldEnum | PracticeCloneScalarFieldEnum[]
  }

  /**
   * PracticeClone create
   */
  export type PracticeCloneCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PracticeClone
     */
    select?: PracticeCloneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PracticeClone
     */
    omit?: PracticeCloneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PracticeCloneInclude<ExtArgs> | null
    /**
     * The data needed to create a PracticeClone.
     */
    data: XOR<PracticeCloneCreateInput, PracticeCloneUncheckedCreateInput>
  }

  /**
   * PracticeClone createMany
   */
  export type PracticeCloneCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PracticeClones.
     */
    data: PracticeCloneCreateManyInput | PracticeCloneCreateManyInput[]
  }

  /**
   * PracticeClone createManyAndReturn
   */
  export type PracticeCloneCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PracticeClone
     */
    select?: PracticeCloneSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PracticeClone
     */
    omit?: PracticeCloneOmit<ExtArgs> | null
    /**
     * The data used to create many PracticeClones.
     */
    data: PracticeCloneCreateManyInput | PracticeCloneCreateManyInput[]
  }

  /**
   * PracticeClone update
   */
  export type PracticeCloneUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PracticeClone
     */
    select?: PracticeCloneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PracticeClone
     */
    omit?: PracticeCloneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PracticeCloneInclude<ExtArgs> | null
    /**
     * The data needed to update a PracticeClone.
     */
    data: XOR<PracticeCloneUpdateInput, PracticeCloneUncheckedUpdateInput>
    /**
     * Choose, which PracticeClone to update.
     */
    where: PracticeCloneWhereUniqueInput
  }

  /**
   * PracticeClone updateMany
   */
  export type PracticeCloneUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PracticeClones.
     */
    data: XOR<PracticeCloneUpdateManyMutationInput, PracticeCloneUncheckedUpdateManyInput>
    /**
     * Filter which PracticeClones to update
     */
    where?: PracticeCloneWhereInput
    /**
     * Limit how many PracticeClones to update.
     */
    limit?: number
  }

  /**
   * PracticeClone updateManyAndReturn
   */
  export type PracticeCloneUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PracticeClone
     */
    select?: PracticeCloneSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PracticeClone
     */
    omit?: PracticeCloneOmit<ExtArgs> | null
    /**
     * The data used to update PracticeClones.
     */
    data: XOR<PracticeCloneUpdateManyMutationInput, PracticeCloneUncheckedUpdateManyInput>
    /**
     * Filter which PracticeClones to update
     */
    where?: PracticeCloneWhereInput
    /**
     * Limit how many PracticeClones to update.
     */
    limit?: number
  }

  /**
   * PracticeClone upsert
   */
  export type PracticeCloneUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PracticeClone
     */
    select?: PracticeCloneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PracticeClone
     */
    omit?: PracticeCloneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PracticeCloneInclude<ExtArgs> | null
    /**
     * The filter to search for the PracticeClone to update in case it exists.
     */
    where: PracticeCloneWhereUniqueInput
    /**
     * In case the PracticeClone found by the `where` argument doesn't exist, create a new PracticeClone with this data.
     */
    create: XOR<PracticeCloneCreateInput, PracticeCloneUncheckedCreateInput>
    /**
     * In case the PracticeClone was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PracticeCloneUpdateInput, PracticeCloneUncheckedUpdateInput>
  }

  /**
   * PracticeClone delete
   */
  export type PracticeCloneDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PracticeClone
     */
    select?: PracticeCloneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PracticeClone
     */
    omit?: PracticeCloneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PracticeCloneInclude<ExtArgs> | null
    /**
     * Filter which PracticeClone to delete.
     */
    where: PracticeCloneWhereUniqueInput
  }

  /**
   * PracticeClone deleteMany
   */
  export type PracticeCloneDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PracticeClones to delete
     */
    where?: PracticeCloneWhereInput
    /**
     * Limit how many PracticeClones to delete.
     */
    limit?: number
  }

  /**
   * PracticeClone.practiceAnswers
   */
  export type PracticeClone$practiceAnswersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PracticeAnswer
     */
    select?: PracticeAnswerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PracticeAnswer
     */
    omit?: PracticeAnswerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PracticeAnswerInclude<ExtArgs> | null
    where?: PracticeAnswerWhereInput
    orderBy?: PracticeAnswerOrderByWithRelationInput | PracticeAnswerOrderByWithRelationInput[]
    cursor?: PracticeAnswerWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PracticeAnswerScalarFieldEnum | PracticeAnswerScalarFieldEnum[]
  }

  /**
   * PracticeClone.userProgress
   */
  export type PracticeClone$userProgressArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPracticeProgress
     */
    select?: UserPracticeProgressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPracticeProgress
     */
    omit?: UserPracticeProgressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPracticeProgressInclude<ExtArgs> | null
    where?: UserPracticeProgressWhereInput
    orderBy?: UserPracticeProgressOrderByWithRelationInput | UserPracticeProgressOrderByWithRelationInput[]
    cursor?: UserPracticeProgressWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserPracticeProgressScalarFieldEnum | UserPracticeProgressScalarFieldEnum[]
  }

  /**
   * PracticeClone.cloneDiscussions
   */
  export type PracticeClone$cloneDiscussionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CloneDiscussion
     */
    select?: CloneDiscussionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CloneDiscussion
     */
    omit?: CloneDiscussionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CloneDiscussionInclude<ExtArgs> | null
    where?: CloneDiscussionWhereInput
    orderBy?: CloneDiscussionOrderByWithRelationInput | CloneDiscussionOrderByWithRelationInput[]
    cursor?: CloneDiscussionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CloneDiscussionScalarFieldEnum | CloneDiscussionScalarFieldEnum[]
  }

  /**
   * PracticeClone without action
   */
  export type PracticeCloneDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PracticeClone
     */
    select?: PracticeCloneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PracticeClone
     */
    omit?: PracticeCloneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PracticeCloneInclude<ExtArgs> | null
  }


  /**
   * Model PracticeAnswer
   */

  export type AggregatePracticeAnswer = {
    _count: PracticeAnswerCountAggregateOutputType | null
    _avg: PracticeAnswerAvgAggregateOutputType | null
    _sum: PracticeAnswerSumAggregateOutputType | null
    _min: PracticeAnswerMinAggregateOutputType | null
    _max: PracticeAnswerMaxAggregateOutputType | null
  }

  export type PracticeAnswerAvgAggregateOutputType = {
    practiceCloneId: number | null
  }

  export type PracticeAnswerSumAggregateOutputType = {
    practiceCloneId: number | null
  }

  export type PracticeAnswerMinAggregateOutputType = {
    id: string | null
    practiceCloneId: number | null
    questionId: string | null
    correctAnswer: string | null
    explanation: string | null
  }

  export type PracticeAnswerMaxAggregateOutputType = {
    id: string | null
    practiceCloneId: number | null
    questionId: string | null
    correctAnswer: string | null
    explanation: string | null
  }

  export type PracticeAnswerCountAggregateOutputType = {
    id: number
    practiceCloneId: number
    questionId: number
    correctAnswer: number
    explanation: number
    _all: number
  }


  export type PracticeAnswerAvgAggregateInputType = {
    practiceCloneId?: true
  }

  export type PracticeAnswerSumAggregateInputType = {
    practiceCloneId?: true
  }

  export type PracticeAnswerMinAggregateInputType = {
    id?: true
    practiceCloneId?: true
    questionId?: true
    correctAnswer?: true
    explanation?: true
  }

  export type PracticeAnswerMaxAggregateInputType = {
    id?: true
    practiceCloneId?: true
    questionId?: true
    correctAnswer?: true
    explanation?: true
  }

  export type PracticeAnswerCountAggregateInputType = {
    id?: true
    practiceCloneId?: true
    questionId?: true
    correctAnswer?: true
    explanation?: true
    _all?: true
  }

  export type PracticeAnswerAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PracticeAnswer to aggregate.
     */
    where?: PracticeAnswerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PracticeAnswers to fetch.
     */
    orderBy?: PracticeAnswerOrderByWithRelationInput | PracticeAnswerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PracticeAnswerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PracticeAnswers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PracticeAnswers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PracticeAnswers
    **/
    _count?: true | PracticeAnswerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PracticeAnswerAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PracticeAnswerSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PracticeAnswerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PracticeAnswerMaxAggregateInputType
  }

  export type GetPracticeAnswerAggregateType<T extends PracticeAnswerAggregateArgs> = {
        [P in keyof T & keyof AggregatePracticeAnswer]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePracticeAnswer[P]>
      : GetScalarType<T[P], AggregatePracticeAnswer[P]>
  }




  export type PracticeAnswerGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PracticeAnswerWhereInput
    orderBy?: PracticeAnswerOrderByWithAggregationInput | PracticeAnswerOrderByWithAggregationInput[]
    by: PracticeAnswerScalarFieldEnum[] | PracticeAnswerScalarFieldEnum
    having?: PracticeAnswerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PracticeAnswerCountAggregateInputType | true
    _avg?: PracticeAnswerAvgAggregateInputType
    _sum?: PracticeAnswerSumAggregateInputType
    _min?: PracticeAnswerMinAggregateInputType
    _max?: PracticeAnswerMaxAggregateInputType
  }

  export type PracticeAnswerGroupByOutputType = {
    id: string
    practiceCloneId: number
    questionId: string
    correctAnswer: string
    explanation: string | null
    _count: PracticeAnswerCountAggregateOutputType | null
    _avg: PracticeAnswerAvgAggregateOutputType | null
    _sum: PracticeAnswerSumAggregateOutputType | null
    _min: PracticeAnswerMinAggregateOutputType | null
    _max: PracticeAnswerMaxAggregateOutputType | null
  }

  type GetPracticeAnswerGroupByPayload<T extends PracticeAnswerGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PracticeAnswerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PracticeAnswerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PracticeAnswerGroupByOutputType[P]>
            : GetScalarType<T[P], PracticeAnswerGroupByOutputType[P]>
        }
      >
    >


  export type PracticeAnswerSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    practiceCloneId?: boolean
    questionId?: boolean
    correctAnswer?: boolean
    explanation?: boolean
    practiceClone?: boolean | PracticeCloneDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["practiceAnswer"]>

  export type PracticeAnswerSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    practiceCloneId?: boolean
    questionId?: boolean
    correctAnswer?: boolean
    explanation?: boolean
    practiceClone?: boolean | PracticeCloneDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["practiceAnswer"]>

  export type PracticeAnswerSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    practiceCloneId?: boolean
    questionId?: boolean
    correctAnswer?: boolean
    explanation?: boolean
    practiceClone?: boolean | PracticeCloneDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["practiceAnswer"]>

  export type PracticeAnswerSelectScalar = {
    id?: boolean
    practiceCloneId?: boolean
    questionId?: boolean
    correctAnswer?: boolean
    explanation?: boolean
  }

  export type PracticeAnswerOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "practiceCloneId" | "questionId" | "correctAnswer" | "explanation", ExtArgs["result"]["practiceAnswer"]>
  export type PracticeAnswerInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    practiceClone?: boolean | PracticeCloneDefaultArgs<ExtArgs>
  }
  export type PracticeAnswerIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    practiceClone?: boolean | PracticeCloneDefaultArgs<ExtArgs>
  }
  export type PracticeAnswerIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    practiceClone?: boolean | PracticeCloneDefaultArgs<ExtArgs>
  }

  export type $PracticeAnswerPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PracticeAnswer"
    objects: {
      practiceClone: Prisma.$PracticeClonePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      practiceCloneId: number
      questionId: string
      correctAnswer: string
      explanation: string | null
    }, ExtArgs["result"]["practiceAnswer"]>
    composites: {}
  }

  type PracticeAnswerGetPayload<S extends boolean | null | undefined | PracticeAnswerDefaultArgs> = $Result.GetResult<Prisma.$PracticeAnswerPayload, S>

  type PracticeAnswerCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PracticeAnswerFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PracticeAnswerCountAggregateInputType | true
    }

  export interface PracticeAnswerDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PracticeAnswer'], meta: { name: 'PracticeAnswer' } }
    /**
     * Find zero or one PracticeAnswer that matches the filter.
     * @param {PracticeAnswerFindUniqueArgs} args - Arguments to find a PracticeAnswer
     * @example
     * // Get one PracticeAnswer
     * const practiceAnswer = await prisma.practiceAnswer.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PracticeAnswerFindUniqueArgs>(args: SelectSubset<T, PracticeAnswerFindUniqueArgs<ExtArgs>>): Prisma__PracticeAnswerClient<$Result.GetResult<Prisma.$PracticeAnswerPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PracticeAnswer that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PracticeAnswerFindUniqueOrThrowArgs} args - Arguments to find a PracticeAnswer
     * @example
     * // Get one PracticeAnswer
     * const practiceAnswer = await prisma.practiceAnswer.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PracticeAnswerFindUniqueOrThrowArgs>(args: SelectSubset<T, PracticeAnswerFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PracticeAnswerClient<$Result.GetResult<Prisma.$PracticeAnswerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PracticeAnswer that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PracticeAnswerFindFirstArgs} args - Arguments to find a PracticeAnswer
     * @example
     * // Get one PracticeAnswer
     * const practiceAnswer = await prisma.practiceAnswer.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PracticeAnswerFindFirstArgs>(args?: SelectSubset<T, PracticeAnswerFindFirstArgs<ExtArgs>>): Prisma__PracticeAnswerClient<$Result.GetResult<Prisma.$PracticeAnswerPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PracticeAnswer that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PracticeAnswerFindFirstOrThrowArgs} args - Arguments to find a PracticeAnswer
     * @example
     * // Get one PracticeAnswer
     * const practiceAnswer = await prisma.practiceAnswer.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PracticeAnswerFindFirstOrThrowArgs>(args?: SelectSubset<T, PracticeAnswerFindFirstOrThrowArgs<ExtArgs>>): Prisma__PracticeAnswerClient<$Result.GetResult<Prisma.$PracticeAnswerPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PracticeAnswers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PracticeAnswerFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PracticeAnswers
     * const practiceAnswers = await prisma.practiceAnswer.findMany()
     * 
     * // Get first 10 PracticeAnswers
     * const practiceAnswers = await prisma.practiceAnswer.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const practiceAnswerWithIdOnly = await prisma.practiceAnswer.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PracticeAnswerFindManyArgs>(args?: SelectSubset<T, PracticeAnswerFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PracticeAnswerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PracticeAnswer.
     * @param {PracticeAnswerCreateArgs} args - Arguments to create a PracticeAnswer.
     * @example
     * // Create one PracticeAnswer
     * const PracticeAnswer = await prisma.practiceAnswer.create({
     *   data: {
     *     // ... data to create a PracticeAnswer
     *   }
     * })
     * 
     */
    create<T extends PracticeAnswerCreateArgs>(args: SelectSubset<T, PracticeAnswerCreateArgs<ExtArgs>>): Prisma__PracticeAnswerClient<$Result.GetResult<Prisma.$PracticeAnswerPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PracticeAnswers.
     * @param {PracticeAnswerCreateManyArgs} args - Arguments to create many PracticeAnswers.
     * @example
     * // Create many PracticeAnswers
     * const practiceAnswer = await prisma.practiceAnswer.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PracticeAnswerCreateManyArgs>(args?: SelectSubset<T, PracticeAnswerCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PracticeAnswers and returns the data saved in the database.
     * @param {PracticeAnswerCreateManyAndReturnArgs} args - Arguments to create many PracticeAnswers.
     * @example
     * // Create many PracticeAnswers
     * const practiceAnswer = await prisma.practiceAnswer.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PracticeAnswers and only return the `id`
     * const practiceAnswerWithIdOnly = await prisma.practiceAnswer.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PracticeAnswerCreateManyAndReturnArgs>(args?: SelectSubset<T, PracticeAnswerCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PracticeAnswerPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PracticeAnswer.
     * @param {PracticeAnswerDeleteArgs} args - Arguments to delete one PracticeAnswer.
     * @example
     * // Delete one PracticeAnswer
     * const PracticeAnswer = await prisma.practiceAnswer.delete({
     *   where: {
     *     // ... filter to delete one PracticeAnswer
     *   }
     * })
     * 
     */
    delete<T extends PracticeAnswerDeleteArgs>(args: SelectSubset<T, PracticeAnswerDeleteArgs<ExtArgs>>): Prisma__PracticeAnswerClient<$Result.GetResult<Prisma.$PracticeAnswerPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PracticeAnswer.
     * @param {PracticeAnswerUpdateArgs} args - Arguments to update one PracticeAnswer.
     * @example
     * // Update one PracticeAnswer
     * const practiceAnswer = await prisma.practiceAnswer.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PracticeAnswerUpdateArgs>(args: SelectSubset<T, PracticeAnswerUpdateArgs<ExtArgs>>): Prisma__PracticeAnswerClient<$Result.GetResult<Prisma.$PracticeAnswerPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PracticeAnswers.
     * @param {PracticeAnswerDeleteManyArgs} args - Arguments to filter PracticeAnswers to delete.
     * @example
     * // Delete a few PracticeAnswers
     * const { count } = await prisma.practiceAnswer.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PracticeAnswerDeleteManyArgs>(args?: SelectSubset<T, PracticeAnswerDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PracticeAnswers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PracticeAnswerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PracticeAnswers
     * const practiceAnswer = await prisma.practiceAnswer.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PracticeAnswerUpdateManyArgs>(args: SelectSubset<T, PracticeAnswerUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PracticeAnswers and returns the data updated in the database.
     * @param {PracticeAnswerUpdateManyAndReturnArgs} args - Arguments to update many PracticeAnswers.
     * @example
     * // Update many PracticeAnswers
     * const practiceAnswer = await prisma.practiceAnswer.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PracticeAnswers and only return the `id`
     * const practiceAnswerWithIdOnly = await prisma.practiceAnswer.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PracticeAnswerUpdateManyAndReturnArgs>(args: SelectSubset<T, PracticeAnswerUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PracticeAnswerPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PracticeAnswer.
     * @param {PracticeAnswerUpsertArgs} args - Arguments to update or create a PracticeAnswer.
     * @example
     * // Update or create a PracticeAnswer
     * const practiceAnswer = await prisma.practiceAnswer.upsert({
     *   create: {
     *     // ... data to create a PracticeAnswer
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PracticeAnswer we want to update
     *   }
     * })
     */
    upsert<T extends PracticeAnswerUpsertArgs>(args: SelectSubset<T, PracticeAnswerUpsertArgs<ExtArgs>>): Prisma__PracticeAnswerClient<$Result.GetResult<Prisma.$PracticeAnswerPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PracticeAnswers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PracticeAnswerCountArgs} args - Arguments to filter PracticeAnswers to count.
     * @example
     * // Count the number of PracticeAnswers
     * const count = await prisma.practiceAnswer.count({
     *   where: {
     *     // ... the filter for the PracticeAnswers we want to count
     *   }
     * })
    **/
    count<T extends PracticeAnswerCountArgs>(
      args?: Subset<T, PracticeAnswerCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PracticeAnswerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PracticeAnswer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PracticeAnswerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PracticeAnswerAggregateArgs>(args: Subset<T, PracticeAnswerAggregateArgs>): Prisma.PrismaPromise<GetPracticeAnswerAggregateType<T>>

    /**
     * Group by PracticeAnswer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PracticeAnswerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PracticeAnswerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PracticeAnswerGroupByArgs['orderBy'] }
        : { orderBy?: PracticeAnswerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PracticeAnswerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPracticeAnswerGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PracticeAnswer model
   */
  readonly fields: PracticeAnswerFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PracticeAnswer.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PracticeAnswerClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    practiceClone<T extends PracticeCloneDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PracticeCloneDefaultArgs<ExtArgs>>): Prisma__PracticeCloneClient<$Result.GetResult<Prisma.$PracticeClonePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PracticeAnswer model
   */
  interface PracticeAnswerFieldRefs {
    readonly id: FieldRef<"PracticeAnswer", 'String'>
    readonly practiceCloneId: FieldRef<"PracticeAnswer", 'Int'>
    readonly questionId: FieldRef<"PracticeAnswer", 'String'>
    readonly correctAnswer: FieldRef<"PracticeAnswer", 'String'>
    readonly explanation: FieldRef<"PracticeAnswer", 'String'>
  }
    

  // Custom InputTypes
  /**
   * PracticeAnswer findUnique
   */
  export type PracticeAnswerFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PracticeAnswer
     */
    select?: PracticeAnswerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PracticeAnswer
     */
    omit?: PracticeAnswerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PracticeAnswerInclude<ExtArgs> | null
    /**
     * Filter, which PracticeAnswer to fetch.
     */
    where: PracticeAnswerWhereUniqueInput
  }

  /**
   * PracticeAnswer findUniqueOrThrow
   */
  export type PracticeAnswerFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PracticeAnswer
     */
    select?: PracticeAnswerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PracticeAnswer
     */
    omit?: PracticeAnswerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PracticeAnswerInclude<ExtArgs> | null
    /**
     * Filter, which PracticeAnswer to fetch.
     */
    where: PracticeAnswerWhereUniqueInput
  }

  /**
   * PracticeAnswer findFirst
   */
  export type PracticeAnswerFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PracticeAnswer
     */
    select?: PracticeAnswerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PracticeAnswer
     */
    omit?: PracticeAnswerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PracticeAnswerInclude<ExtArgs> | null
    /**
     * Filter, which PracticeAnswer to fetch.
     */
    where?: PracticeAnswerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PracticeAnswers to fetch.
     */
    orderBy?: PracticeAnswerOrderByWithRelationInput | PracticeAnswerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PracticeAnswers.
     */
    cursor?: PracticeAnswerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PracticeAnswers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PracticeAnswers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PracticeAnswers.
     */
    distinct?: PracticeAnswerScalarFieldEnum | PracticeAnswerScalarFieldEnum[]
  }

  /**
   * PracticeAnswer findFirstOrThrow
   */
  export type PracticeAnswerFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PracticeAnswer
     */
    select?: PracticeAnswerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PracticeAnswer
     */
    omit?: PracticeAnswerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PracticeAnswerInclude<ExtArgs> | null
    /**
     * Filter, which PracticeAnswer to fetch.
     */
    where?: PracticeAnswerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PracticeAnswers to fetch.
     */
    orderBy?: PracticeAnswerOrderByWithRelationInput | PracticeAnswerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PracticeAnswers.
     */
    cursor?: PracticeAnswerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PracticeAnswers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PracticeAnswers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PracticeAnswers.
     */
    distinct?: PracticeAnswerScalarFieldEnum | PracticeAnswerScalarFieldEnum[]
  }

  /**
   * PracticeAnswer findMany
   */
  export type PracticeAnswerFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PracticeAnswer
     */
    select?: PracticeAnswerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PracticeAnswer
     */
    omit?: PracticeAnswerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PracticeAnswerInclude<ExtArgs> | null
    /**
     * Filter, which PracticeAnswers to fetch.
     */
    where?: PracticeAnswerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PracticeAnswers to fetch.
     */
    orderBy?: PracticeAnswerOrderByWithRelationInput | PracticeAnswerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PracticeAnswers.
     */
    cursor?: PracticeAnswerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PracticeAnswers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PracticeAnswers.
     */
    skip?: number
    distinct?: PracticeAnswerScalarFieldEnum | PracticeAnswerScalarFieldEnum[]
  }

  /**
   * PracticeAnswer create
   */
  export type PracticeAnswerCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PracticeAnswer
     */
    select?: PracticeAnswerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PracticeAnswer
     */
    omit?: PracticeAnswerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PracticeAnswerInclude<ExtArgs> | null
    /**
     * The data needed to create a PracticeAnswer.
     */
    data: XOR<PracticeAnswerCreateInput, PracticeAnswerUncheckedCreateInput>
  }

  /**
   * PracticeAnswer createMany
   */
  export type PracticeAnswerCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PracticeAnswers.
     */
    data: PracticeAnswerCreateManyInput | PracticeAnswerCreateManyInput[]
  }

  /**
   * PracticeAnswer createManyAndReturn
   */
  export type PracticeAnswerCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PracticeAnswer
     */
    select?: PracticeAnswerSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PracticeAnswer
     */
    omit?: PracticeAnswerOmit<ExtArgs> | null
    /**
     * The data used to create many PracticeAnswers.
     */
    data: PracticeAnswerCreateManyInput | PracticeAnswerCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PracticeAnswerIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PracticeAnswer update
   */
  export type PracticeAnswerUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PracticeAnswer
     */
    select?: PracticeAnswerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PracticeAnswer
     */
    omit?: PracticeAnswerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PracticeAnswerInclude<ExtArgs> | null
    /**
     * The data needed to update a PracticeAnswer.
     */
    data: XOR<PracticeAnswerUpdateInput, PracticeAnswerUncheckedUpdateInput>
    /**
     * Choose, which PracticeAnswer to update.
     */
    where: PracticeAnswerWhereUniqueInput
  }

  /**
   * PracticeAnswer updateMany
   */
  export type PracticeAnswerUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PracticeAnswers.
     */
    data: XOR<PracticeAnswerUpdateManyMutationInput, PracticeAnswerUncheckedUpdateManyInput>
    /**
     * Filter which PracticeAnswers to update
     */
    where?: PracticeAnswerWhereInput
    /**
     * Limit how many PracticeAnswers to update.
     */
    limit?: number
  }

  /**
   * PracticeAnswer updateManyAndReturn
   */
  export type PracticeAnswerUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PracticeAnswer
     */
    select?: PracticeAnswerSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PracticeAnswer
     */
    omit?: PracticeAnswerOmit<ExtArgs> | null
    /**
     * The data used to update PracticeAnswers.
     */
    data: XOR<PracticeAnswerUpdateManyMutationInput, PracticeAnswerUncheckedUpdateManyInput>
    /**
     * Filter which PracticeAnswers to update
     */
    where?: PracticeAnswerWhereInput
    /**
     * Limit how many PracticeAnswers to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PracticeAnswerIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PracticeAnswer upsert
   */
  export type PracticeAnswerUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PracticeAnswer
     */
    select?: PracticeAnswerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PracticeAnswer
     */
    omit?: PracticeAnswerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PracticeAnswerInclude<ExtArgs> | null
    /**
     * The filter to search for the PracticeAnswer to update in case it exists.
     */
    where: PracticeAnswerWhereUniqueInput
    /**
     * In case the PracticeAnswer found by the `where` argument doesn't exist, create a new PracticeAnswer with this data.
     */
    create: XOR<PracticeAnswerCreateInput, PracticeAnswerUncheckedCreateInput>
    /**
     * In case the PracticeAnswer was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PracticeAnswerUpdateInput, PracticeAnswerUncheckedUpdateInput>
  }

  /**
   * PracticeAnswer delete
   */
  export type PracticeAnswerDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PracticeAnswer
     */
    select?: PracticeAnswerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PracticeAnswer
     */
    omit?: PracticeAnswerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PracticeAnswerInclude<ExtArgs> | null
    /**
     * Filter which PracticeAnswer to delete.
     */
    where: PracticeAnswerWhereUniqueInput
  }

  /**
   * PracticeAnswer deleteMany
   */
  export type PracticeAnswerDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PracticeAnswers to delete
     */
    where?: PracticeAnswerWhereInput
    /**
     * Limit how many PracticeAnswers to delete.
     */
    limit?: number
  }

  /**
   * PracticeAnswer without action
   */
  export type PracticeAnswerDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PracticeAnswer
     */
    select?: PracticeAnswerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PracticeAnswer
     */
    omit?: PracticeAnswerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PracticeAnswerInclude<ExtArgs> | null
  }


  /**
   * Model UserPracticeProgress
   */

  export type AggregateUserPracticeProgress = {
    _count: UserPracticeProgressCountAggregateOutputType | null
    _avg: UserPracticeProgressAvgAggregateOutputType | null
    _sum: UserPracticeProgressSumAggregateOutputType | null
    _min: UserPracticeProgressMinAggregateOutputType | null
    _max: UserPracticeProgressMaxAggregateOutputType | null
  }

  export type UserPracticeProgressAvgAggregateOutputType = {
    id: number | null
    userId: number | null
    practiceCloneId: number | null
    progress: number | null
    reviewScore: number | null
  }

  export type UserPracticeProgressSumAggregateOutputType = {
    id: number | null
    userId: number | null
    practiceCloneId: number | null
    progress: number | null
    reviewScore: number | null
  }

  export type UserPracticeProgressMinAggregateOutputType = {
    id: number | null
    userId: number | null
    practiceCloneId: number | null
    progress: number | null
    answers: string | null
    currentStep: string | null
    status: string | null
    lastSaved: Date | null
    submittedAt: Date | null
    reviewComments: string | null
    reviewScore: number | null
    lastReviewed: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserPracticeProgressMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    practiceCloneId: number | null
    progress: number | null
    answers: string | null
    currentStep: string | null
    status: string | null
    lastSaved: Date | null
    submittedAt: Date | null
    reviewComments: string | null
    reviewScore: number | null
    lastReviewed: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserPracticeProgressCountAggregateOutputType = {
    id: number
    userId: number
    practiceCloneId: number
    progress: number
    answers: number
    currentStep: number
    status: number
    lastSaved: number
    submittedAt: number
    reviewComments: number
    reviewScore: number
    lastReviewed: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserPracticeProgressAvgAggregateInputType = {
    id?: true
    userId?: true
    practiceCloneId?: true
    progress?: true
    reviewScore?: true
  }

  export type UserPracticeProgressSumAggregateInputType = {
    id?: true
    userId?: true
    practiceCloneId?: true
    progress?: true
    reviewScore?: true
  }

  export type UserPracticeProgressMinAggregateInputType = {
    id?: true
    userId?: true
    practiceCloneId?: true
    progress?: true
    answers?: true
    currentStep?: true
    status?: true
    lastSaved?: true
    submittedAt?: true
    reviewComments?: true
    reviewScore?: true
    lastReviewed?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserPracticeProgressMaxAggregateInputType = {
    id?: true
    userId?: true
    practiceCloneId?: true
    progress?: true
    answers?: true
    currentStep?: true
    status?: true
    lastSaved?: true
    submittedAt?: true
    reviewComments?: true
    reviewScore?: true
    lastReviewed?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserPracticeProgressCountAggregateInputType = {
    id?: true
    userId?: true
    practiceCloneId?: true
    progress?: true
    answers?: true
    currentStep?: true
    status?: true
    lastSaved?: true
    submittedAt?: true
    reviewComments?: true
    reviewScore?: true
    lastReviewed?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserPracticeProgressAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserPracticeProgress to aggregate.
     */
    where?: UserPracticeProgressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserPracticeProgresses to fetch.
     */
    orderBy?: UserPracticeProgressOrderByWithRelationInput | UserPracticeProgressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserPracticeProgressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserPracticeProgresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserPracticeProgresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserPracticeProgresses
    **/
    _count?: true | UserPracticeProgressCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserPracticeProgressAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserPracticeProgressSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserPracticeProgressMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserPracticeProgressMaxAggregateInputType
  }

  export type GetUserPracticeProgressAggregateType<T extends UserPracticeProgressAggregateArgs> = {
        [P in keyof T & keyof AggregateUserPracticeProgress]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserPracticeProgress[P]>
      : GetScalarType<T[P], AggregateUserPracticeProgress[P]>
  }




  export type UserPracticeProgressGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserPracticeProgressWhereInput
    orderBy?: UserPracticeProgressOrderByWithAggregationInput | UserPracticeProgressOrderByWithAggregationInput[]
    by: UserPracticeProgressScalarFieldEnum[] | UserPracticeProgressScalarFieldEnum
    having?: UserPracticeProgressScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserPracticeProgressCountAggregateInputType | true
    _avg?: UserPracticeProgressAvgAggregateInputType
    _sum?: UserPracticeProgressSumAggregateInputType
    _min?: UserPracticeProgressMinAggregateInputType
    _max?: UserPracticeProgressMaxAggregateInputType
  }

  export type UserPracticeProgressGroupByOutputType = {
    id: number
    userId: number
    practiceCloneId: number
    progress: number
    answers: string | null
    currentStep: string
    status: string
    lastSaved: Date | null
    submittedAt: Date | null
    reviewComments: string | null
    reviewScore: number | null
    lastReviewed: Date | null
    createdAt: Date
    updatedAt: Date
    _count: UserPracticeProgressCountAggregateOutputType | null
    _avg: UserPracticeProgressAvgAggregateOutputType | null
    _sum: UserPracticeProgressSumAggregateOutputType | null
    _min: UserPracticeProgressMinAggregateOutputType | null
    _max: UserPracticeProgressMaxAggregateOutputType | null
  }

  type GetUserPracticeProgressGroupByPayload<T extends UserPracticeProgressGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserPracticeProgressGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserPracticeProgressGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserPracticeProgressGroupByOutputType[P]>
            : GetScalarType<T[P], UserPracticeProgressGroupByOutputType[P]>
        }
      >
    >


  export type UserPracticeProgressSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    practiceCloneId?: boolean
    progress?: boolean
    answers?: boolean
    currentStep?: boolean
    status?: boolean
    lastSaved?: boolean
    submittedAt?: boolean
    reviewComments?: boolean
    reviewScore?: boolean
    lastReviewed?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    practiceClone?: boolean | PracticeCloneDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userPracticeProgress"]>

  export type UserPracticeProgressSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    practiceCloneId?: boolean
    progress?: boolean
    answers?: boolean
    currentStep?: boolean
    status?: boolean
    lastSaved?: boolean
    submittedAt?: boolean
    reviewComments?: boolean
    reviewScore?: boolean
    lastReviewed?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    practiceClone?: boolean | PracticeCloneDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userPracticeProgress"]>

  export type UserPracticeProgressSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    practiceCloneId?: boolean
    progress?: boolean
    answers?: boolean
    currentStep?: boolean
    status?: boolean
    lastSaved?: boolean
    submittedAt?: boolean
    reviewComments?: boolean
    reviewScore?: boolean
    lastReviewed?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    practiceClone?: boolean | PracticeCloneDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userPracticeProgress"]>

  export type UserPracticeProgressSelectScalar = {
    id?: boolean
    userId?: boolean
    practiceCloneId?: boolean
    progress?: boolean
    answers?: boolean
    currentStep?: boolean
    status?: boolean
    lastSaved?: boolean
    submittedAt?: boolean
    reviewComments?: boolean
    reviewScore?: boolean
    lastReviewed?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserPracticeProgressOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "practiceCloneId" | "progress" | "answers" | "currentStep" | "status" | "lastSaved" | "submittedAt" | "reviewComments" | "reviewScore" | "lastReviewed" | "createdAt" | "updatedAt", ExtArgs["result"]["userPracticeProgress"]>
  export type UserPracticeProgressInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    practiceClone?: boolean | PracticeCloneDefaultArgs<ExtArgs>
  }
  export type UserPracticeProgressIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    practiceClone?: boolean | PracticeCloneDefaultArgs<ExtArgs>
  }
  export type UserPracticeProgressIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    practiceClone?: boolean | PracticeCloneDefaultArgs<ExtArgs>
  }

  export type $UserPracticeProgressPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserPracticeProgress"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      practiceClone: Prisma.$PracticeClonePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userId: number
      practiceCloneId: number
      progress: number
      answers: string | null
      currentStep: string
      status: string
      lastSaved: Date | null
      submittedAt: Date | null
      reviewComments: string | null
      reviewScore: number | null
      lastReviewed: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["userPracticeProgress"]>
    composites: {}
  }

  type UserPracticeProgressGetPayload<S extends boolean | null | undefined | UserPracticeProgressDefaultArgs> = $Result.GetResult<Prisma.$UserPracticeProgressPayload, S>

  type UserPracticeProgressCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserPracticeProgressFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserPracticeProgressCountAggregateInputType | true
    }

  export interface UserPracticeProgressDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserPracticeProgress'], meta: { name: 'UserPracticeProgress' } }
    /**
     * Find zero or one UserPracticeProgress that matches the filter.
     * @param {UserPracticeProgressFindUniqueArgs} args - Arguments to find a UserPracticeProgress
     * @example
     * // Get one UserPracticeProgress
     * const userPracticeProgress = await prisma.userPracticeProgress.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserPracticeProgressFindUniqueArgs>(args: SelectSubset<T, UserPracticeProgressFindUniqueArgs<ExtArgs>>): Prisma__UserPracticeProgressClient<$Result.GetResult<Prisma.$UserPracticeProgressPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UserPracticeProgress that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserPracticeProgressFindUniqueOrThrowArgs} args - Arguments to find a UserPracticeProgress
     * @example
     * // Get one UserPracticeProgress
     * const userPracticeProgress = await prisma.userPracticeProgress.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserPracticeProgressFindUniqueOrThrowArgs>(args: SelectSubset<T, UserPracticeProgressFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserPracticeProgressClient<$Result.GetResult<Prisma.$UserPracticeProgressPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserPracticeProgress that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPracticeProgressFindFirstArgs} args - Arguments to find a UserPracticeProgress
     * @example
     * // Get one UserPracticeProgress
     * const userPracticeProgress = await prisma.userPracticeProgress.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserPracticeProgressFindFirstArgs>(args?: SelectSubset<T, UserPracticeProgressFindFirstArgs<ExtArgs>>): Prisma__UserPracticeProgressClient<$Result.GetResult<Prisma.$UserPracticeProgressPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserPracticeProgress that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPracticeProgressFindFirstOrThrowArgs} args - Arguments to find a UserPracticeProgress
     * @example
     * // Get one UserPracticeProgress
     * const userPracticeProgress = await prisma.userPracticeProgress.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserPracticeProgressFindFirstOrThrowArgs>(args?: SelectSubset<T, UserPracticeProgressFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserPracticeProgressClient<$Result.GetResult<Prisma.$UserPracticeProgressPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UserPracticeProgresses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPracticeProgressFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserPracticeProgresses
     * const userPracticeProgresses = await prisma.userPracticeProgress.findMany()
     * 
     * // Get first 10 UserPracticeProgresses
     * const userPracticeProgresses = await prisma.userPracticeProgress.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userPracticeProgressWithIdOnly = await prisma.userPracticeProgress.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserPracticeProgressFindManyArgs>(args?: SelectSubset<T, UserPracticeProgressFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPracticeProgressPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UserPracticeProgress.
     * @param {UserPracticeProgressCreateArgs} args - Arguments to create a UserPracticeProgress.
     * @example
     * // Create one UserPracticeProgress
     * const UserPracticeProgress = await prisma.userPracticeProgress.create({
     *   data: {
     *     // ... data to create a UserPracticeProgress
     *   }
     * })
     * 
     */
    create<T extends UserPracticeProgressCreateArgs>(args: SelectSubset<T, UserPracticeProgressCreateArgs<ExtArgs>>): Prisma__UserPracticeProgressClient<$Result.GetResult<Prisma.$UserPracticeProgressPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UserPracticeProgresses.
     * @param {UserPracticeProgressCreateManyArgs} args - Arguments to create many UserPracticeProgresses.
     * @example
     * // Create many UserPracticeProgresses
     * const userPracticeProgress = await prisma.userPracticeProgress.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserPracticeProgressCreateManyArgs>(args?: SelectSubset<T, UserPracticeProgressCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserPracticeProgresses and returns the data saved in the database.
     * @param {UserPracticeProgressCreateManyAndReturnArgs} args - Arguments to create many UserPracticeProgresses.
     * @example
     * // Create many UserPracticeProgresses
     * const userPracticeProgress = await prisma.userPracticeProgress.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserPracticeProgresses and only return the `id`
     * const userPracticeProgressWithIdOnly = await prisma.userPracticeProgress.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserPracticeProgressCreateManyAndReturnArgs>(args?: SelectSubset<T, UserPracticeProgressCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPracticeProgressPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a UserPracticeProgress.
     * @param {UserPracticeProgressDeleteArgs} args - Arguments to delete one UserPracticeProgress.
     * @example
     * // Delete one UserPracticeProgress
     * const UserPracticeProgress = await prisma.userPracticeProgress.delete({
     *   where: {
     *     // ... filter to delete one UserPracticeProgress
     *   }
     * })
     * 
     */
    delete<T extends UserPracticeProgressDeleteArgs>(args: SelectSubset<T, UserPracticeProgressDeleteArgs<ExtArgs>>): Prisma__UserPracticeProgressClient<$Result.GetResult<Prisma.$UserPracticeProgressPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UserPracticeProgress.
     * @param {UserPracticeProgressUpdateArgs} args - Arguments to update one UserPracticeProgress.
     * @example
     * // Update one UserPracticeProgress
     * const userPracticeProgress = await prisma.userPracticeProgress.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserPracticeProgressUpdateArgs>(args: SelectSubset<T, UserPracticeProgressUpdateArgs<ExtArgs>>): Prisma__UserPracticeProgressClient<$Result.GetResult<Prisma.$UserPracticeProgressPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UserPracticeProgresses.
     * @param {UserPracticeProgressDeleteManyArgs} args - Arguments to filter UserPracticeProgresses to delete.
     * @example
     * // Delete a few UserPracticeProgresses
     * const { count } = await prisma.userPracticeProgress.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserPracticeProgressDeleteManyArgs>(args?: SelectSubset<T, UserPracticeProgressDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserPracticeProgresses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPracticeProgressUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserPracticeProgresses
     * const userPracticeProgress = await prisma.userPracticeProgress.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserPracticeProgressUpdateManyArgs>(args: SelectSubset<T, UserPracticeProgressUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserPracticeProgresses and returns the data updated in the database.
     * @param {UserPracticeProgressUpdateManyAndReturnArgs} args - Arguments to update many UserPracticeProgresses.
     * @example
     * // Update many UserPracticeProgresses
     * const userPracticeProgress = await prisma.userPracticeProgress.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more UserPracticeProgresses and only return the `id`
     * const userPracticeProgressWithIdOnly = await prisma.userPracticeProgress.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserPracticeProgressUpdateManyAndReturnArgs>(args: SelectSubset<T, UserPracticeProgressUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPracticeProgressPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one UserPracticeProgress.
     * @param {UserPracticeProgressUpsertArgs} args - Arguments to update or create a UserPracticeProgress.
     * @example
     * // Update or create a UserPracticeProgress
     * const userPracticeProgress = await prisma.userPracticeProgress.upsert({
     *   create: {
     *     // ... data to create a UserPracticeProgress
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserPracticeProgress we want to update
     *   }
     * })
     */
    upsert<T extends UserPracticeProgressUpsertArgs>(args: SelectSubset<T, UserPracticeProgressUpsertArgs<ExtArgs>>): Prisma__UserPracticeProgressClient<$Result.GetResult<Prisma.$UserPracticeProgressPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of UserPracticeProgresses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPracticeProgressCountArgs} args - Arguments to filter UserPracticeProgresses to count.
     * @example
     * // Count the number of UserPracticeProgresses
     * const count = await prisma.userPracticeProgress.count({
     *   where: {
     *     // ... the filter for the UserPracticeProgresses we want to count
     *   }
     * })
    **/
    count<T extends UserPracticeProgressCountArgs>(
      args?: Subset<T, UserPracticeProgressCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserPracticeProgressCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserPracticeProgress.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPracticeProgressAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserPracticeProgressAggregateArgs>(args: Subset<T, UserPracticeProgressAggregateArgs>): Prisma.PrismaPromise<GetUserPracticeProgressAggregateType<T>>

    /**
     * Group by UserPracticeProgress.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPracticeProgressGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserPracticeProgressGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserPracticeProgressGroupByArgs['orderBy'] }
        : { orderBy?: UserPracticeProgressGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserPracticeProgressGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserPracticeProgressGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserPracticeProgress model
   */
  readonly fields: UserPracticeProgressFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserPracticeProgress.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserPracticeProgressClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    practiceClone<T extends PracticeCloneDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PracticeCloneDefaultArgs<ExtArgs>>): Prisma__PracticeCloneClient<$Result.GetResult<Prisma.$PracticeClonePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserPracticeProgress model
   */
  interface UserPracticeProgressFieldRefs {
    readonly id: FieldRef<"UserPracticeProgress", 'Int'>
    readonly userId: FieldRef<"UserPracticeProgress", 'Int'>
    readonly practiceCloneId: FieldRef<"UserPracticeProgress", 'Int'>
    readonly progress: FieldRef<"UserPracticeProgress", 'Int'>
    readonly answers: FieldRef<"UserPracticeProgress", 'String'>
    readonly currentStep: FieldRef<"UserPracticeProgress", 'String'>
    readonly status: FieldRef<"UserPracticeProgress", 'String'>
    readonly lastSaved: FieldRef<"UserPracticeProgress", 'DateTime'>
    readonly submittedAt: FieldRef<"UserPracticeProgress", 'DateTime'>
    readonly reviewComments: FieldRef<"UserPracticeProgress", 'String'>
    readonly reviewScore: FieldRef<"UserPracticeProgress", 'Int'>
    readonly lastReviewed: FieldRef<"UserPracticeProgress", 'DateTime'>
    readonly createdAt: FieldRef<"UserPracticeProgress", 'DateTime'>
    readonly updatedAt: FieldRef<"UserPracticeProgress", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * UserPracticeProgress findUnique
   */
  export type UserPracticeProgressFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPracticeProgress
     */
    select?: UserPracticeProgressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPracticeProgress
     */
    omit?: UserPracticeProgressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPracticeProgressInclude<ExtArgs> | null
    /**
     * Filter, which UserPracticeProgress to fetch.
     */
    where: UserPracticeProgressWhereUniqueInput
  }

  /**
   * UserPracticeProgress findUniqueOrThrow
   */
  export type UserPracticeProgressFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPracticeProgress
     */
    select?: UserPracticeProgressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPracticeProgress
     */
    omit?: UserPracticeProgressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPracticeProgressInclude<ExtArgs> | null
    /**
     * Filter, which UserPracticeProgress to fetch.
     */
    where: UserPracticeProgressWhereUniqueInput
  }

  /**
   * UserPracticeProgress findFirst
   */
  export type UserPracticeProgressFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPracticeProgress
     */
    select?: UserPracticeProgressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPracticeProgress
     */
    omit?: UserPracticeProgressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPracticeProgressInclude<ExtArgs> | null
    /**
     * Filter, which UserPracticeProgress to fetch.
     */
    where?: UserPracticeProgressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserPracticeProgresses to fetch.
     */
    orderBy?: UserPracticeProgressOrderByWithRelationInput | UserPracticeProgressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserPracticeProgresses.
     */
    cursor?: UserPracticeProgressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserPracticeProgresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserPracticeProgresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserPracticeProgresses.
     */
    distinct?: UserPracticeProgressScalarFieldEnum | UserPracticeProgressScalarFieldEnum[]
  }

  /**
   * UserPracticeProgress findFirstOrThrow
   */
  export type UserPracticeProgressFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPracticeProgress
     */
    select?: UserPracticeProgressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPracticeProgress
     */
    omit?: UserPracticeProgressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPracticeProgressInclude<ExtArgs> | null
    /**
     * Filter, which UserPracticeProgress to fetch.
     */
    where?: UserPracticeProgressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserPracticeProgresses to fetch.
     */
    orderBy?: UserPracticeProgressOrderByWithRelationInput | UserPracticeProgressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserPracticeProgresses.
     */
    cursor?: UserPracticeProgressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserPracticeProgresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserPracticeProgresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserPracticeProgresses.
     */
    distinct?: UserPracticeProgressScalarFieldEnum | UserPracticeProgressScalarFieldEnum[]
  }

  /**
   * UserPracticeProgress findMany
   */
  export type UserPracticeProgressFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPracticeProgress
     */
    select?: UserPracticeProgressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPracticeProgress
     */
    omit?: UserPracticeProgressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPracticeProgressInclude<ExtArgs> | null
    /**
     * Filter, which UserPracticeProgresses to fetch.
     */
    where?: UserPracticeProgressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserPracticeProgresses to fetch.
     */
    orderBy?: UserPracticeProgressOrderByWithRelationInput | UserPracticeProgressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserPracticeProgresses.
     */
    cursor?: UserPracticeProgressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserPracticeProgresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserPracticeProgresses.
     */
    skip?: number
    distinct?: UserPracticeProgressScalarFieldEnum | UserPracticeProgressScalarFieldEnum[]
  }

  /**
   * UserPracticeProgress create
   */
  export type UserPracticeProgressCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPracticeProgress
     */
    select?: UserPracticeProgressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPracticeProgress
     */
    omit?: UserPracticeProgressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPracticeProgressInclude<ExtArgs> | null
    /**
     * The data needed to create a UserPracticeProgress.
     */
    data: XOR<UserPracticeProgressCreateInput, UserPracticeProgressUncheckedCreateInput>
  }

  /**
   * UserPracticeProgress createMany
   */
  export type UserPracticeProgressCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserPracticeProgresses.
     */
    data: UserPracticeProgressCreateManyInput | UserPracticeProgressCreateManyInput[]
  }

  /**
   * UserPracticeProgress createManyAndReturn
   */
  export type UserPracticeProgressCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPracticeProgress
     */
    select?: UserPracticeProgressSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserPracticeProgress
     */
    omit?: UserPracticeProgressOmit<ExtArgs> | null
    /**
     * The data used to create many UserPracticeProgresses.
     */
    data: UserPracticeProgressCreateManyInput | UserPracticeProgressCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPracticeProgressIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserPracticeProgress update
   */
  export type UserPracticeProgressUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPracticeProgress
     */
    select?: UserPracticeProgressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPracticeProgress
     */
    omit?: UserPracticeProgressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPracticeProgressInclude<ExtArgs> | null
    /**
     * The data needed to update a UserPracticeProgress.
     */
    data: XOR<UserPracticeProgressUpdateInput, UserPracticeProgressUncheckedUpdateInput>
    /**
     * Choose, which UserPracticeProgress to update.
     */
    where: UserPracticeProgressWhereUniqueInput
  }

  /**
   * UserPracticeProgress updateMany
   */
  export type UserPracticeProgressUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserPracticeProgresses.
     */
    data: XOR<UserPracticeProgressUpdateManyMutationInput, UserPracticeProgressUncheckedUpdateManyInput>
    /**
     * Filter which UserPracticeProgresses to update
     */
    where?: UserPracticeProgressWhereInput
    /**
     * Limit how many UserPracticeProgresses to update.
     */
    limit?: number
  }

  /**
   * UserPracticeProgress updateManyAndReturn
   */
  export type UserPracticeProgressUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPracticeProgress
     */
    select?: UserPracticeProgressSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserPracticeProgress
     */
    omit?: UserPracticeProgressOmit<ExtArgs> | null
    /**
     * The data used to update UserPracticeProgresses.
     */
    data: XOR<UserPracticeProgressUpdateManyMutationInput, UserPracticeProgressUncheckedUpdateManyInput>
    /**
     * Filter which UserPracticeProgresses to update
     */
    where?: UserPracticeProgressWhereInput
    /**
     * Limit how many UserPracticeProgresses to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPracticeProgressIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserPracticeProgress upsert
   */
  export type UserPracticeProgressUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPracticeProgress
     */
    select?: UserPracticeProgressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPracticeProgress
     */
    omit?: UserPracticeProgressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPracticeProgressInclude<ExtArgs> | null
    /**
     * The filter to search for the UserPracticeProgress to update in case it exists.
     */
    where: UserPracticeProgressWhereUniqueInput
    /**
     * In case the UserPracticeProgress found by the `where` argument doesn't exist, create a new UserPracticeProgress with this data.
     */
    create: XOR<UserPracticeProgressCreateInput, UserPracticeProgressUncheckedCreateInput>
    /**
     * In case the UserPracticeProgress was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserPracticeProgressUpdateInput, UserPracticeProgressUncheckedUpdateInput>
  }

  /**
   * UserPracticeProgress delete
   */
  export type UserPracticeProgressDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPracticeProgress
     */
    select?: UserPracticeProgressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPracticeProgress
     */
    omit?: UserPracticeProgressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPracticeProgressInclude<ExtArgs> | null
    /**
     * Filter which UserPracticeProgress to delete.
     */
    where: UserPracticeProgressWhereUniqueInput
  }

  /**
   * UserPracticeProgress deleteMany
   */
  export type UserPracticeProgressDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserPracticeProgresses to delete
     */
    where?: UserPracticeProgressWhereInput
    /**
     * Limit how many UserPracticeProgresses to delete.
     */
    limit?: number
  }

  /**
   * UserPracticeProgress without action
   */
  export type UserPracticeProgressDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPracticeProgress
     */
    select?: UserPracticeProgressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPracticeProgress
     */
    omit?: UserPracticeProgressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPracticeProgressInclude<ExtArgs> | null
  }


  /**
   * Model HelpTopic
   */

  export type AggregateHelpTopic = {
    _count: HelpTopicCountAggregateOutputType | null
    _min: HelpTopicMinAggregateOutputType | null
    _max: HelpTopicMaxAggregateOutputType | null
  }

  export type HelpTopicMinAggregateOutputType = {
    id: string | null
    analysisQuestionId: string | null
    title: string | null
    videoBoxUrl: string | null
    helpDocumentUrl: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type HelpTopicMaxAggregateOutputType = {
    id: string | null
    analysisQuestionId: string | null
    title: string | null
    videoBoxUrl: string | null
    helpDocumentUrl: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type HelpTopicCountAggregateOutputType = {
    id: number
    analysisQuestionId: number
    title: number
    videoBoxUrl: number
    helpDocumentUrl: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type HelpTopicMinAggregateInputType = {
    id?: true
    analysisQuestionId?: true
    title?: true
    videoBoxUrl?: true
    helpDocumentUrl?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type HelpTopicMaxAggregateInputType = {
    id?: true
    analysisQuestionId?: true
    title?: true
    videoBoxUrl?: true
    helpDocumentUrl?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type HelpTopicCountAggregateInputType = {
    id?: true
    analysisQuestionId?: true
    title?: true
    videoBoxUrl?: true
    helpDocumentUrl?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type HelpTopicAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which HelpTopic to aggregate.
     */
    where?: HelpTopicWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HelpTopics to fetch.
     */
    orderBy?: HelpTopicOrderByWithRelationInput | HelpTopicOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: HelpTopicWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HelpTopics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HelpTopics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned HelpTopics
    **/
    _count?: true | HelpTopicCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: HelpTopicMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: HelpTopicMaxAggregateInputType
  }

  export type GetHelpTopicAggregateType<T extends HelpTopicAggregateArgs> = {
        [P in keyof T & keyof AggregateHelpTopic]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateHelpTopic[P]>
      : GetScalarType<T[P], AggregateHelpTopic[P]>
  }




  export type HelpTopicGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: HelpTopicWhereInput
    orderBy?: HelpTopicOrderByWithAggregationInput | HelpTopicOrderByWithAggregationInput[]
    by: HelpTopicScalarFieldEnum[] | HelpTopicScalarFieldEnum
    having?: HelpTopicScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: HelpTopicCountAggregateInputType | true
    _min?: HelpTopicMinAggregateInputType
    _max?: HelpTopicMaxAggregateInputType
  }

  export type HelpTopicGroupByOutputType = {
    id: string
    analysisQuestionId: string
    title: string
    videoBoxUrl: string
    helpDocumentUrl: string
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: HelpTopicCountAggregateOutputType | null
    _min: HelpTopicMinAggregateOutputType | null
    _max: HelpTopicMaxAggregateOutputType | null
  }

  type GetHelpTopicGroupByPayload<T extends HelpTopicGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<HelpTopicGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof HelpTopicGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], HelpTopicGroupByOutputType[P]>
            : GetScalarType<T[P], HelpTopicGroupByOutputType[P]>
        }
      >
    >


  export type HelpTopicSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    analysisQuestionId?: boolean
    title?: boolean
    videoBoxUrl?: boolean
    helpDocumentUrl?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    analysisQuestion?: boolean | AnalysisQuestionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["helpTopic"]>

  export type HelpTopicSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    analysisQuestionId?: boolean
    title?: boolean
    videoBoxUrl?: boolean
    helpDocumentUrl?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    analysisQuestion?: boolean | AnalysisQuestionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["helpTopic"]>

  export type HelpTopicSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    analysisQuestionId?: boolean
    title?: boolean
    videoBoxUrl?: boolean
    helpDocumentUrl?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    analysisQuestion?: boolean | AnalysisQuestionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["helpTopic"]>

  export type HelpTopicSelectScalar = {
    id?: boolean
    analysisQuestionId?: boolean
    title?: boolean
    videoBoxUrl?: boolean
    helpDocumentUrl?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type HelpTopicOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "analysisQuestionId" | "title" | "videoBoxUrl" | "helpDocumentUrl" | "isActive" | "createdAt" | "updatedAt", ExtArgs["result"]["helpTopic"]>
  export type HelpTopicInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    analysisQuestion?: boolean | AnalysisQuestionDefaultArgs<ExtArgs>
  }
  export type HelpTopicIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    analysisQuestion?: boolean | AnalysisQuestionDefaultArgs<ExtArgs>
  }
  export type HelpTopicIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    analysisQuestion?: boolean | AnalysisQuestionDefaultArgs<ExtArgs>
  }

  export type $HelpTopicPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "HelpTopic"
    objects: {
      analysisQuestion: Prisma.$AnalysisQuestionPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      analysisQuestionId: string
      title: string
      videoBoxUrl: string
      helpDocumentUrl: string
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["helpTopic"]>
    composites: {}
  }

  type HelpTopicGetPayload<S extends boolean | null | undefined | HelpTopicDefaultArgs> = $Result.GetResult<Prisma.$HelpTopicPayload, S>

  type HelpTopicCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<HelpTopicFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: HelpTopicCountAggregateInputType | true
    }

  export interface HelpTopicDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['HelpTopic'], meta: { name: 'HelpTopic' } }
    /**
     * Find zero or one HelpTopic that matches the filter.
     * @param {HelpTopicFindUniqueArgs} args - Arguments to find a HelpTopic
     * @example
     * // Get one HelpTopic
     * const helpTopic = await prisma.helpTopic.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends HelpTopicFindUniqueArgs>(args: SelectSubset<T, HelpTopicFindUniqueArgs<ExtArgs>>): Prisma__HelpTopicClient<$Result.GetResult<Prisma.$HelpTopicPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one HelpTopic that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {HelpTopicFindUniqueOrThrowArgs} args - Arguments to find a HelpTopic
     * @example
     * // Get one HelpTopic
     * const helpTopic = await prisma.helpTopic.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends HelpTopicFindUniqueOrThrowArgs>(args: SelectSubset<T, HelpTopicFindUniqueOrThrowArgs<ExtArgs>>): Prisma__HelpTopicClient<$Result.GetResult<Prisma.$HelpTopicPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first HelpTopic that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HelpTopicFindFirstArgs} args - Arguments to find a HelpTopic
     * @example
     * // Get one HelpTopic
     * const helpTopic = await prisma.helpTopic.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends HelpTopicFindFirstArgs>(args?: SelectSubset<T, HelpTopicFindFirstArgs<ExtArgs>>): Prisma__HelpTopicClient<$Result.GetResult<Prisma.$HelpTopicPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first HelpTopic that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HelpTopicFindFirstOrThrowArgs} args - Arguments to find a HelpTopic
     * @example
     * // Get one HelpTopic
     * const helpTopic = await prisma.helpTopic.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends HelpTopicFindFirstOrThrowArgs>(args?: SelectSubset<T, HelpTopicFindFirstOrThrowArgs<ExtArgs>>): Prisma__HelpTopicClient<$Result.GetResult<Prisma.$HelpTopicPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more HelpTopics that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HelpTopicFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all HelpTopics
     * const helpTopics = await prisma.helpTopic.findMany()
     * 
     * // Get first 10 HelpTopics
     * const helpTopics = await prisma.helpTopic.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const helpTopicWithIdOnly = await prisma.helpTopic.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends HelpTopicFindManyArgs>(args?: SelectSubset<T, HelpTopicFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HelpTopicPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a HelpTopic.
     * @param {HelpTopicCreateArgs} args - Arguments to create a HelpTopic.
     * @example
     * // Create one HelpTopic
     * const HelpTopic = await prisma.helpTopic.create({
     *   data: {
     *     // ... data to create a HelpTopic
     *   }
     * })
     * 
     */
    create<T extends HelpTopicCreateArgs>(args: SelectSubset<T, HelpTopicCreateArgs<ExtArgs>>): Prisma__HelpTopicClient<$Result.GetResult<Prisma.$HelpTopicPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many HelpTopics.
     * @param {HelpTopicCreateManyArgs} args - Arguments to create many HelpTopics.
     * @example
     * // Create many HelpTopics
     * const helpTopic = await prisma.helpTopic.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends HelpTopicCreateManyArgs>(args?: SelectSubset<T, HelpTopicCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many HelpTopics and returns the data saved in the database.
     * @param {HelpTopicCreateManyAndReturnArgs} args - Arguments to create many HelpTopics.
     * @example
     * // Create many HelpTopics
     * const helpTopic = await prisma.helpTopic.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many HelpTopics and only return the `id`
     * const helpTopicWithIdOnly = await prisma.helpTopic.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends HelpTopicCreateManyAndReturnArgs>(args?: SelectSubset<T, HelpTopicCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HelpTopicPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a HelpTopic.
     * @param {HelpTopicDeleteArgs} args - Arguments to delete one HelpTopic.
     * @example
     * // Delete one HelpTopic
     * const HelpTopic = await prisma.helpTopic.delete({
     *   where: {
     *     // ... filter to delete one HelpTopic
     *   }
     * })
     * 
     */
    delete<T extends HelpTopicDeleteArgs>(args: SelectSubset<T, HelpTopicDeleteArgs<ExtArgs>>): Prisma__HelpTopicClient<$Result.GetResult<Prisma.$HelpTopicPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one HelpTopic.
     * @param {HelpTopicUpdateArgs} args - Arguments to update one HelpTopic.
     * @example
     * // Update one HelpTopic
     * const helpTopic = await prisma.helpTopic.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends HelpTopicUpdateArgs>(args: SelectSubset<T, HelpTopicUpdateArgs<ExtArgs>>): Prisma__HelpTopicClient<$Result.GetResult<Prisma.$HelpTopicPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more HelpTopics.
     * @param {HelpTopicDeleteManyArgs} args - Arguments to filter HelpTopics to delete.
     * @example
     * // Delete a few HelpTopics
     * const { count } = await prisma.helpTopic.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends HelpTopicDeleteManyArgs>(args?: SelectSubset<T, HelpTopicDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more HelpTopics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HelpTopicUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many HelpTopics
     * const helpTopic = await prisma.helpTopic.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends HelpTopicUpdateManyArgs>(args: SelectSubset<T, HelpTopicUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more HelpTopics and returns the data updated in the database.
     * @param {HelpTopicUpdateManyAndReturnArgs} args - Arguments to update many HelpTopics.
     * @example
     * // Update many HelpTopics
     * const helpTopic = await prisma.helpTopic.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more HelpTopics and only return the `id`
     * const helpTopicWithIdOnly = await prisma.helpTopic.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends HelpTopicUpdateManyAndReturnArgs>(args: SelectSubset<T, HelpTopicUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HelpTopicPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one HelpTopic.
     * @param {HelpTopicUpsertArgs} args - Arguments to update or create a HelpTopic.
     * @example
     * // Update or create a HelpTopic
     * const helpTopic = await prisma.helpTopic.upsert({
     *   create: {
     *     // ... data to create a HelpTopic
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the HelpTopic we want to update
     *   }
     * })
     */
    upsert<T extends HelpTopicUpsertArgs>(args: SelectSubset<T, HelpTopicUpsertArgs<ExtArgs>>): Prisma__HelpTopicClient<$Result.GetResult<Prisma.$HelpTopicPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of HelpTopics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HelpTopicCountArgs} args - Arguments to filter HelpTopics to count.
     * @example
     * // Count the number of HelpTopics
     * const count = await prisma.helpTopic.count({
     *   where: {
     *     // ... the filter for the HelpTopics we want to count
     *   }
     * })
    **/
    count<T extends HelpTopicCountArgs>(
      args?: Subset<T, HelpTopicCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], HelpTopicCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a HelpTopic.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HelpTopicAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends HelpTopicAggregateArgs>(args: Subset<T, HelpTopicAggregateArgs>): Prisma.PrismaPromise<GetHelpTopicAggregateType<T>>

    /**
     * Group by HelpTopic.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HelpTopicGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends HelpTopicGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: HelpTopicGroupByArgs['orderBy'] }
        : { orderBy?: HelpTopicGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, HelpTopicGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetHelpTopicGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the HelpTopic model
   */
  readonly fields: HelpTopicFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for HelpTopic.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__HelpTopicClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    analysisQuestion<T extends AnalysisQuestionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AnalysisQuestionDefaultArgs<ExtArgs>>): Prisma__AnalysisQuestionClient<$Result.GetResult<Prisma.$AnalysisQuestionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the HelpTopic model
   */
  interface HelpTopicFieldRefs {
    readonly id: FieldRef<"HelpTopic", 'String'>
    readonly analysisQuestionId: FieldRef<"HelpTopic", 'String'>
    readonly title: FieldRef<"HelpTopic", 'String'>
    readonly videoBoxUrl: FieldRef<"HelpTopic", 'String'>
    readonly helpDocumentUrl: FieldRef<"HelpTopic", 'String'>
    readonly isActive: FieldRef<"HelpTopic", 'Boolean'>
    readonly createdAt: FieldRef<"HelpTopic", 'DateTime'>
    readonly updatedAt: FieldRef<"HelpTopic", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * HelpTopic findUnique
   */
  export type HelpTopicFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HelpTopic
     */
    select?: HelpTopicSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HelpTopic
     */
    omit?: HelpTopicOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HelpTopicInclude<ExtArgs> | null
    /**
     * Filter, which HelpTopic to fetch.
     */
    where: HelpTopicWhereUniqueInput
  }

  /**
   * HelpTopic findUniqueOrThrow
   */
  export type HelpTopicFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HelpTopic
     */
    select?: HelpTopicSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HelpTopic
     */
    omit?: HelpTopicOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HelpTopicInclude<ExtArgs> | null
    /**
     * Filter, which HelpTopic to fetch.
     */
    where: HelpTopicWhereUniqueInput
  }

  /**
   * HelpTopic findFirst
   */
  export type HelpTopicFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HelpTopic
     */
    select?: HelpTopicSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HelpTopic
     */
    omit?: HelpTopicOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HelpTopicInclude<ExtArgs> | null
    /**
     * Filter, which HelpTopic to fetch.
     */
    where?: HelpTopicWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HelpTopics to fetch.
     */
    orderBy?: HelpTopicOrderByWithRelationInput | HelpTopicOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for HelpTopics.
     */
    cursor?: HelpTopicWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HelpTopics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HelpTopics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of HelpTopics.
     */
    distinct?: HelpTopicScalarFieldEnum | HelpTopicScalarFieldEnum[]
  }

  /**
   * HelpTopic findFirstOrThrow
   */
  export type HelpTopicFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HelpTopic
     */
    select?: HelpTopicSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HelpTopic
     */
    omit?: HelpTopicOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HelpTopicInclude<ExtArgs> | null
    /**
     * Filter, which HelpTopic to fetch.
     */
    where?: HelpTopicWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HelpTopics to fetch.
     */
    orderBy?: HelpTopicOrderByWithRelationInput | HelpTopicOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for HelpTopics.
     */
    cursor?: HelpTopicWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HelpTopics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HelpTopics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of HelpTopics.
     */
    distinct?: HelpTopicScalarFieldEnum | HelpTopicScalarFieldEnum[]
  }

  /**
   * HelpTopic findMany
   */
  export type HelpTopicFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HelpTopic
     */
    select?: HelpTopicSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HelpTopic
     */
    omit?: HelpTopicOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HelpTopicInclude<ExtArgs> | null
    /**
     * Filter, which HelpTopics to fetch.
     */
    where?: HelpTopicWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HelpTopics to fetch.
     */
    orderBy?: HelpTopicOrderByWithRelationInput | HelpTopicOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing HelpTopics.
     */
    cursor?: HelpTopicWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HelpTopics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HelpTopics.
     */
    skip?: number
    distinct?: HelpTopicScalarFieldEnum | HelpTopicScalarFieldEnum[]
  }

  /**
   * HelpTopic create
   */
  export type HelpTopicCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HelpTopic
     */
    select?: HelpTopicSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HelpTopic
     */
    omit?: HelpTopicOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HelpTopicInclude<ExtArgs> | null
    /**
     * The data needed to create a HelpTopic.
     */
    data: XOR<HelpTopicCreateInput, HelpTopicUncheckedCreateInput>
  }

  /**
   * HelpTopic createMany
   */
  export type HelpTopicCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many HelpTopics.
     */
    data: HelpTopicCreateManyInput | HelpTopicCreateManyInput[]
  }

  /**
   * HelpTopic createManyAndReturn
   */
  export type HelpTopicCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HelpTopic
     */
    select?: HelpTopicSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the HelpTopic
     */
    omit?: HelpTopicOmit<ExtArgs> | null
    /**
     * The data used to create many HelpTopics.
     */
    data: HelpTopicCreateManyInput | HelpTopicCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HelpTopicIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * HelpTopic update
   */
  export type HelpTopicUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HelpTopic
     */
    select?: HelpTopicSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HelpTopic
     */
    omit?: HelpTopicOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HelpTopicInclude<ExtArgs> | null
    /**
     * The data needed to update a HelpTopic.
     */
    data: XOR<HelpTopicUpdateInput, HelpTopicUncheckedUpdateInput>
    /**
     * Choose, which HelpTopic to update.
     */
    where: HelpTopicWhereUniqueInput
  }

  /**
   * HelpTopic updateMany
   */
  export type HelpTopicUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update HelpTopics.
     */
    data: XOR<HelpTopicUpdateManyMutationInput, HelpTopicUncheckedUpdateManyInput>
    /**
     * Filter which HelpTopics to update
     */
    where?: HelpTopicWhereInput
    /**
     * Limit how many HelpTopics to update.
     */
    limit?: number
  }

  /**
   * HelpTopic updateManyAndReturn
   */
  export type HelpTopicUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HelpTopic
     */
    select?: HelpTopicSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the HelpTopic
     */
    omit?: HelpTopicOmit<ExtArgs> | null
    /**
     * The data used to update HelpTopics.
     */
    data: XOR<HelpTopicUpdateManyMutationInput, HelpTopicUncheckedUpdateManyInput>
    /**
     * Filter which HelpTopics to update
     */
    where?: HelpTopicWhereInput
    /**
     * Limit how many HelpTopics to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HelpTopicIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * HelpTopic upsert
   */
  export type HelpTopicUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HelpTopic
     */
    select?: HelpTopicSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HelpTopic
     */
    omit?: HelpTopicOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HelpTopicInclude<ExtArgs> | null
    /**
     * The filter to search for the HelpTopic to update in case it exists.
     */
    where: HelpTopicWhereUniqueInput
    /**
     * In case the HelpTopic found by the `where` argument doesn't exist, create a new HelpTopic with this data.
     */
    create: XOR<HelpTopicCreateInput, HelpTopicUncheckedCreateInput>
    /**
     * In case the HelpTopic was found with the provided `where` argument, update it with this data.
     */
    update: XOR<HelpTopicUpdateInput, HelpTopicUncheckedUpdateInput>
  }

  /**
   * HelpTopic delete
   */
  export type HelpTopicDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HelpTopic
     */
    select?: HelpTopicSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HelpTopic
     */
    omit?: HelpTopicOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HelpTopicInclude<ExtArgs> | null
    /**
     * Filter which HelpTopic to delete.
     */
    where: HelpTopicWhereUniqueInput
  }

  /**
   * HelpTopic deleteMany
   */
  export type HelpTopicDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which HelpTopics to delete
     */
    where?: HelpTopicWhereInput
    /**
     * Limit how many HelpTopics to delete.
     */
    limit?: number
  }

  /**
   * HelpTopic without action
   */
  export type HelpTopicDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HelpTopic
     */
    select?: HelpTopicSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HelpTopic
     */
    omit?: HelpTopicOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HelpTopicInclude<ExtArgs> | null
  }


  /**
   * Model StepHelp
   */

  export type AggregateStepHelp = {
    _count: StepHelpCountAggregateOutputType | null
    _min: StepHelpMinAggregateOutputType | null
    _max: StepHelpMaxAggregateOutputType | null
  }

  export type StepHelpMinAggregateOutputType = {
    id: string | null
    step: string | null
    title: string | null
    description: string | null
    videoBoxUrl: string | null
    helpDocumentUrl: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type StepHelpMaxAggregateOutputType = {
    id: string | null
    step: string | null
    title: string | null
    description: string | null
    videoBoxUrl: string | null
    helpDocumentUrl: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type StepHelpCountAggregateOutputType = {
    id: number
    step: number
    title: number
    description: number
    videoBoxUrl: number
    helpDocumentUrl: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type StepHelpMinAggregateInputType = {
    id?: true
    step?: true
    title?: true
    description?: true
    videoBoxUrl?: true
    helpDocumentUrl?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type StepHelpMaxAggregateInputType = {
    id?: true
    step?: true
    title?: true
    description?: true
    videoBoxUrl?: true
    helpDocumentUrl?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type StepHelpCountAggregateInputType = {
    id?: true
    step?: true
    title?: true
    description?: true
    videoBoxUrl?: true
    helpDocumentUrl?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type StepHelpAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StepHelp to aggregate.
     */
    where?: StepHelpWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StepHelps to fetch.
     */
    orderBy?: StepHelpOrderByWithRelationInput | StepHelpOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StepHelpWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StepHelps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StepHelps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned StepHelps
    **/
    _count?: true | StepHelpCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StepHelpMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StepHelpMaxAggregateInputType
  }

  export type GetStepHelpAggregateType<T extends StepHelpAggregateArgs> = {
        [P in keyof T & keyof AggregateStepHelp]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStepHelp[P]>
      : GetScalarType<T[P], AggregateStepHelp[P]>
  }




  export type StepHelpGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StepHelpWhereInput
    orderBy?: StepHelpOrderByWithAggregationInput | StepHelpOrderByWithAggregationInput[]
    by: StepHelpScalarFieldEnum[] | StepHelpScalarFieldEnum
    having?: StepHelpScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StepHelpCountAggregateInputType | true
    _min?: StepHelpMinAggregateInputType
    _max?: StepHelpMaxAggregateInputType
  }

  export type StepHelpGroupByOutputType = {
    id: string
    step: string
    title: string
    description: string | null
    videoBoxUrl: string
    helpDocumentUrl: string
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: StepHelpCountAggregateOutputType | null
    _min: StepHelpMinAggregateOutputType | null
    _max: StepHelpMaxAggregateOutputType | null
  }

  type GetStepHelpGroupByPayload<T extends StepHelpGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StepHelpGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StepHelpGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StepHelpGroupByOutputType[P]>
            : GetScalarType<T[P], StepHelpGroupByOutputType[P]>
        }
      >
    >


  export type StepHelpSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    step?: boolean
    title?: boolean
    description?: boolean
    videoBoxUrl?: boolean
    helpDocumentUrl?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["stepHelp"]>

  export type StepHelpSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    step?: boolean
    title?: boolean
    description?: boolean
    videoBoxUrl?: boolean
    helpDocumentUrl?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["stepHelp"]>

  export type StepHelpSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    step?: boolean
    title?: boolean
    description?: boolean
    videoBoxUrl?: boolean
    helpDocumentUrl?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["stepHelp"]>

  export type StepHelpSelectScalar = {
    id?: boolean
    step?: boolean
    title?: boolean
    description?: boolean
    videoBoxUrl?: boolean
    helpDocumentUrl?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type StepHelpOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "step" | "title" | "description" | "videoBoxUrl" | "helpDocumentUrl" | "isActive" | "createdAt" | "updatedAt", ExtArgs["result"]["stepHelp"]>

  export type $StepHelpPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "StepHelp"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      step: string
      title: string
      description: string | null
      videoBoxUrl: string
      helpDocumentUrl: string
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["stepHelp"]>
    composites: {}
  }

  type StepHelpGetPayload<S extends boolean | null | undefined | StepHelpDefaultArgs> = $Result.GetResult<Prisma.$StepHelpPayload, S>

  type StepHelpCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<StepHelpFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: StepHelpCountAggregateInputType | true
    }

  export interface StepHelpDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['StepHelp'], meta: { name: 'StepHelp' } }
    /**
     * Find zero or one StepHelp that matches the filter.
     * @param {StepHelpFindUniqueArgs} args - Arguments to find a StepHelp
     * @example
     * // Get one StepHelp
     * const stepHelp = await prisma.stepHelp.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends StepHelpFindUniqueArgs>(args: SelectSubset<T, StepHelpFindUniqueArgs<ExtArgs>>): Prisma__StepHelpClient<$Result.GetResult<Prisma.$StepHelpPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one StepHelp that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {StepHelpFindUniqueOrThrowArgs} args - Arguments to find a StepHelp
     * @example
     * // Get one StepHelp
     * const stepHelp = await prisma.stepHelp.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends StepHelpFindUniqueOrThrowArgs>(args: SelectSubset<T, StepHelpFindUniqueOrThrowArgs<ExtArgs>>): Prisma__StepHelpClient<$Result.GetResult<Prisma.$StepHelpPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first StepHelp that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StepHelpFindFirstArgs} args - Arguments to find a StepHelp
     * @example
     * // Get one StepHelp
     * const stepHelp = await prisma.stepHelp.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends StepHelpFindFirstArgs>(args?: SelectSubset<T, StepHelpFindFirstArgs<ExtArgs>>): Prisma__StepHelpClient<$Result.GetResult<Prisma.$StepHelpPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first StepHelp that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StepHelpFindFirstOrThrowArgs} args - Arguments to find a StepHelp
     * @example
     * // Get one StepHelp
     * const stepHelp = await prisma.stepHelp.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends StepHelpFindFirstOrThrowArgs>(args?: SelectSubset<T, StepHelpFindFirstOrThrowArgs<ExtArgs>>): Prisma__StepHelpClient<$Result.GetResult<Prisma.$StepHelpPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more StepHelps that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StepHelpFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all StepHelps
     * const stepHelps = await prisma.stepHelp.findMany()
     * 
     * // Get first 10 StepHelps
     * const stepHelps = await prisma.stepHelp.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const stepHelpWithIdOnly = await prisma.stepHelp.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends StepHelpFindManyArgs>(args?: SelectSubset<T, StepHelpFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StepHelpPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a StepHelp.
     * @param {StepHelpCreateArgs} args - Arguments to create a StepHelp.
     * @example
     * // Create one StepHelp
     * const StepHelp = await prisma.stepHelp.create({
     *   data: {
     *     // ... data to create a StepHelp
     *   }
     * })
     * 
     */
    create<T extends StepHelpCreateArgs>(args: SelectSubset<T, StepHelpCreateArgs<ExtArgs>>): Prisma__StepHelpClient<$Result.GetResult<Prisma.$StepHelpPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many StepHelps.
     * @param {StepHelpCreateManyArgs} args - Arguments to create many StepHelps.
     * @example
     * // Create many StepHelps
     * const stepHelp = await prisma.stepHelp.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends StepHelpCreateManyArgs>(args?: SelectSubset<T, StepHelpCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many StepHelps and returns the data saved in the database.
     * @param {StepHelpCreateManyAndReturnArgs} args - Arguments to create many StepHelps.
     * @example
     * // Create many StepHelps
     * const stepHelp = await prisma.stepHelp.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many StepHelps and only return the `id`
     * const stepHelpWithIdOnly = await prisma.stepHelp.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends StepHelpCreateManyAndReturnArgs>(args?: SelectSubset<T, StepHelpCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StepHelpPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a StepHelp.
     * @param {StepHelpDeleteArgs} args - Arguments to delete one StepHelp.
     * @example
     * // Delete one StepHelp
     * const StepHelp = await prisma.stepHelp.delete({
     *   where: {
     *     // ... filter to delete one StepHelp
     *   }
     * })
     * 
     */
    delete<T extends StepHelpDeleteArgs>(args: SelectSubset<T, StepHelpDeleteArgs<ExtArgs>>): Prisma__StepHelpClient<$Result.GetResult<Prisma.$StepHelpPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one StepHelp.
     * @param {StepHelpUpdateArgs} args - Arguments to update one StepHelp.
     * @example
     * // Update one StepHelp
     * const stepHelp = await prisma.stepHelp.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends StepHelpUpdateArgs>(args: SelectSubset<T, StepHelpUpdateArgs<ExtArgs>>): Prisma__StepHelpClient<$Result.GetResult<Prisma.$StepHelpPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more StepHelps.
     * @param {StepHelpDeleteManyArgs} args - Arguments to filter StepHelps to delete.
     * @example
     * // Delete a few StepHelps
     * const { count } = await prisma.stepHelp.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends StepHelpDeleteManyArgs>(args?: SelectSubset<T, StepHelpDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StepHelps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StepHelpUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many StepHelps
     * const stepHelp = await prisma.stepHelp.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends StepHelpUpdateManyArgs>(args: SelectSubset<T, StepHelpUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StepHelps and returns the data updated in the database.
     * @param {StepHelpUpdateManyAndReturnArgs} args - Arguments to update many StepHelps.
     * @example
     * // Update many StepHelps
     * const stepHelp = await prisma.stepHelp.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more StepHelps and only return the `id`
     * const stepHelpWithIdOnly = await prisma.stepHelp.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends StepHelpUpdateManyAndReturnArgs>(args: SelectSubset<T, StepHelpUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StepHelpPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one StepHelp.
     * @param {StepHelpUpsertArgs} args - Arguments to update or create a StepHelp.
     * @example
     * // Update or create a StepHelp
     * const stepHelp = await prisma.stepHelp.upsert({
     *   create: {
     *     // ... data to create a StepHelp
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the StepHelp we want to update
     *   }
     * })
     */
    upsert<T extends StepHelpUpsertArgs>(args: SelectSubset<T, StepHelpUpsertArgs<ExtArgs>>): Prisma__StepHelpClient<$Result.GetResult<Prisma.$StepHelpPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of StepHelps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StepHelpCountArgs} args - Arguments to filter StepHelps to count.
     * @example
     * // Count the number of StepHelps
     * const count = await prisma.stepHelp.count({
     *   where: {
     *     // ... the filter for the StepHelps we want to count
     *   }
     * })
    **/
    count<T extends StepHelpCountArgs>(
      args?: Subset<T, StepHelpCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StepHelpCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a StepHelp.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StepHelpAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StepHelpAggregateArgs>(args: Subset<T, StepHelpAggregateArgs>): Prisma.PrismaPromise<GetStepHelpAggregateType<T>>

    /**
     * Group by StepHelp.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StepHelpGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StepHelpGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StepHelpGroupByArgs['orderBy'] }
        : { orderBy?: StepHelpGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StepHelpGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStepHelpGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the StepHelp model
   */
  readonly fields: StepHelpFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for StepHelp.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StepHelpClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the StepHelp model
   */
  interface StepHelpFieldRefs {
    readonly id: FieldRef<"StepHelp", 'String'>
    readonly step: FieldRef<"StepHelp", 'String'>
    readonly title: FieldRef<"StepHelp", 'String'>
    readonly description: FieldRef<"StepHelp", 'String'>
    readonly videoBoxUrl: FieldRef<"StepHelp", 'String'>
    readonly helpDocumentUrl: FieldRef<"StepHelp", 'String'>
    readonly isActive: FieldRef<"StepHelp", 'Boolean'>
    readonly createdAt: FieldRef<"StepHelp", 'DateTime'>
    readonly updatedAt: FieldRef<"StepHelp", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * StepHelp findUnique
   */
  export type StepHelpFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StepHelp
     */
    select?: StepHelpSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StepHelp
     */
    omit?: StepHelpOmit<ExtArgs> | null
    /**
     * Filter, which StepHelp to fetch.
     */
    where: StepHelpWhereUniqueInput
  }

  /**
   * StepHelp findUniqueOrThrow
   */
  export type StepHelpFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StepHelp
     */
    select?: StepHelpSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StepHelp
     */
    omit?: StepHelpOmit<ExtArgs> | null
    /**
     * Filter, which StepHelp to fetch.
     */
    where: StepHelpWhereUniqueInput
  }

  /**
   * StepHelp findFirst
   */
  export type StepHelpFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StepHelp
     */
    select?: StepHelpSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StepHelp
     */
    omit?: StepHelpOmit<ExtArgs> | null
    /**
     * Filter, which StepHelp to fetch.
     */
    where?: StepHelpWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StepHelps to fetch.
     */
    orderBy?: StepHelpOrderByWithRelationInput | StepHelpOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StepHelps.
     */
    cursor?: StepHelpWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StepHelps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StepHelps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StepHelps.
     */
    distinct?: StepHelpScalarFieldEnum | StepHelpScalarFieldEnum[]
  }

  /**
   * StepHelp findFirstOrThrow
   */
  export type StepHelpFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StepHelp
     */
    select?: StepHelpSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StepHelp
     */
    omit?: StepHelpOmit<ExtArgs> | null
    /**
     * Filter, which StepHelp to fetch.
     */
    where?: StepHelpWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StepHelps to fetch.
     */
    orderBy?: StepHelpOrderByWithRelationInput | StepHelpOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StepHelps.
     */
    cursor?: StepHelpWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StepHelps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StepHelps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StepHelps.
     */
    distinct?: StepHelpScalarFieldEnum | StepHelpScalarFieldEnum[]
  }

  /**
   * StepHelp findMany
   */
  export type StepHelpFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StepHelp
     */
    select?: StepHelpSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StepHelp
     */
    omit?: StepHelpOmit<ExtArgs> | null
    /**
     * Filter, which StepHelps to fetch.
     */
    where?: StepHelpWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StepHelps to fetch.
     */
    orderBy?: StepHelpOrderByWithRelationInput | StepHelpOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing StepHelps.
     */
    cursor?: StepHelpWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StepHelps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StepHelps.
     */
    skip?: number
    distinct?: StepHelpScalarFieldEnum | StepHelpScalarFieldEnum[]
  }

  /**
   * StepHelp create
   */
  export type StepHelpCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StepHelp
     */
    select?: StepHelpSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StepHelp
     */
    omit?: StepHelpOmit<ExtArgs> | null
    /**
     * The data needed to create a StepHelp.
     */
    data: XOR<StepHelpCreateInput, StepHelpUncheckedCreateInput>
  }

  /**
   * StepHelp createMany
   */
  export type StepHelpCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many StepHelps.
     */
    data: StepHelpCreateManyInput | StepHelpCreateManyInput[]
  }

  /**
   * StepHelp createManyAndReturn
   */
  export type StepHelpCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StepHelp
     */
    select?: StepHelpSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the StepHelp
     */
    omit?: StepHelpOmit<ExtArgs> | null
    /**
     * The data used to create many StepHelps.
     */
    data: StepHelpCreateManyInput | StepHelpCreateManyInput[]
  }

  /**
   * StepHelp update
   */
  export type StepHelpUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StepHelp
     */
    select?: StepHelpSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StepHelp
     */
    omit?: StepHelpOmit<ExtArgs> | null
    /**
     * The data needed to update a StepHelp.
     */
    data: XOR<StepHelpUpdateInput, StepHelpUncheckedUpdateInput>
    /**
     * Choose, which StepHelp to update.
     */
    where: StepHelpWhereUniqueInput
  }

  /**
   * StepHelp updateMany
   */
  export type StepHelpUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update StepHelps.
     */
    data: XOR<StepHelpUpdateManyMutationInput, StepHelpUncheckedUpdateManyInput>
    /**
     * Filter which StepHelps to update
     */
    where?: StepHelpWhereInput
    /**
     * Limit how many StepHelps to update.
     */
    limit?: number
  }

  /**
   * StepHelp updateManyAndReturn
   */
  export type StepHelpUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StepHelp
     */
    select?: StepHelpSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the StepHelp
     */
    omit?: StepHelpOmit<ExtArgs> | null
    /**
     * The data used to update StepHelps.
     */
    data: XOR<StepHelpUpdateManyMutationInput, StepHelpUncheckedUpdateManyInput>
    /**
     * Filter which StepHelps to update
     */
    where?: StepHelpWhereInput
    /**
     * Limit how many StepHelps to update.
     */
    limit?: number
  }

  /**
   * StepHelp upsert
   */
  export type StepHelpUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StepHelp
     */
    select?: StepHelpSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StepHelp
     */
    omit?: StepHelpOmit<ExtArgs> | null
    /**
     * The filter to search for the StepHelp to update in case it exists.
     */
    where: StepHelpWhereUniqueInput
    /**
     * In case the StepHelp found by the `where` argument doesn't exist, create a new StepHelp with this data.
     */
    create: XOR<StepHelpCreateInput, StepHelpUncheckedCreateInput>
    /**
     * In case the StepHelp was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StepHelpUpdateInput, StepHelpUncheckedUpdateInput>
  }

  /**
   * StepHelp delete
   */
  export type StepHelpDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StepHelp
     */
    select?: StepHelpSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StepHelp
     */
    omit?: StepHelpOmit<ExtArgs> | null
    /**
     * Filter which StepHelp to delete.
     */
    where: StepHelpWhereUniqueInput
  }

  /**
   * StepHelp deleteMany
   */
  export type StepHelpDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StepHelps to delete
     */
    where?: StepHelpWhereInput
    /**
     * Limit how many StepHelps to delete.
     */
    limit?: number
  }

  /**
   * StepHelp without action
   */
  export type StepHelpDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StepHelp
     */
    select?: StepHelpSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StepHelp
     */
    omit?: StepHelpOmit<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    email: 'email',
    password: 'password',
    name: 'name',
    role: 'role',
    status: 'status',
    schoolId: 'schoolId',
    resetToken: 'resetToken',
    resetTokenExpiry: 'resetTokenExpiry',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const SchoolScalarFieldEnum: {
    id: 'id',
    name: 'name',
    schoolId: 'schoolId',
    instructor: 'instructor',
    students: 'students',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SchoolScalarFieldEnum = (typeof SchoolScalarFieldEnum)[keyof typeof SchoolScalarFieldEnum]


  export const ProgramSettingsScalarFieldEnum: {
    id: 'id',
    projectHeader: 'projectHeader',
    principalInvestigator: 'principalInvestigator',
    projectName: 'projectName',
    staffEmail: 'staffEmail',
    organismName: 'organismName',
    orfContactInformation: 'orfContactInformation',
    cloningVector: 'cloningVector',
    sequencePrimer: 'sequencePrimer',
    libraryName: 'libraryName',
    restrictionEnzyme: 'restrictionEnzyme',
    description: 'description',
    welcomeText: 'welcomeText',
    overview: 'overview',
    collectDemographics: 'collectDemographics',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ProgramSettingsScalarFieldEnum = (typeof ProgramSettingsScalarFieldEnum)[keyof typeof ProgramSettingsScalarFieldEnum]


  export const DemographicsScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    academicYear: 'academicYear',
    yearsInProgram: 'yearsInProgram',
    classesTaken: 'classesTaken',
    otherScienceCourses: 'otherScienceCourses',
    age: 'age',
    gender: 'gender',
    ethnicity: 'ethnicity',
    educationLevel: 'educationLevel',
    city: 'city',
    state: 'state',
    country: 'country',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type DemographicsScalarFieldEnum = (typeof DemographicsScalarFieldEnum)[keyof typeof DemographicsScalarFieldEnum]


  export const LoginLogScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    loginTime: 'loginTime',
    ipAddress: 'ipAddress',
    userAgent: 'userAgent',
    success: 'success',
    createdAt: 'createdAt'
  };

  export type LoginLogScalarFieldEnum = (typeof LoginLogScalarFieldEnum)[keyof typeof LoginLogScalarFieldEnum]


  export const AnalysisQuestionScalarFieldEnum: {
    id: 'id',
    step: 'step',
    text: 'text',
    type: 'type',
    options: 'options',
    required: 'required',
    order: 'order',
    conditionalLogic: 'conditionalLogic',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AnalysisQuestionScalarFieldEnum = (typeof AnalysisQuestionScalarFieldEnum)[keyof typeof AnalysisQuestionScalarFieldEnum]


  export const CommonFeedbackScalarFieldEnum: {
    id: 'id',
    questionId: 'questionId',
    title: 'title',
    text: 'text',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CommonFeedbackScalarFieldEnum = (typeof CommonFeedbackScalarFieldEnum)[keyof typeof CommonFeedbackScalarFieldEnum]


  export const UploadedFileScalarFieldEnum: {
    id: 'id',
    filename: 'filename',
    originalName: 'originalName',
    cloneName: 'cloneName',
    size: 'size',
    uploadDate: 'uploadDate',
    status: 'status',
    progress: 'progress',
    analysisData: 'analysisData',
    assignedToId: 'assignedToId',
    uploadedById: 'uploadedById',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UploadedFileScalarFieldEnum = (typeof UploadedFileScalarFieldEnum)[keyof typeof UploadedFileScalarFieldEnum]


  export const CloneDiscussionScalarFieldEnum: {
    id: 'id',
    studentId: 'studentId',
    cloneId: 'cloneId',
    practiceCloneId: 'practiceCloneId',
    title: 'title',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    lastMessageAt: 'lastMessageAt'
  };

  export type CloneDiscussionScalarFieldEnum = (typeof CloneDiscussionScalarFieldEnum)[keyof typeof CloneDiscussionScalarFieldEnum]


  export const DiscussionMessageScalarFieldEnum: {
    id: 'id',
    discussionId: 'discussionId',
    senderId: 'senderId',
    content: 'content',
    messageType: 'messageType',
    readBy: 'readBy',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type DiscussionMessageScalarFieldEnum = (typeof DiscussionMessageScalarFieldEnum)[keyof typeof DiscussionMessageScalarFieldEnum]


  export const MessageScalarFieldEnum: {
    id: 'id',
    subject: 'subject',
    content: 'content',
    messageType: 'messageType',
    isRead: 'isRead',
    senderId: 'senderId',
    recipientId: 'recipientId',
    cloneId: 'cloneId',
    cloneProgress: 'cloneProgress',
    currentStep: 'currentStep',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    isGroupMessage: 'isGroupMessage',
    groupParticipants: 'groupParticipants'
  };

  export type MessageScalarFieldEnum = (typeof MessageScalarFieldEnum)[keyof typeof MessageScalarFieldEnum]


  export const PracticeCloneScalarFieldEnum: {
    id: 'id',
    cloneName: 'cloneName',
    filename: 'filename',
    originalName: 'originalName',
    description: 'description',
    isActive: 'isActive',
    uploadDate: 'uploadDate',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PracticeCloneScalarFieldEnum = (typeof PracticeCloneScalarFieldEnum)[keyof typeof PracticeCloneScalarFieldEnum]


  export const PracticeAnswerScalarFieldEnum: {
    id: 'id',
    practiceCloneId: 'practiceCloneId',
    questionId: 'questionId',
    correctAnswer: 'correctAnswer',
    explanation: 'explanation'
  };

  export type PracticeAnswerScalarFieldEnum = (typeof PracticeAnswerScalarFieldEnum)[keyof typeof PracticeAnswerScalarFieldEnum]


  export const UserPracticeProgressScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    practiceCloneId: 'practiceCloneId',
    progress: 'progress',
    answers: 'answers',
    currentStep: 'currentStep',
    status: 'status',
    lastSaved: 'lastSaved',
    submittedAt: 'submittedAt',
    reviewComments: 'reviewComments',
    reviewScore: 'reviewScore',
    lastReviewed: 'lastReviewed',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserPracticeProgressScalarFieldEnum = (typeof UserPracticeProgressScalarFieldEnum)[keyof typeof UserPracticeProgressScalarFieldEnum]


  export const HelpTopicScalarFieldEnum: {
    id: 'id',
    analysisQuestionId: 'analysisQuestionId',
    title: 'title',
    videoBoxUrl: 'videoBoxUrl',
    helpDocumentUrl: 'helpDocumentUrl',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type HelpTopicScalarFieldEnum = (typeof HelpTopicScalarFieldEnum)[keyof typeof HelpTopicScalarFieldEnum]


  export const StepHelpScalarFieldEnum: {
    id: 'id',
    step: 'step',
    title: 'title',
    description: 'description',
    videoBoxUrl: 'videoBoxUrl',
    helpDocumentUrl: 'helpDocumentUrl',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type StepHelpScalarFieldEnum = (typeof StepHelpScalarFieldEnum)[keyof typeof StepHelpScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: IntFilter<"User"> | number
    email?: StringFilter<"User"> | string
    password?: StringFilter<"User"> | string
    name?: StringFilter<"User"> | string
    role?: StringFilter<"User"> | string
    status?: StringFilter<"User"> | string
    schoolId?: IntNullableFilter<"User"> | number | null
    resetToken?: StringNullableFilter<"User"> | string | null
    resetTokenExpiry?: DateTimeNullableFilter<"User"> | Date | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    school?: XOR<SchoolNullableScalarRelationFilter, SchoolWhereInput> | null
    demographics?: XOR<DemographicsNullableScalarRelationFilter, DemographicsWhereInput> | null
    assignedFiles?: UploadedFileListRelationFilter
    uploadedFiles?: UploadedFileListRelationFilter
    sentMessages?: MessageListRelationFilter
    receivedMessages?: MessageListRelationFilter
    practiceProgress?: UserPracticeProgressListRelationFilter
    loginLogs?: LoginLogListRelationFilter
    discussions?: CloneDiscussionListRelationFilter
    discussionMessagesSent?: DiscussionMessageListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    name?: SortOrder
    role?: SortOrder
    status?: SortOrder
    schoolId?: SortOrderInput | SortOrder
    resetToken?: SortOrderInput | SortOrder
    resetTokenExpiry?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    school?: SchoolOrderByWithRelationInput
    demographics?: DemographicsOrderByWithRelationInput
    assignedFiles?: UploadedFileOrderByRelationAggregateInput
    uploadedFiles?: UploadedFileOrderByRelationAggregateInput
    sentMessages?: MessageOrderByRelationAggregateInput
    receivedMessages?: MessageOrderByRelationAggregateInput
    practiceProgress?: UserPracticeProgressOrderByRelationAggregateInput
    loginLogs?: LoginLogOrderByRelationAggregateInput
    discussions?: CloneDiscussionOrderByRelationAggregateInput
    discussionMessagesSent?: DiscussionMessageOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    email?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    password?: StringFilter<"User"> | string
    name?: StringFilter<"User"> | string
    role?: StringFilter<"User"> | string
    status?: StringFilter<"User"> | string
    schoolId?: IntNullableFilter<"User"> | number | null
    resetToken?: StringNullableFilter<"User"> | string | null
    resetTokenExpiry?: DateTimeNullableFilter<"User"> | Date | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    school?: XOR<SchoolNullableScalarRelationFilter, SchoolWhereInput> | null
    demographics?: XOR<DemographicsNullableScalarRelationFilter, DemographicsWhereInput> | null
    assignedFiles?: UploadedFileListRelationFilter
    uploadedFiles?: UploadedFileListRelationFilter
    sentMessages?: MessageListRelationFilter
    receivedMessages?: MessageListRelationFilter
    practiceProgress?: UserPracticeProgressListRelationFilter
    loginLogs?: LoginLogListRelationFilter
    discussions?: CloneDiscussionListRelationFilter
    discussionMessagesSent?: DiscussionMessageListRelationFilter
  }, "id" | "email">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    name?: SortOrder
    role?: SortOrder
    status?: SortOrder
    schoolId?: SortOrderInput | SortOrder
    resetToken?: SortOrderInput | SortOrder
    resetTokenExpiry?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _avg?: UserAvgOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
    _sum?: UserSumOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"User"> | number
    email?: StringWithAggregatesFilter<"User"> | string
    password?: StringWithAggregatesFilter<"User"> | string
    name?: StringWithAggregatesFilter<"User"> | string
    role?: StringWithAggregatesFilter<"User"> | string
    status?: StringWithAggregatesFilter<"User"> | string
    schoolId?: IntNullableWithAggregatesFilter<"User"> | number | null
    resetToken?: StringNullableWithAggregatesFilter<"User"> | string | null
    resetTokenExpiry?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
  }

  export type SchoolWhereInput = {
    AND?: SchoolWhereInput | SchoolWhereInput[]
    OR?: SchoolWhereInput[]
    NOT?: SchoolWhereInput | SchoolWhereInput[]
    id?: IntFilter<"School"> | number
    name?: StringFilter<"School"> | string
    schoolId?: StringFilter<"School"> | string
    instructor?: StringFilter<"School"> | string
    students?: IntFilter<"School"> | number
    createdAt?: DateTimeFilter<"School"> | Date | string
    updatedAt?: DateTimeFilter<"School"> | Date | string
    users?: UserListRelationFilter
  }

  export type SchoolOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    schoolId?: SortOrder
    instructor?: SortOrder
    students?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    users?: UserOrderByRelationAggregateInput
  }

  export type SchoolWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    schoolId?: string
    AND?: SchoolWhereInput | SchoolWhereInput[]
    OR?: SchoolWhereInput[]
    NOT?: SchoolWhereInput | SchoolWhereInput[]
    name?: StringFilter<"School"> | string
    instructor?: StringFilter<"School"> | string
    students?: IntFilter<"School"> | number
    createdAt?: DateTimeFilter<"School"> | Date | string
    updatedAt?: DateTimeFilter<"School"> | Date | string
    users?: UserListRelationFilter
  }, "id" | "schoolId">

  export type SchoolOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    schoolId?: SortOrder
    instructor?: SortOrder
    students?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SchoolCountOrderByAggregateInput
    _avg?: SchoolAvgOrderByAggregateInput
    _max?: SchoolMaxOrderByAggregateInput
    _min?: SchoolMinOrderByAggregateInput
    _sum?: SchoolSumOrderByAggregateInput
  }

  export type SchoolScalarWhereWithAggregatesInput = {
    AND?: SchoolScalarWhereWithAggregatesInput | SchoolScalarWhereWithAggregatesInput[]
    OR?: SchoolScalarWhereWithAggregatesInput[]
    NOT?: SchoolScalarWhereWithAggregatesInput | SchoolScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"School"> | number
    name?: StringWithAggregatesFilter<"School"> | string
    schoolId?: StringWithAggregatesFilter<"School"> | string
    instructor?: StringWithAggregatesFilter<"School"> | string
    students?: IntWithAggregatesFilter<"School"> | number
    createdAt?: DateTimeWithAggregatesFilter<"School"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"School"> | Date | string
  }

  export type ProgramSettingsWhereInput = {
    AND?: ProgramSettingsWhereInput | ProgramSettingsWhereInput[]
    OR?: ProgramSettingsWhereInput[]
    NOT?: ProgramSettingsWhereInput | ProgramSettingsWhereInput[]
    id?: IntFilter<"ProgramSettings"> | number
    projectHeader?: StringFilter<"ProgramSettings"> | string
    principalInvestigator?: StringNullableFilter<"ProgramSettings"> | string | null
    projectName?: StringNullableFilter<"ProgramSettings"> | string | null
    staffEmail?: StringNullableFilter<"ProgramSettings"> | string | null
    organismName?: StringNullableFilter<"ProgramSettings"> | string | null
    orfContactInformation?: StringNullableFilter<"ProgramSettings"> | string | null
    cloningVector?: StringNullableFilter<"ProgramSettings"> | string | null
    sequencePrimer?: StringNullableFilter<"ProgramSettings"> | string | null
    libraryName?: StringNullableFilter<"ProgramSettings"> | string | null
    restrictionEnzyme?: StringNullableFilter<"ProgramSettings"> | string | null
    description?: StringNullableFilter<"ProgramSettings"> | string | null
    welcomeText?: StringNullableFilter<"ProgramSettings"> | string | null
    overview?: StringNullableFilter<"ProgramSettings"> | string | null
    collectDemographics?: BoolFilter<"ProgramSettings"> | boolean
    createdAt?: DateTimeFilter<"ProgramSettings"> | Date | string
    updatedAt?: DateTimeFilter<"ProgramSettings"> | Date | string
  }

  export type ProgramSettingsOrderByWithRelationInput = {
    id?: SortOrder
    projectHeader?: SortOrder
    principalInvestigator?: SortOrderInput | SortOrder
    projectName?: SortOrderInput | SortOrder
    staffEmail?: SortOrderInput | SortOrder
    organismName?: SortOrderInput | SortOrder
    orfContactInformation?: SortOrderInput | SortOrder
    cloningVector?: SortOrderInput | SortOrder
    sequencePrimer?: SortOrderInput | SortOrder
    libraryName?: SortOrderInput | SortOrder
    restrictionEnzyme?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    welcomeText?: SortOrderInput | SortOrder
    overview?: SortOrderInput | SortOrder
    collectDemographics?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProgramSettingsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ProgramSettingsWhereInput | ProgramSettingsWhereInput[]
    OR?: ProgramSettingsWhereInput[]
    NOT?: ProgramSettingsWhereInput | ProgramSettingsWhereInput[]
    projectHeader?: StringFilter<"ProgramSettings"> | string
    principalInvestigator?: StringNullableFilter<"ProgramSettings"> | string | null
    projectName?: StringNullableFilter<"ProgramSettings"> | string | null
    staffEmail?: StringNullableFilter<"ProgramSettings"> | string | null
    organismName?: StringNullableFilter<"ProgramSettings"> | string | null
    orfContactInformation?: StringNullableFilter<"ProgramSettings"> | string | null
    cloningVector?: StringNullableFilter<"ProgramSettings"> | string | null
    sequencePrimer?: StringNullableFilter<"ProgramSettings"> | string | null
    libraryName?: StringNullableFilter<"ProgramSettings"> | string | null
    restrictionEnzyme?: StringNullableFilter<"ProgramSettings"> | string | null
    description?: StringNullableFilter<"ProgramSettings"> | string | null
    welcomeText?: StringNullableFilter<"ProgramSettings"> | string | null
    overview?: StringNullableFilter<"ProgramSettings"> | string | null
    collectDemographics?: BoolFilter<"ProgramSettings"> | boolean
    createdAt?: DateTimeFilter<"ProgramSettings"> | Date | string
    updatedAt?: DateTimeFilter<"ProgramSettings"> | Date | string
  }, "id">

  export type ProgramSettingsOrderByWithAggregationInput = {
    id?: SortOrder
    projectHeader?: SortOrder
    principalInvestigator?: SortOrderInput | SortOrder
    projectName?: SortOrderInput | SortOrder
    staffEmail?: SortOrderInput | SortOrder
    organismName?: SortOrderInput | SortOrder
    orfContactInformation?: SortOrderInput | SortOrder
    cloningVector?: SortOrderInput | SortOrder
    sequencePrimer?: SortOrderInput | SortOrder
    libraryName?: SortOrderInput | SortOrder
    restrictionEnzyme?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    welcomeText?: SortOrderInput | SortOrder
    overview?: SortOrderInput | SortOrder
    collectDemographics?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ProgramSettingsCountOrderByAggregateInput
    _avg?: ProgramSettingsAvgOrderByAggregateInput
    _max?: ProgramSettingsMaxOrderByAggregateInput
    _min?: ProgramSettingsMinOrderByAggregateInput
    _sum?: ProgramSettingsSumOrderByAggregateInput
  }

  export type ProgramSettingsScalarWhereWithAggregatesInput = {
    AND?: ProgramSettingsScalarWhereWithAggregatesInput | ProgramSettingsScalarWhereWithAggregatesInput[]
    OR?: ProgramSettingsScalarWhereWithAggregatesInput[]
    NOT?: ProgramSettingsScalarWhereWithAggregatesInput | ProgramSettingsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ProgramSettings"> | number
    projectHeader?: StringWithAggregatesFilter<"ProgramSettings"> | string
    principalInvestigator?: StringNullableWithAggregatesFilter<"ProgramSettings"> | string | null
    projectName?: StringNullableWithAggregatesFilter<"ProgramSettings"> | string | null
    staffEmail?: StringNullableWithAggregatesFilter<"ProgramSettings"> | string | null
    organismName?: StringNullableWithAggregatesFilter<"ProgramSettings"> | string | null
    orfContactInformation?: StringNullableWithAggregatesFilter<"ProgramSettings"> | string | null
    cloningVector?: StringNullableWithAggregatesFilter<"ProgramSettings"> | string | null
    sequencePrimer?: StringNullableWithAggregatesFilter<"ProgramSettings"> | string | null
    libraryName?: StringNullableWithAggregatesFilter<"ProgramSettings"> | string | null
    restrictionEnzyme?: StringNullableWithAggregatesFilter<"ProgramSettings"> | string | null
    description?: StringNullableWithAggregatesFilter<"ProgramSettings"> | string | null
    welcomeText?: StringNullableWithAggregatesFilter<"ProgramSettings"> | string | null
    overview?: StringNullableWithAggregatesFilter<"ProgramSettings"> | string | null
    collectDemographics?: BoolWithAggregatesFilter<"ProgramSettings"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"ProgramSettings"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ProgramSettings"> | Date | string
  }

  export type DemographicsWhereInput = {
    AND?: DemographicsWhereInput | DemographicsWhereInput[]
    OR?: DemographicsWhereInput[]
    NOT?: DemographicsWhereInput | DemographicsWhereInput[]
    id?: IntFilter<"Demographics"> | number
    userId?: IntFilter<"Demographics"> | number
    academicYear?: StringNullableFilter<"Demographics"> | string | null
    yearsInProgram?: StringNullableFilter<"Demographics"> | string | null
    classesTaken?: StringNullableFilter<"Demographics"> | string | null
    otherScienceCourses?: StringNullableFilter<"Demographics"> | string | null
    age?: IntNullableFilter<"Demographics"> | number | null
    gender?: StringNullableFilter<"Demographics"> | string | null
    ethnicity?: StringNullableFilter<"Demographics"> | string | null
    educationLevel?: StringNullableFilter<"Demographics"> | string | null
    city?: StringNullableFilter<"Demographics"> | string | null
    state?: StringNullableFilter<"Demographics"> | string | null
    country?: StringNullableFilter<"Demographics"> | string | null
    createdAt?: DateTimeFilter<"Demographics"> | Date | string
    updatedAt?: DateTimeFilter<"Demographics"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type DemographicsOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    academicYear?: SortOrderInput | SortOrder
    yearsInProgram?: SortOrderInput | SortOrder
    classesTaken?: SortOrderInput | SortOrder
    otherScienceCourses?: SortOrderInput | SortOrder
    age?: SortOrderInput | SortOrder
    gender?: SortOrderInput | SortOrder
    ethnicity?: SortOrderInput | SortOrder
    educationLevel?: SortOrderInput | SortOrder
    city?: SortOrderInput | SortOrder
    state?: SortOrderInput | SortOrder
    country?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type DemographicsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    userId?: number
    AND?: DemographicsWhereInput | DemographicsWhereInput[]
    OR?: DemographicsWhereInput[]
    NOT?: DemographicsWhereInput | DemographicsWhereInput[]
    academicYear?: StringNullableFilter<"Demographics"> | string | null
    yearsInProgram?: StringNullableFilter<"Demographics"> | string | null
    classesTaken?: StringNullableFilter<"Demographics"> | string | null
    otherScienceCourses?: StringNullableFilter<"Demographics"> | string | null
    age?: IntNullableFilter<"Demographics"> | number | null
    gender?: StringNullableFilter<"Demographics"> | string | null
    ethnicity?: StringNullableFilter<"Demographics"> | string | null
    educationLevel?: StringNullableFilter<"Demographics"> | string | null
    city?: StringNullableFilter<"Demographics"> | string | null
    state?: StringNullableFilter<"Demographics"> | string | null
    country?: StringNullableFilter<"Demographics"> | string | null
    createdAt?: DateTimeFilter<"Demographics"> | Date | string
    updatedAt?: DateTimeFilter<"Demographics"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "userId">

  export type DemographicsOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    academicYear?: SortOrderInput | SortOrder
    yearsInProgram?: SortOrderInput | SortOrder
    classesTaken?: SortOrderInput | SortOrder
    otherScienceCourses?: SortOrderInput | SortOrder
    age?: SortOrderInput | SortOrder
    gender?: SortOrderInput | SortOrder
    ethnicity?: SortOrderInput | SortOrder
    educationLevel?: SortOrderInput | SortOrder
    city?: SortOrderInput | SortOrder
    state?: SortOrderInput | SortOrder
    country?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: DemographicsCountOrderByAggregateInput
    _avg?: DemographicsAvgOrderByAggregateInput
    _max?: DemographicsMaxOrderByAggregateInput
    _min?: DemographicsMinOrderByAggregateInput
    _sum?: DemographicsSumOrderByAggregateInput
  }

  export type DemographicsScalarWhereWithAggregatesInput = {
    AND?: DemographicsScalarWhereWithAggregatesInput | DemographicsScalarWhereWithAggregatesInput[]
    OR?: DemographicsScalarWhereWithAggregatesInput[]
    NOT?: DemographicsScalarWhereWithAggregatesInput | DemographicsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Demographics"> | number
    userId?: IntWithAggregatesFilter<"Demographics"> | number
    academicYear?: StringNullableWithAggregatesFilter<"Demographics"> | string | null
    yearsInProgram?: StringNullableWithAggregatesFilter<"Demographics"> | string | null
    classesTaken?: StringNullableWithAggregatesFilter<"Demographics"> | string | null
    otherScienceCourses?: StringNullableWithAggregatesFilter<"Demographics"> | string | null
    age?: IntNullableWithAggregatesFilter<"Demographics"> | number | null
    gender?: StringNullableWithAggregatesFilter<"Demographics"> | string | null
    ethnicity?: StringNullableWithAggregatesFilter<"Demographics"> | string | null
    educationLevel?: StringNullableWithAggregatesFilter<"Demographics"> | string | null
    city?: StringNullableWithAggregatesFilter<"Demographics"> | string | null
    state?: StringNullableWithAggregatesFilter<"Demographics"> | string | null
    country?: StringNullableWithAggregatesFilter<"Demographics"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Demographics"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Demographics"> | Date | string
  }

  export type LoginLogWhereInput = {
    AND?: LoginLogWhereInput | LoginLogWhereInput[]
    OR?: LoginLogWhereInput[]
    NOT?: LoginLogWhereInput | LoginLogWhereInput[]
    id?: IntFilter<"LoginLog"> | number
    userId?: IntFilter<"LoginLog"> | number
    loginTime?: DateTimeFilter<"LoginLog"> | Date | string
    ipAddress?: StringNullableFilter<"LoginLog"> | string | null
    userAgent?: StringNullableFilter<"LoginLog"> | string | null
    success?: BoolFilter<"LoginLog"> | boolean
    createdAt?: DateTimeFilter<"LoginLog"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type LoginLogOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    loginTime?: SortOrder
    ipAddress?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    success?: SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type LoginLogWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: LoginLogWhereInput | LoginLogWhereInput[]
    OR?: LoginLogWhereInput[]
    NOT?: LoginLogWhereInput | LoginLogWhereInput[]
    userId?: IntFilter<"LoginLog"> | number
    loginTime?: DateTimeFilter<"LoginLog"> | Date | string
    ipAddress?: StringNullableFilter<"LoginLog"> | string | null
    userAgent?: StringNullableFilter<"LoginLog"> | string | null
    success?: BoolFilter<"LoginLog"> | boolean
    createdAt?: DateTimeFilter<"LoginLog"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type LoginLogOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    loginTime?: SortOrder
    ipAddress?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    success?: SortOrder
    createdAt?: SortOrder
    _count?: LoginLogCountOrderByAggregateInput
    _avg?: LoginLogAvgOrderByAggregateInput
    _max?: LoginLogMaxOrderByAggregateInput
    _min?: LoginLogMinOrderByAggregateInput
    _sum?: LoginLogSumOrderByAggregateInput
  }

  export type LoginLogScalarWhereWithAggregatesInput = {
    AND?: LoginLogScalarWhereWithAggregatesInput | LoginLogScalarWhereWithAggregatesInput[]
    OR?: LoginLogScalarWhereWithAggregatesInput[]
    NOT?: LoginLogScalarWhereWithAggregatesInput | LoginLogScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"LoginLog"> | number
    userId?: IntWithAggregatesFilter<"LoginLog"> | number
    loginTime?: DateTimeWithAggregatesFilter<"LoginLog"> | Date | string
    ipAddress?: StringNullableWithAggregatesFilter<"LoginLog"> | string | null
    userAgent?: StringNullableWithAggregatesFilter<"LoginLog"> | string | null
    success?: BoolWithAggregatesFilter<"LoginLog"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"LoginLog"> | Date | string
  }

  export type AnalysisQuestionWhereInput = {
    AND?: AnalysisQuestionWhereInput | AnalysisQuestionWhereInput[]
    OR?: AnalysisQuestionWhereInput[]
    NOT?: AnalysisQuestionWhereInput | AnalysisQuestionWhereInput[]
    id?: StringFilter<"AnalysisQuestion"> | string
    step?: StringFilter<"AnalysisQuestion"> | string
    text?: StringFilter<"AnalysisQuestion"> | string
    type?: StringFilter<"AnalysisQuestion"> | string
    options?: StringNullableFilter<"AnalysisQuestion"> | string | null
    required?: BoolFilter<"AnalysisQuestion"> | boolean
    order?: IntFilter<"AnalysisQuestion"> | number
    conditionalLogic?: StringNullableFilter<"AnalysisQuestion"> | string | null
    createdAt?: DateTimeFilter<"AnalysisQuestion"> | Date | string
    updatedAt?: DateTimeFilter<"AnalysisQuestion"> | Date | string
    HelpTopic?: HelpTopicListRelationFilter
  }

  export type AnalysisQuestionOrderByWithRelationInput = {
    id?: SortOrder
    step?: SortOrder
    text?: SortOrder
    type?: SortOrder
    options?: SortOrderInput | SortOrder
    required?: SortOrder
    order?: SortOrder
    conditionalLogic?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    HelpTopic?: HelpTopicOrderByRelationAggregateInput
  }

  export type AnalysisQuestionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AnalysisQuestionWhereInput | AnalysisQuestionWhereInput[]
    OR?: AnalysisQuestionWhereInput[]
    NOT?: AnalysisQuestionWhereInput | AnalysisQuestionWhereInput[]
    step?: StringFilter<"AnalysisQuestion"> | string
    text?: StringFilter<"AnalysisQuestion"> | string
    type?: StringFilter<"AnalysisQuestion"> | string
    options?: StringNullableFilter<"AnalysisQuestion"> | string | null
    required?: BoolFilter<"AnalysisQuestion"> | boolean
    order?: IntFilter<"AnalysisQuestion"> | number
    conditionalLogic?: StringNullableFilter<"AnalysisQuestion"> | string | null
    createdAt?: DateTimeFilter<"AnalysisQuestion"> | Date | string
    updatedAt?: DateTimeFilter<"AnalysisQuestion"> | Date | string
    HelpTopic?: HelpTopicListRelationFilter
  }, "id">

  export type AnalysisQuestionOrderByWithAggregationInput = {
    id?: SortOrder
    step?: SortOrder
    text?: SortOrder
    type?: SortOrder
    options?: SortOrderInput | SortOrder
    required?: SortOrder
    order?: SortOrder
    conditionalLogic?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AnalysisQuestionCountOrderByAggregateInput
    _avg?: AnalysisQuestionAvgOrderByAggregateInput
    _max?: AnalysisQuestionMaxOrderByAggregateInput
    _min?: AnalysisQuestionMinOrderByAggregateInput
    _sum?: AnalysisQuestionSumOrderByAggregateInput
  }

  export type AnalysisQuestionScalarWhereWithAggregatesInput = {
    AND?: AnalysisQuestionScalarWhereWithAggregatesInput | AnalysisQuestionScalarWhereWithAggregatesInput[]
    OR?: AnalysisQuestionScalarWhereWithAggregatesInput[]
    NOT?: AnalysisQuestionScalarWhereWithAggregatesInput | AnalysisQuestionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AnalysisQuestion"> | string
    step?: StringWithAggregatesFilter<"AnalysisQuestion"> | string
    text?: StringWithAggregatesFilter<"AnalysisQuestion"> | string
    type?: StringWithAggregatesFilter<"AnalysisQuestion"> | string
    options?: StringNullableWithAggregatesFilter<"AnalysisQuestion"> | string | null
    required?: BoolWithAggregatesFilter<"AnalysisQuestion"> | boolean
    order?: IntWithAggregatesFilter<"AnalysisQuestion"> | number
    conditionalLogic?: StringNullableWithAggregatesFilter<"AnalysisQuestion"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"AnalysisQuestion"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"AnalysisQuestion"> | Date | string
  }

  export type CommonFeedbackWhereInput = {
    AND?: CommonFeedbackWhereInput | CommonFeedbackWhereInput[]
    OR?: CommonFeedbackWhereInput[]
    NOT?: CommonFeedbackWhereInput | CommonFeedbackWhereInput[]
    id?: IntFilter<"CommonFeedback"> | number
    questionId?: StringFilter<"CommonFeedback"> | string
    title?: StringFilter<"CommonFeedback"> | string
    text?: StringFilter<"CommonFeedback"> | string
    isActive?: BoolFilter<"CommonFeedback"> | boolean
    createdAt?: DateTimeFilter<"CommonFeedback"> | Date | string
    updatedAt?: DateTimeFilter<"CommonFeedback"> | Date | string
  }

  export type CommonFeedbackOrderByWithRelationInput = {
    id?: SortOrder
    questionId?: SortOrder
    title?: SortOrder
    text?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CommonFeedbackWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: CommonFeedbackWhereInput | CommonFeedbackWhereInput[]
    OR?: CommonFeedbackWhereInput[]
    NOT?: CommonFeedbackWhereInput | CommonFeedbackWhereInput[]
    questionId?: StringFilter<"CommonFeedback"> | string
    title?: StringFilter<"CommonFeedback"> | string
    text?: StringFilter<"CommonFeedback"> | string
    isActive?: BoolFilter<"CommonFeedback"> | boolean
    createdAt?: DateTimeFilter<"CommonFeedback"> | Date | string
    updatedAt?: DateTimeFilter<"CommonFeedback"> | Date | string
  }, "id">

  export type CommonFeedbackOrderByWithAggregationInput = {
    id?: SortOrder
    questionId?: SortOrder
    title?: SortOrder
    text?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CommonFeedbackCountOrderByAggregateInput
    _avg?: CommonFeedbackAvgOrderByAggregateInput
    _max?: CommonFeedbackMaxOrderByAggregateInput
    _min?: CommonFeedbackMinOrderByAggregateInput
    _sum?: CommonFeedbackSumOrderByAggregateInput
  }

  export type CommonFeedbackScalarWhereWithAggregatesInput = {
    AND?: CommonFeedbackScalarWhereWithAggregatesInput | CommonFeedbackScalarWhereWithAggregatesInput[]
    OR?: CommonFeedbackScalarWhereWithAggregatesInput[]
    NOT?: CommonFeedbackScalarWhereWithAggregatesInput | CommonFeedbackScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"CommonFeedback"> | number
    questionId?: StringWithAggregatesFilter<"CommonFeedback"> | string
    title?: StringWithAggregatesFilter<"CommonFeedback"> | string
    text?: StringWithAggregatesFilter<"CommonFeedback"> | string
    isActive?: BoolWithAggregatesFilter<"CommonFeedback"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"CommonFeedback"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"CommonFeedback"> | Date | string
  }

  export type UploadedFileWhereInput = {
    AND?: UploadedFileWhereInput | UploadedFileWhereInput[]
    OR?: UploadedFileWhereInput[]
    NOT?: UploadedFileWhereInput | UploadedFileWhereInput[]
    id?: IntFilter<"UploadedFile"> | number
    filename?: StringFilter<"UploadedFile"> | string
    originalName?: StringFilter<"UploadedFile"> | string
    cloneName?: StringFilter<"UploadedFile"> | string
    size?: StringFilter<"UploadedFile"> | string
    uploadDate?: StringFilter<"UploadedFile"> | string
    status?: StringFilter<"UploadedFile"> | string
    progress?: IntFilter<"UploadedFile"> | number
    analysisData?: StringNullableFilter<"UploadedFile"> | string | null
    assignedToId?: IntNullableFilter<"UploadedFile"> | number | null
    uploadedById?: IntFilter<"UploadedFile"> | number
    createdAt?: DateTimeFilter<"UploadedFile"> | Date | string
    updatedAt?: DateTimeFilter<"UploadedFile"> | Date | string
    assignedTo?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    uploadedBy?: XOR<UserScalarRelationFilter, UserWhereInput>
    messages?: MessageListRelationFilter
    cloneDiscussions?: CloneDiscussionListRelationFilter
  }

  export type UploadedFileOrderByWithRelationInput = {
    id?: SortOrder
    filename?: SortOrder
    originalName?: SortOrder
    cloneName?: SortOrder
    size?: SortOrder
    uploadDate?: SortOrder
    status?: SortOrder
    progress?: SortOrder
    analysisData?: SortOrderInput | SortOrder
    assignedToId?: SortOrderInput | SortOrder
    uploadedById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    assignedTo?: UserOrderByWithRelationInput
    uploadedBy?: UserOrderByWithRelationInput
    messages?: MessageOrderByRelationAggregateInput
    cloneDiscussions?: CloneDiscussionOrderByRelationAggregateInput
  }

  export type UploadedFileWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: UploadedFileWhereInput | UploadedFileWhereInput[]
    OR?: UploadedFileWhereInput[]
    NOT?: UploadedFileWhereInput | UploadedFileWhereInput[]
    filename?: StringFilter<"UploadedFile"> | string
    originalName?: StringFilter<"UploadedFile"> | string
    cloneName?: StringFilter<"UploadedFile"> | string
    size?: StringFilter<"UploadedFile"> | string
    uploadDate?: StringFilter<"UploadedFile"> | string
    status?: StringFilter<"UploadedFile"> | string
    progress?: IntFilter<"UploadedFile"> | number
    analysisData?: StringNullableFilter<"UploadedFile"> | string | null
    assignedToId?: IntNullableFilter<"UploadedFile"> | number | null
    uploadedById?: IntFilter<"UploadedFile"> | number
    createdAt?: DateTimeFilter<"UploadedFile"> | Date | string
    updatedAt?: DateTimeFilter<"UploadedFile"> | Date | string
    assignedTo?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    uploadedBy?: XOR<UserScalarRelationFilter, UserWhereInput>
    messages?: MessageListRelationFilter
    cloneDiscussions?: CloneDiscussionListRelationFilter
  }, "id">

  export type UploadedFileOrderByWithAggregationInput = {
    id?: SortOrder
    filename?: SortOrder
    originalName?: SortOrder
    cloneName?: SortOrder
    size?: SortOrder
    uploadDate?: SortOrder
    status?: SortOrder
    progress?: SortOrder
    analysisData?: SortOrderInput | SortOrder
    assignedToId?: SortOrderInput | SortOrder
    uploadedById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UploadedFileCountOrderByAggregateInput
    _avg?: UploadedFileAvgOrderByAggregateInput
    _max?: UploadedFileMaxOrderByAggregateInput
    _min?: UploadedFileMinOrderByAggregateInput
    _sum?: UploadedFileSumOrderByAggregateInput
  }

  export type UploadedFileScalarWhereWithAggregatesInput = {
    AND?: UploadedFileScalarWhereWithAggregatesInput | UploadedFileScalarWhereWithAggregatesInput[]
    OR?: UploadedFileScalarWhereWithAggregatesInput[]
    NOT?: UploadedFileScalarWhereWithAggregatesInput | UploadedFileScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"UploadedFile"> | number
    filename?: StringWithAggregatesFilter<"UploadedFile"> | string
    originalName?: StringWithAggregatesFilter<"UploadedFile"> | string
    cloneName?: StringWithAggregatesFilter<"UploadedFile"> | string
    size?: StringWithAggregatesFilter<"UploadedFile"> | string
    uploadDate?: StringWithAggregatesFilter<"UploadedFile"> | string
    status?: StringWithAggregatesFilter<"UploadedFile"> | string
    progress?: IntWithAggregatesFilter<"UploadedFile"> | number
    analysisData?: StringNullableWithAggregatesFilter<"UploadedFile"> | string | null
    assignedToId?: IntNullableWithAggregatesFilter<"UploadedFile"> | number | null
    uploadedById?: IntWithAggregatesFilter<"UploadedFile"> | number
    createdAt?: DateTimeWithAggregatesFilter<"UploadedFile"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"UploadedFile"> | Date | string
  }

  export type CloneDiscussionWhereInput = {
    AND?: CloneDiscussionWhereInput | CloneDiscussionWhereInput[]
    OR?: CloneDiscussionWhereInput[]
    NOT?: CloneDiscussionWhereInput | CloneDiscussionWhereInput[]
    id?: IntFilter<"CloneDiscussion"> | number
    studentId?: IntFilter<"CloneDiscussion"> | number
    cloneId?: IntNullableFilter<"CloneDiscussion"> | number | null
    practiceCloneId?: IntNullableFilter<"CloneDiscussion"> | number | null
    title?: StringFilter<"CloneDiscussion"> | string
    status?: StringFilter<"CloneDiscussion"> | string
    createdAt?: DateTimeFilter<"CloneDiscussion"> | Date | string
    updatedAt?: DateTimeFilter<"CloneDiscussion"> | Date | string
    lastMessageAt?: DateTimeFilter<"CloneDiscussion"> | Date | string
    student?: XOR<UserScalarRelationFilter, UserWhereInput>
    clone?: XOR<UploadedFileNullableScalarRelationFilter, UploadedFileWhereInput> | null
    practiceClone?: XOR<PracticeCloneNullableScalarRelationFilter, PracticeCloneWhereInput> | null
    messages?: DiscussionMessageListRelationFilter
  }

  export type CloneDiscussionOrderByWithRelationInput = {
    id?: SortOrder
    studentId?: SortOrder
    cloneId?: SortOrderInput | SortOrder
    practiceCloneId?: SortOrderInput | SortOrder
    title?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    lastMessageAt?: SortOrder
    student?: UserOrderByWithRelationInput
    clone?: UploadedFileOrderByWithRelationInput
    practiceClone?: PracticeCloneOrderByWithRelationInput
    messages?: DiscussionMessageOrderByRelationAggregateInput
  }

  export type CloneDiscussionWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    studentId_cloneId?: CloneDiscussionStudentIdCloneIdCompoundUniqueInput
    studentId_practiceCloneId?: CloneDiscussionStudentIdPracticeCloneIdCompoundUniqueInput
    AND?: CloneDiscussionWhereInput | CloneDiscussionWhereInput[]
    OR?: CloneDiscussionWhereInput[]
    NOT?: CloneDiscussionWhereInput | CloneDiscussionWhereInput[]
    studentId?: IntFilter<"CloneDiscussion"> | number
    cloneId?: IntNullableFilter<"CloneDiscussion"> | number | null
    practiceCloneId?: IntNullableFilter<"CloneDiscussion"> | number | null
    title?: StringFilter<"CloneDiscussion"> | string
    status?: StringFilter<"CloneDiscussion"> | string
    createdAt?: DateTimeFilter<"CloneDiscussion"> | Date | string
    updatedAt?: DateTimeFilter<"CloneDiscussion"> | Date | string
    lastMessageAt?: DateTimeFilter<"CloneDiscussion"> | Date | string
    student?: XOR<UserScalarRelationFilter, UserWhereInput>
    clone?: XOR<UploadedFileNullableScalarRelationFilter, UploadedFileWhereInput> | null
    practiceClone?: XOR<PracticeCloneNullableScalarRelationFilter, PracticeCloneWhereInput> | null
    messages?: DiscussionMessageListRelationFilter
  }, "id" | "studentId_cloneId" | "studentId_practiceCloneId">

  export type CloneDiscussionOrderByWithAggregationInput = {
    id?: SortOrder
    studentId?: SortOrder
    cloneId?: SortOrderInput | SortOrder
    practiceCloneId?: SortOrderInput | SortOrder
    title?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    lastMessageAt?: SortOrder
    _count?: CloneDiscussionCountOrderByAggregateInput
    _avg?: CloneDiscussionAvgOrderByAggregateInput
    _max?: CloneDiscussionMaxOrderByAggregateInput
    _min?: CloneDiscussionMinOrderByAggregateInput
    _sum?: CloneDiscussionSumOrderByAggregateInput
  }

  export type CloneDiscussionScalarWhereWithAggregatesInput = {
    AND?: CloneDiscussionScalarWhereWithAggregatesInput | CloneDiscussionScalarWhereWithAggregatesInput[]
    OR?: CloneDiscussionScalarWhereWithAggregatesInput[]
    NOT?: CloneDiscussionScalarWhereWithAggregatesInput | CloneDiscussionScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"CloneDiscussion"> | number
    studentId?: IntWithAggregatesFilter<"CloneDiscussion"> | number
    cloneId?: IntNullableWithAggregatesFilter<"CloneDiscussion"> | number | null
    practiceCloneId?: IntNullableWithAggregatesFilter<"CloneDiscussion"> | number | null
    title?: StringWithAggregatesFilter<"CloneDiscussion"> | string
    status?: StringWithAggregatesFilter<"CloneDiscussion"> | string
    createdAt?: DateTimeWithAggregatesFilter<"CloneDiscussion"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"CloneDiscussion"> | Date | string
    lastMessageAt?: DateTimeWithAggregatesFilter<"CloneDiscussion"> | Date | string
  }

  export type DiscussionMessageWhereInput = {
    AND?: DiscussionMessageWhereInput | DiscussionMessageWhereInput[]
    OR?: DiscussionMessageWhereInput[]
    NOT?: DiscussionMessageWhereInput | DiscussionMessageWhereInput[]
    id?: IntFilter<"DiscussionMessage"> | number
    discussionId?: IntFilter<"DiscussionMessage"> | number
    senderId?: IntFilter<"DiscussionMessage"> | number
    content?: StringFilter<"DiscussionMessage"> | string
    messageType?: StringFilter<"DiscussionMessage"> | string
    readBy?: StringNullableFilter<"DiscussionMessage"> | string | null
    createdAt?: DateTimeFilter<"DiscussionMessage"> | Date | string
    updatedAt?: DateTimeFilter<"DiscussionMessage"> | Date | string
    discussion?: XOR<CloneDiscussionScalarRelationFilter, CloneDiscussionWhereInput>
    sender?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type DiscussionMessageOrderByWithRelationInput = {
    id?: SortOrder
    discussionId?: SortOrder
    senderId?: SortOrder
    content?: SortOrder
    messageType?: SortOrder
    readBy?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    discussion?: CloneDiscussionOrderByWithRelationInput
    sender?: UserOrderByWithRelationInput
  }

  export type DiscussionMessageWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: DiscussionMessageWhereInput | DiscussionMessageWhereInput[]
    OR?: DiscussionMessageWhereInput[]
    NOT?: DiscussionMessageWhereInput | DiscussionMessageWhereInput[]
    discussionId?: IntFilter<"DiscussionMessage"> | number
    senderId?: IntFilter<"DiscussionMessage"> | number
    content?: StringFilter<"DiscussionMessage"> | string
    messageType?: StringFilter<"DiscussionMessage"> | string
    readBy?: StringNullableFilter<"DiscussionMessage"> | string | null
    createdAt?: DateTimeFilter<"DiscussionMessage"> | Date | string
    updatedAt?: DateTimeFilter<"DiscussionMessage"> | Date | string
    discussion?: XOR<CloneDiscussionScalarRelationFilter, CloneDiscussionWhereInput>
    sender?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type DiscussionMessageOrderByWithAggregationInput = {
    id?: SortOrder
    discussionId?: SortOrder
    senderId?: SortOrder
    content?: SortOrder
    messageType?: SortOrder
    readBy?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: DiscussionMessageCountOrderByAggregateInput
    _avg?: DiscussionMessageAvgOrderByAggregateInput
    _max?: DiscussionMessageMaxOrderByAggregateInput
    _min?: DiscussionMessageMinOrderByAggregateInput
    _sum?: DiscussionMessageSumOrderByAggregateInput
  }

  export type DiscussionMessageScalarWhereWithAggregatesInput = {
    AND?: DiscussionMessageScalarWhereWithAggregatesInput | DiscussionMessageScalarWhereWithAggregatesInput[]
    OR?: DiscussionMessageScalarWhereWithAggregatesInput[]
    NOT?: DiscussionMessageScalarWhereWithAggregatesInput | DiscussionMessageScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"DiscussionMessage"> | number
    discussionId?: IntWithAggregatesFilter<"DiscussionMessage"> | number
    senderId?: IntWithAggregatesFilter<"DiscussionMessage"> | number
    content?: StringWithAggregatesFilter<"DiscussionMessage"> | string
    messageType?: StringWithAggregatesFilter<"DiscussionMessage"> | string
    readBy?: StringNullableWithAggregatesFilter<"DiscussionMessage"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"DiscussionMessage"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"DiscussionMessage"> | Date | string
  }

  export type MessageWhereInput = {
    AND?: MessageWhereInput | MessageWhereInput[]
    OR?: MessageWhereInput[]
    NOT?: MessageWhereInput | MessageWhereInput[]
    id?: IntFilter<"Message"> | number
    subject?: StringFilter<"Message"> | string
    content?: StringFilter<"Message"> | string
    messageType?: StringFilter<"Message"> | string
    isRead?: BoolFilter<"Message"> | boolean
    senderId?: IntFilter<"Message"> | number
    recipientId?: IntFilter<"Message"> | number
    cloneId?: IntNullableFilter<"Message"> | number | null
    cloneProgress?: IntNullableFilter<"Message"> | number | null
    currentStep?: StringNullableFilter<"Message"> | string | null
    createdAt?: DateTimeFilter<"Message"> | Date | string
    updatedAt?: DateTimeFilter<"Message"> | Date | string
    isGroupMessage?: BoolNullableFilter<"Message"> | boolean | null
    groupParticipants?: StringNullableFilter<"Message"> | string | null
    sender?: XOR<UserScalarRelationFilter, UserWhereInput>
    recipient?: XOR<UserScalarRelationFilter, UserWhereInput>
    clone?: XOR<UploadedFileNullableScalarRelationFilter, UploadedFileWhereInput> | null
  }

  export type MessageOrderByWithRelationInput = {
    id?: SortOrder
    subject?: SortOrder
    content?: SortOrder
    messageType?: SortOrder
    isRead?: SortOrder
    senderId?: SortOrder
    recipientId?: SortOrder
    cloneId?: SortOrderInput | SortOrder
    cloneProgress?: SortOrderInput | SortOrder
    currentStep?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isGroupMessage?: SortOrderInput | SortOrder
    groupParticipants?: SortOrderInput | SortOrder
    sender?: UserOrderByWithRelationInput
    recipient?: UserOrderByWithRelationInput
    clone?: UploadedFileOrderByWithRelationInput
  }

  export type MessageWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: MessageWhereInput | MessageWhereInput[]
    OR?: MessageWhereInput[]
    NOT?: MessageWhereInput | MessageWhereInput[]
    subject?: StringFilter<"Message"> | string
    content?: StringFilter<"Message"> | string
    messageType?: StringFilter<"Message"> | string
    isRead?: BoolFilter<"Message"> | boolean
    senderId?: IntFilter<"Message"> | number
    recipientId?: IntFilter<"Message"> | number
    cloneId?: IntNullableFilter<"Message"> | number | null
    cloneProgress?: IntNullableFilter<"Message"> | number | null
    currentStep?: StringNullableFilter<"Message"> | string | null
    createdAt?: DateTimeFilter<"Message"> | Date | string
    updatedAt?: DateTimeFilter<"Message"> | Date | string
    isGroupMessage?: BoolNullableFilter<"Message"> | boolean | null
    groupParticipants?: StringNullableFilter<"Message"> | string | null
    sender?: XOR<UserScalarRelationFilter, UserWhereInput>
    recipient?: XOR<UserScalarRelationFilter, UserWhereInput>
    clone?: XOR<UploadedFileNullableScalarRelationFilter, UploadedFileWhereInput> | null
  }, "id">

  export type MessageOrderByWithAggregationInput = {
    id?: SortOrder
    subject?: SortOrder
    content?: SortOrder
    messageType?: SortOrder
    isRead?: SortOrder
    senderId?: SortOrder
    recipientId?: SortOrder
    cloneId?: SortOrderInput | SortOrder
    cloneProgress?: SortOrderInput | SortOrder
    currentStep?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isGroupMessage?: SortOrderInput | SortOrder
    groupParticipants?: SortOrderInput | SortOrder
    _count?: MessageCountOrderByAggregateInput
    _avg?: MessageAvgOrderByAggregateInput
    _max?: MessageMaxOrderByAggregateInput
    _min?: MessageMinOrderByAggregateInput
    _sum?: MessageSumOrderByAggregateInput
  }

  export type MessageScalarWhereWithAggregatesInput = {
    AND?: MessageScalarWhereWithAggregatesInput | MessageScalarWhereWithAggregatesInput[]
    OR?: MessageScalarWhereWithAggregatesInput[]
    NOT?: MessageScalarWhereWithAggregatesInput | MessageScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Message"> | number
    subject?: StringWithAggregatesFilter<"Message"> | string
    content?: StringWithAggregatesFilter<"Message"> | string
    messageType?: StringWithAggregatesFilter<"Message"> | string
    isRead?: BoolWithAggregatesFilter<"Message"> | boolean
    senderId?: IntWithAggregatesFilter<"Message"> | number
    recipientId?: IntWithAggregatesFilter<"Message"> | number
    cloneId?: IntNullableWithAggregatesFilter<"Message"> | number | null
    cloneProgress?: IntNullableWithAggregatesFilter<"Message"> | number | null
    currentStep?: StringNullableWithAggregatesFilter<"Message"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Message"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Message"> | Date | string
    isGroupMessage?: BoolNullableWithAggregatesFilter<"Message"> | boolean | null
    groupParticipants?: StringNullableWithAggregatesFilter<"Message"> | string | null
  }

  export type PracticeCloneWhereInput = {
    AND?: PracticeCloneWhereInput | PracticeCloneWhereInput[]
    OR?: PracticeCloneWhereInput[]
    NOT?: PracticeCloneWhereInput | PracticeCloneWhereInput[]
    id?: IntFilter<"PracticeClone"> | number
    cloneName?: StringFilter<"PracticeClone"> | string
    filename?: StringFilter<"PracticeClone"> | string
    originalName?: StringFilter<"PracticeClone"> | string
    description?: StringNullableFilter<"PracticeClone"> | string | null
    isActive?: BoolFilter<"PracticeClone"> | boolean
    uploadDate?: DateTimeFilter<"PracticeClone"> | Date | string
    createdAt?: DateTimeFilter<"PracticeClone"> | Date | string
    updatedAt?: DateTimeFilter<"PracticeClone"> | Date | string
    practiceAnswers?: PracticeAnswerListRelationFilter
    userProgress?: UserPracticeProgressListRelationFilter
    cloneDiscussions?: CloneDiscussionListRelationFilter
  }

  export type PracticeCloneOrderByWithRelationInput = {
    id?: SortOrder
    cloneName?: SortOrder
    filename?: SortOrder
    originalName?: SortOrder
    description?: SortOrderInput | SortOrder
    isActive?: SortOrder
    uploadDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    practiceAnswers?: PracticeAnswerOrderByRelationAggregateInput
    userProgress?: UserPracticeProgressOrderByRelationAggregateInput
    cloneDiscussions?: CloneDiscussionOrderByRelationAggregateInput
  }

  export type PracticeCloneWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: PracticeCloneWhereInput | PracticeCloneWhereInput[]
    OR?: PracticeCloneWhereInput[]
    NOT?: PracticeCloneWhereInput | PracticeCloneWhereInput[]
    cloneName?: StringFilter<"PracticeClone"> | string
    filename?: StringFilter<"PracticeClone"> | string
    originalName?: StringFilter<"PracticeClone"> | string
    description?: StringNullableFilter<"PracticeClone"> | string | null
    isActive?: BoolFilter<"PracticeClone"> | boolean
    uploadDate?: DateTimeFilter<"PracticeClone"> | Date | string
    createdAt?: DateTimeFilter<"PracticeClone"> | Date | string
    updatedAt?: DateTimeFilter<"PracticeClone"> | Date | string
    practiceAnswers?: PracticeAnswerListRelationFilter
    userProgress?: UserPracticeProgressListRelationFilter
    cloneDiscussions?: CloneDiscussionListRelationFilter
  }, "id">

  export type PracticeCloneOrderByWithAggregationInput = {
    id?: SortOrder
    cloneName?: SortOrder
    filename?: SortOrder
    originalName?: SortOrder
    description?: SortOrderInput | SortOrder
    isActive?: SortOrder
    uploadDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PracticeCloneCountOrderByAggregateInput
    _avg?: PracticeCloneAvgOrderByAggregateInput
    _max?: PracticeCloneMaxOrderByAggregateInput
    _min?: PracticeCloneMinOrderByAggregateInput
    _sum?: PracticeCloneSumOrderByAggregateInput
  }

  export type PracticeCloneScalarWhereWithAggregatesInput = {
    AND?: PracticeCloneScalarWhereWithAggregatesInput | PracticeCloneScalarWhereWithAggregatesInput[]
    OR?: PracticeCloneScalarWhereWithAggregatesInput[]
    NOT?: PracticeCloneScalarWhereWithAggregatesInput | PracticeCloneScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"PracticeClone"> | number
    cloneName?: StringWithAggregatesFilter<"PracticeClone"> | string
    filename?: StringWithAggregatesFilter<"PracticeClone"> | string
    originalName?: StringWithAggregatesFilter<"PracticeClone"> | string
    description?: StringNullableWithAggregatesFilter<"PracticeClone"> | string | null
    isActive?: BoolWithAggregatesFilter<"PracticeClone"> | boolean
    uploadDate?: DateTimeWithAggregatesFilter<"PracticeClone"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"PracticeClone"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"PracticeClone"> | Date | string
  }

  export type PracticeAnswerWhereInput = {
    AND?: PracticeAnswerWhereInput | PracticeAnswerWhereInput[]
    OR?: PracticeAnswerWhereInput[]
    NOT?: PracticeAnswerWhereInput | PracticeAnswerWhereInput[]
    id?: StringFilter<"PracticeAnswer"> | string
    practiceCloneId?: IntFilter<"PracticeAnswer"> | number
    questionId?: StringFilter<"PracticeAnswer"> | string
    correctAnswer?: StringFilter<"PracticeAnswer"> | string
    explanation?: StringNullableFilter<"PracticeAnswer"> | string | null
    practiceClone?: XOR<PracticeCloneScalarRelationFilter, PracticeCloneWhereInput>
  }

  export type PracticeAnswerOrderByWithRelationInput = {
    id?: SortOrder
    practiceCloneId?: SortOrder
    questionId?: SortOrder
    correctAnswer?: SortOrder
    explanation?: SortOrderInput | SortOrder
    practiceClone?: PracticeCloneOrderByWithRelationInput
  }

  export type PracticeAnswerWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    practiceCloneId_questionId?: PracticeAnswerPracticeCloneIdQuestionIdCompoundUniqueInput
    AND?: PracticeAnswerWhereInput | PracticeAnswerWhereInput[]
    OR?: PracticeAnswerWhereInput[]
    NOT?: PracticeAnswerWhereInput | PracticeAnswerWhereInput[]
    practiceCloneId?: IntFilter<"PracticeAnswer"> | number
    questionId?: StringFilter<"PracticeAnswer"> | string
    correctAnswer?: StringFilter<"PracticeAnswer"> | string
    explanation?: StringNullableFilter<"PracticeAnswer"> | string | null
    practiceClone?: XOR<PracticeCloneScalarRelationFilter, PracticeCloneWhereInput>
  }, "id" | "practiceCloneId_questionId">

  export type PracticeAnswerOrderByWithAggregationInput = {
    id?: SortOrder
    practiceCloneId?: SortOrder
    questionId?: SortOrder
    correctAnswer?: SortOrder
    explanation?: SortOrderInput | SortOrder
    _count?: PracticeAnswerCountOrderByAggregateInput
    _avg?: PracticeAnswerAvgOrderByAggregateInput
    _max?: PracticeAnswerMaxOrderByAggregateInput
    _min?: PracticeAnswerMinOrderByAggregateInput
    _sum?: PracticeAnswerSumOrderByAggregateInput
  }

  export type PracticeAnswerScalarWhereWithAggregatesInput = {
    AND?: PracticeAnswerScalarWhereWithAggregatesInput | PracticeAnswerScalarWhereWithAggregatesInput[]
    OR?: PracticeAnswerScalarWhereWithAggregatesInput[]
    NOT?: PracticeAnswerScalarWhereWithAggregatesInput | PracticeAnswerScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PracticeAnswer"> | string
    practiceCloneId?: IntWithAggregatesFilter<"PracticeAnswer"> | number
    questionId?: StringWithAggregatesFilter<"PracticeAnswer"> | string
    correctAnswer?: StringWithAggregatesFilter<"PracticeAnswer"> | string
    explanation?: StringNullableWithAggregatesFilter<"PracticeAnswer"> | string | null
  }

  export type UserPracticeProgressWhereInput = {
    AND?: UserPracticeProgressWhereInput | UserPracticeProgressWhereInput[]
    OR?: UserPracticeProgressWhereInput[]
    NOT?: UserPracticeProgressWhereInput | UserPracticeProgressWhereInput[]
    id?: IntFilter<"UserPracticeProgress"> | number
    userId?: IntFilter<"UserPracticeProgress"> | number
    practiceCloneId?: IntFilter<"UserPracticeProgress"> | number
    progress?: IntFilter<"UserPracticeProgress"> | number
    answers?: StringNullableFilter<"UserPracticeProgress"> | string | null
    currentStep?: StringFilter<"UserPracticeProgress"> | string
    status?: StringFilter<"UserPracticeProgress"> | string
    lastSaved?: DateTimeNullableFilter<"UserPracticeProgress"> | Date | string | null
    submittedAt?: DateTimeNullableFilter<"UserPracticeProgress"> | Date | string | null
    reviewComments?: StringNullableFilter<"UserPracticeProgress"> | string | null
    reviewScore?: IntNullableFilter<"UserPracticeProgress"> | number | null
    lastReviewed?: DateTimeNullableFilter<"UserPracticeProgress"> | Date | string | null
    createdAt?: DateTimeFilter<"UserPracticeProgress"> | Date | string
    updatedAt?: DateTimeFilter<"UserPracticeProgress"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    practiceClone?: XOR<PracticeCloneScalarRelationFilter, PracticeCloneWhereInput>
  }

  export type UserPracticeProgressOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    practiceCloneId?: SortOrder
    progress?: SortOrder
    answers?: SortOrderInput | SortOrder
    currentStep?: SortOrder
    status?: SortOrder
    lastSaved?: SortOrderInput | SortOrder
    submittedAt?: SortOrderInput | SortOrder
    reviewComments?: SortOrderInput | SortOrder
    reviewScore?: SortOrderInput | SortOrder
    lastReviewed?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    practiceClone?: PracticeCloneOrderByWithRelationInput
  }

  export type UserPracticeProgressWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    userId_practiceCloneId?: UserPracticeProgressUserIdPracticeCloneIdCompoundUniqueInput
    AND?: UserPracticeProgressWhereInput | UserPracticeProgressWhereInput[]
    OR?: UserPracticeProgressWhereInput[]
    NOT?: UserPracticeProgressWhereInput | UserPracticeProgressWhereInput[]
    userId?: IntFilter<"UserPracticeProgress"> | number
    practiceCloneId?: IntFilter<"UserPracticeProgress"> | number
    progress?: IntFilter<"UserPracticeProgress"> | number
    answers?: StringNullableFilter<"UserPracticeProgress"> | string | null
    currentStep?: StringFilter<"UserPracticeProgress"> | string
    status?: StringFilter<"UserPracticeProgress"> | string
    lastSaved?: DateTimeNullableFilter<"UserPracticeProgress"> | Date | string | null
    submittedAt?: DateTimeNullableFilter<"UserPracticeProgress"> | Date | string | null
    reviewComments?: StringNullableFilter<"UserPracticeProgress"> | string | null
    reviewScore?: IntNullableFilter<"UserPracticeProgress"> | number | null
    lastReviewed?: DateTimeNullableFilter<"UserPracticeProgress"> | Date | string | null
    createdAt?: DateTimeFilter<"UserPracticeProgress"> | Date | string
    updatedAt?: DateTimeFilter<"UserPracticeProgress"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    practiceClone?: XOR<PracticeCloneScalarRelationFilter, PracticeCloneWhereInput>
  }, "id" | "userId_practiceCloneId">

  export type UserPracticeProgressOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    practiceCloneId?: SortOrder
    progress?: SortOrder
    answers?: SortOrderInput | SortOrder
    currentStep?: SortOrder
    status?: SortOrder
    lastSaved?: SortOrderInput | SortOrder
    submittedAt?: SortOrderInput | SortOrder
    reviewComments?: SortOrderInput | SortOrder
    reviewScore?: SortOrderInput | SortOrder
    lastReviewed?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserPracticeProgressCountOrderByAggregateInput
    _avg?: UserPracticeProgressAvgOrderByAggregateInput
    _max?: UserPracticeProgressMaxOrderByAggregateInput
    _min?: UserPracticeProgressMinOrderByAggregateInput
    _sum?: UserPracticeProgressSumOrderByAggregateInput
  }

  export type UserPracticeProgressScalarWhereWithAggregatesInput = {
    AND?: UserPracticeProgressScalarWhereWithAggregatesInput | UserPracticeProgressScalarWhereWithAggregatesInput[]
    OR?: UserPracticeProgressScalarWhereWithAggregatesInput[]
    NOT?: UserPracticeProgressScalarWhereWithAggregatesInput | UserPracticeProgressScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"UserPracticeProgress"> | number
    userId?: IntWithAggregatesFilter<"UserPracticeProgress"> | number
    practiceCloneId?: IntWithAggregatesFilter<"UserPracticeProgress"> | number
    progress?: IntWithAggregatesFilter<"UserPracticeProgress"> | number
    answers?: StringNullableWithAggregatesFilter<"UserPracticeProgress"> | string | null
    currentStep?: StringWithAggregatesFilter<"UserPracticeProgress"> | string
    status?: StringWithAggregatesFilter<"UserPracticeProgress"> | string
    lastSaved?: DateTimeNullableWithAggregatesFilter<"UserPracticeProgress"> | Date | string | null
    submittedAt?: DateTimeNullableWithAggregatesFilter<"UserPracticeProgress"> | Date | string | null
    reviewComments?: StringNullableWithAggregatesFilter<"UserPracticeProgress"> | string | null
    reviewScore?: IntNullableWithAggregatesFilter<"UserPracticeProgress"> | number | null
    lastReviewed?: DateTimeNullableWithAggregatesFilter<"UserPracticeProgress"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"UserPracticeProgress"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"UserPracticeProgress"> | Date | string
  }

  export type HelpTopicWhereInput = {
    AND?: HelpTopicWhereInput | HelpTopicWhereInput[]
    OR?: HelpTopicWhereInput[]
    NOT?: HelpTopicWhereInput | HelpTopicWhereInput[]
    id?: StringFilter<"HelpTopic"> | string
    analysisQuestionId?: StringFilter<"HelpTopic"> | string
    title?: StringFilter<"HelpTopic"> | string
    videoBoxUrl?: StringFilter<"HelpTopic"> | string
    helpDocumentUrl?: StringFilter<"HelpTopic"> | string
    isActive?: BoolFilter<"HelpTopic"> | boolean
    createdAt?: DateTimeFilter<"HelpTopic"> | Date | string
    updatedAt?: DateTimeFilter<"HelpTopic"> | Date | string
    analysisQuestion?: XOR<AnalysisQuestionScalarRelationFilter, AnalysisQuestionWhereInput>
  }

  export type HelpTopicOrderByWithRelationInput = {
    id?: SortOrder
    analysisQuestionId?: SortOrder
    title?: SortOrder
    videoBoxUrl?: SortOrder
    helpDocumentUrl?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    analysisQuestion?: AnalysisQuestionOrderByWithRelationInput
  }

  export type HelpTopicWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: HelpTopicWhereInput | HelpTopicWhereInput[]
    OR?: HelpTopicWhereInput[]
    NOT?: HelpTopicWhereInput | HelpTopicWhereInput[]
    analysisQuestionId?: StringFilter<"HelpTopic"> | string
    title?: StringFilter<"HelpTopic"> | string
    videoBoxUrl?: StringFilter<"HelpTopic"> | string
    helpDocumentUrl?: StringFilter<"HelpTopic"> | string
    isActive?: BoolFilter<"HelpTopic"> | boolean
    createdAt?: DateTimeFilter<"HelpTopic"> | Date | string
    updatedAt?: DateTimeFilter<"HelpTopic"> | Date | string
    analysisQuestion?: XOR<AnalysisQuestionScalarRelationFilter, AnalysisQuestionWhereInput>
  }, "id">

  export type HelpTopicOrderByWithAggregationInput = {
    id?: SortOrder
    analysisQuestionId?: SortOrder
    title?: SortOrder
    videoBoxUrl?: SortOrder
    helpDocumentUrl?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: HelpTopicCountOrderByAggregateInput
    _max?: HelpTopicMaxOrderByAggregateInput
    _min?: HelpTopicMinOrderByAggregateInput
  }

  export type HelpTopicScalarWhereWithAggregatesInput = {
    AND?: HelpTopicScalarWhereWithAggregatesInput | HelpTopicScalarWhereWithAggregatesInput[]
    OR?: HelpTopicScalarWhereWithAggregatesInput[]
    NOT?: HelpTopicScalarWhereWithAggregatesInput | HelpTopicScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"HelpTopic"> | string
    analysisQuestionId?: StringWithAggregatesFilter<"HelpTopic"> | string
    title?: StringWithAggregatesFilter<"HelpTopic"> | string
    videoBoxUrl?: StringWithAggregatesFilter<"HelpTopic"> | string
    helpDocumentUrl?: StringWithAggregatesFilter<"HelpTopic"> | string
    isActive?: BoolWithAggregatesFilter<"HelpTopic"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"HelpTopic"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"HelpTopic"> | Date | string
  }

  export type StepHelpWhereInput = {
    AND?: StepHelpWhereInput | StepHelpWhereInput[]
    OR?: StepHelpWhereInput[]
    NOT?: StepHelpWhereInput | StepHelpWhereInput[]
    id?: StringFilter<"StepHelp"> | string
    step?: StringFilter<"StepHelp"> | string
    title?: StringFilter<"StepHelp"> | string
    description?: StringNullableFilter<"StepHelp"> | string | null
    videoBoxUrl?: StringFilter<"StepHelp"> | string
    helpDocumentUrl?: StringFilter<"StepHelp"> | string
    isActive?: BoolFilter<"StepHelp"> | boolean
    createdAt?: DateTimeFilter<"StepHelp"> | Date | string
    updatedAt?: DateTimeFilter<"StepHelp"> | Date | string
  }

  export type StepHelpOrderByWithRelationInput = {
    id?: SortOrder
    step?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    videoBoxUrl?: SortOrder
    helpDocumentUrl?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StepHelpWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    step?: string
    AND?: StepHelpWhereInput | StepHelpWhereInput[]
    OR?: StepHelpWhereInput[]
    NOT?: StepHelpWhereInput | StepHelpWhereInput[]
    title?: StringFilter<"StepHelp"> | string
    description?: StringNullableFilter<"StepHelp"> | string | null
    videoBoxUrl?: StringFilter<"StepHelp"> | string
    helpDocumentUrl?: StringFilter<"StepHelp"> | string
    isActive?: BoolFilter<"StepHelp"> | boolean
    createdAt?: DateTimeFilter<"StepHelp"> | Date | string
    updatedAt?: DateTimeFilter<"StepHelp"> | Date | string
  }, "id" | "step">

  export type StepHelpOrderByWithAggregationInput = {
    id?: SortOrder
    step?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    videoBoxUrl?: SortOrder
    helpDocumentUrl?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: StepHelpCountOrderByAggregateInput
    _max?: StepHelpMaxOrderByAggregateInput
    _min?: StepHelpMinOrderByAggregateInput
  }

  export type StepHelpScalarWhereWithAggregatesInput = {
    AND?: StepHelpScalarWhereWithAggregatesInput | StepHelpScalarWhereWithAggregatesInput[]
    OR?: StepHelpScalarWhereWithAggregatesInput[]
    NOT?: StepHelpScalarWhereWithAggregatesInput | StepHelpScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"StepHelp"> | string
    step?: StringWithAggregatesFilter<"StepHelp"> | string
    title?: StringWithAggregatesFilter<"StepHelp"> | string
    description?: StringNullableWithAggregatesFilter<"StepHelp"> | string | null
    videoBoxUrl?: StringWithAggregatesFilter<"StepHelp"> | string
    helpDocumentUrl?: StringWithAggregatesFilter<"StepHelp"> | string
    isActive?: BoolWithAggregatesFilter<"StepHelp"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"StepHelp"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"StepHelp"> | Date | string
  }

  export type UserCreateInput = {
    email: string
    password: string
    name: string
    role: string
    status?: string
    resetToken?: string | null
    resetTokenExpiry?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    school?: SchoolCreateNestedOneWithoutUsersInput
    demographics?: DemographicsCreateNestedOneWithoutUserInput
    assignedFiles?: UploadedFileCreateNestedManyWithoutAssignedToInput
    uploadedFiles?: UploadedFileCreateNestedManyWithoutUploadedByInput
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    receivedMessages?: MessageCreateNestedManyWithoutRecipientInput
    practiceProgress?: UserPracticeProgressCreateNestedManyWithoutUserInput
    loginLogs?: LoginLogCreateNestedManyWithoutUserInput
    discussions?: CloneDiscussionCreateNestedManyWithoutStudentInput
    discussionMessagesSent?: DiscussionMessageCreateNestedManyWithoutSenderInput
  }

  export type UserUncheckedCreateInput = {
    id?: number
    email: string
    password: string
    name: string
    role: string
    status?: string
    schoolId?: number | null
    resetToken?: string | null
    resetTokenExpiry?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    demographics?: DemographicsUncheckedCreateNestedOneWithoutUserInput
    assignedFiles?: UploadedFileUncheckedCreateNestedManyWithoutAssignedToInput
    uploadedFiles?: UploadedFileUncheckedCreateNestedManyWithoutUploadedByInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    receivedMessages?: MessageUncheckedCreateNestedManyWithoutRecipientInput
    practiceProgress?: UserPracticeProgressUncheckedCreateNestedManyWithoutUserInput
    loginLogs?: LoginLogUncheckedCreateNestedManyWithoutUserInput
    discussions?: CloneDiscussionUncheckedCreateNestedManyWithoutStudentInput
    discussionMessagesSent?: DiscussionMessageUncheckedCreateNestedManyWithoutSenderInput
  }

  export type UserUpdateInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    school?: SchoolUpdateOneWithoutUsersNestedInput
    demographics?: DemographicsUpdateOneWithoutUserNestedInput
    assignedFiles?: UploadedFileUpdateManyWithoutAssignedToNestedInput
    uploadedFiles?: UploadedFileUpdateManyWithoutUploadedByNestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    receivedMessages?: MessageUpdateManyWithoutRecipientNestedInput
    practiceProgress?: UserPracticeProgressUpdateManyWithoutUserNestedInput
    loginLogs?: LoginLogUpdateManyWithoutUserNestedInput
    discussions?: CloneDiscussionUpdateManyWithoutStudentNestedInput
    discussionMessagesSent?: DiscussionMessageUpdateManyWithoutSenderNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    schoolId?: NullableIntFieldUpdateOperationsInput | number | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    demographics?: DemographicsUncheckedUpdateOneWithoutUserNestedInput
    assignedFiles?: UploadedFileUncheckedUpdateManyWithoutAssignedToNestedInput
    uploadedFiles?: UploadedFileUncheckedUpdateManyWithoutUploadedByNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    receivedMessages?: MessageUncheckedUpdateManyWithoutRecipientNestedInput
    practiceProgress?: UserPracticeProgressUncheckedUpdateManyWithoutUserNestedInput
    loginLogs?: LoginLogUncheckedUpdateManyWithoutUserNestedInput
    discussions?: CloneDiscussionUncheckedUpdateManyWithoutStudentNestedInput
    discussionMessagesSent?: DiscussionMessageUncheckedUpdateManyWithoutSenderNestedInput
  }

  export type UserCreateManyInput = {
    id?: number
    email: string
    password: string
    name: string
    role: string
    status?: string
    schoolId?: number | null
    resetToken?: string | null
    resetTokenExpiry?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUpdateManyMutationInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    schoolId?: NullableIntFieldUpdateOperationsInput | number | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SchoolCreateInput = {
    name: string
    schoolId: string
    instructor: string
    students?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutSchoolInput
  }

  export type SchoolUncheckedCreateInput = {
    id?: number
    name: string
    schoolId: string
    instructor: string
    students?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutSchoolInput
  }

  export type SchoolUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    schoolId?: StringFieldUpdateOperationsInput | string
    instructor?: StringFieldUpdateOperationsInput | string
    students?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutSchoolNestedInput
  }

  export type SchoolUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    schoolId?: StringFieldUpdateOperationsInput | string
    instructor?: StringFieldUpdateOperationsInput | string
    students?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutSchoolNestedInput
  }

  export type SchoolCreateManyInput = {
    id?: number
    name: string
    schoolId: string
    instructor: string
    students?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SchoolUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    schoolId?: StringFieldUpdateOperationsInput | string
    instructor?: StringFieldUpdateOperationsInput | string
    students?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SchoolUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    schoolId?: StringFieldUpdateOperationsInput | string
    instructor?: StringFieldUpdateOperationsInput | string
    students?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProgramSettingsCreateInput = {
    projectHeader?: string
    principalInvestigator?: string | null
    projectName?: string | null
    staffEmail?: string | null
    organismName?: string | null
    orfContactInformation?: string | null
    cloningVector?: string | null
    sequencePrimer?: string | null
    libraryName?: string | null
    restrictionEnzyme?: string | null
    description?: string | null
    welcomeText?: string | null
    overview?: string | null
    collectDemographics?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProgramSettingsUncheckedCreateInput = {
    id?: number
    projectHeader?: string
    principalInvestigator?: string | null
    projectName?: string | null
    staffEmail?: string | null
    organismName?: string | null
    orfContactInformation?: string | null
    cloningVector?: string | null
    sequencePrimer?: string | null
    libraryName?: string | null
    restrictionEnzyme?: string | null
    description?: string | null
    welcomeText?: string | null
    overview?: string | null
    collectDemographics?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProgramSettingsUpdateInput = {
    projectHeader?: StringFieldUpdateOperationsInput | string
    principalInvestigator?: NullableStringFieldUpdateOperationsInput | string | null
    projectName?: NullableStringFieldUpdateOperationsInput | string | null
    staffEmail?: NullableStringFieldUpdateOperationsInput | string | null
    organismName?: NullableStringFieldUpdateOperationsInput | string | null
    orfContactInformation?: NullableStringFieldUpdateOperationsInput | string | null
    cloningVector?: NullableStringFieldUpdateOperationsInput | string | null
    sequencePrimer?: NullableStringFieldUpdateOperationsInput | string | null
    libraryName?: NullableStringFieldUpdateOperationsInput | string | null
    restrictionEnzyme?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    welcomeText?: NullableStringFieldUpdateOperationsInput | string | null
    overview?: NullableStringFieldUpdateOperationsInput | string | null
    collectDemographics?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProgramSettingsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    projectHeader?: StringFieldUpdateOperationsInput | string
    principalInvestigator?: NullableStringFieldUpdateOperationsInput | string | null
    projectName?: NullableStringFieldUpdateOperationsInput | string | null
    staffEmail?: NullableStringFieldUpdateOperationsInput | string | null
    organismName?: NullableStringFieldUpdateOperationsInput | string | null
    orfContactInformation?: NullableStringFieldUpdateOperationsInput | string | null
    cloningVector?: NullableStringFieldUpdateOperationsInput | string | null
    sequencePrimer?: NullableStringFieldUpdateOperationsInput | string | null
    libraryName?: NullableStringFieldUpdateOperationsInput | string | null
    restrictionEnzyme?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    welcomeText?: NullableStringFieldUpdateOperationsInput | string | null
    overview?: NullableStringFieldUpdateOperationsInput | string | null
    collectDemographics?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProgramSettingsCreateManyInput = {
    id?: number
    projectHeader?: string
    principalInvestigator?: string | null
    projectName?: string | null
    staffEmail?: string | null
    organismName?: string | null
    orfContactInformation?: string | null
    cloningVector?: string | null
    sequencePrimer?: string | null
    libraryName?: string | null
    restrictionEnzyme?: string | null
    description?: string | null
    welcomeText?: string | null
    overview?: string | null
    collectDemographics?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProgramSettingsUpdateManyMutationInput = {
    projectHeader?: StringFieldUpdateOperationsInput | string
    principalInvestigator?: NullableStringFieldUpdateOperationsInput | string | null
    projectName?: NullableStringFieldUpdateOperationsInput | string | null
    staffEmail?: NullableStringFieldUpdateOperationsInput | string | null
    organismName?: NullableStringFieldUpdateOperationsInput | string | null
    orfContactInformation?: NullableStringFieldUpdateOperationsInput | string | null
    cloningVector?: NullableStringFieldUpdateOperationsInput | string | null
    sequencePrimer?: NullableStringFieldUpdateOperationsInput | string | null
    libraryName?: NullableStringFieldUpdateOperationsInput | string | null
    restrictionEnzyme?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    welcomeText?: NullableStringFieldUpdateOperationsInput | string | null
    overview?: NullableStringFieldUpdateOperationsInput | string | null
    collectDemographics?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProgramSettingsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    projectHeader?: StringFieldUpdateOperationsInput | string
    principalInvestigator?: NullableStringFieldUpdateOperationsInput | string | null
    projectName?: NullableStringFieldUpdateOperationsInput | string | null
    staffEmail?: NullableStringFieldUpdateOperationsInput | string | null
    organismName?: NullableStringFieldUpdateOperationsInput | string | null
    orfContactInformation?: NullableStringFieldUpdateOperationsInput | string | null
    cloningVector?: NullableStringFieldUpdateOperationsInput | string | null
    sequencePrimer?: NullableStringFieldUpdateOperationsInput | string | null
    libraryName?: NullableStringFieldUpdateOperationsInput | string | null
    restrictionEnzyme?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    welcomeText?: NullableStringFieldUpdateOperationsInput | string | null
    overview?: NullableStringFieldUpdateOperationsInput | string | null
    collectDemographics?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DemographicsCreateInput = {
    academicYear?: string | null
    yearsInProgram?: string | null
    classesTaken?: string | null
    otherScienceCourses?: string | null
    age?: number | null
    gender?: string | null
    ethnicity?: string | null
    educationLevel?: string | null
    city?: string | null
    state?: string | null
    country?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutDemographicsInput
  }

  export type DemographicsUncheckedCreateInput = {
    id?: number
    userId: number
    academicYear?: string | null
    yearsInProgram?: string | null
    classesTaken?: string | null
    otherScienceCourses?: string | null
    age?: number | null
    gender?: string | null
    ethnicity?: string | null
    educationLevel?: string | null
    city?: string | null
    state?: string | null
    country?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DemographicsUpdateInput = {
    academicYear?: NullableStringFieldUpdateOperationsInput | string | null
    yearsInProgram?: NullableStringFieldUpdateOperationsInput | string | null
    classesTaken?: NullableStringFieldUpdateOperationsInput | string | null
    otherScienceCourses?: NullableStringFieldUpdateOperationsInput | string | null
    age?: NullableIntFieldUpdateOperationsInput | number | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    ethnicity?: NullableStringFieldUpdateOperationsInput | string | null
    educationLevel?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutDemographicsNestedInput
  }

  export type DemographicsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    academicYear?: NullableStringFieldUpdateOperationsInput | string | null
    yearsInProgram?: NullableStringFieldUpdateOperationsInput | string | null
    classesTaken?: NullableStringFieldUpdateOperationsInput | string | null
    otherScienceCourses?: NullableStringFieldUpdateOperationsInput | string | null
    age?: NullableIntFieldUpdateOperationsInput | number | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    ethnicity?: NullableStringFieldUpdateOperationsInput | string | null
    educationLevel?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DemographicsCreateManyInput = {
    id?: number
    userId: number
    academicYear?: string | null
    yearsInProgram?: string | null
    classesTaken?: string | null
    otherScienceCourses?: string | null
    age?: number | null
    gender?: string | null
    ethnicity?: string | null
    educationLevel?: string | null
    city?: string | null
    state?: string | null
    country?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DemographicsUpdateManyMutationInput = {
    academicYear?: NullableStringFieldUpdateOperationsInput | string | null
    yearsInProgram?: NullableStringFieldUpdateOperationsInput | string | null
    classesTaken?: NullableStringFieldUpdateOperationsInput | string | null
    otherScienceCourses?: NullableStringFieldUpdateOperationsInput | string | null
    age?: NullableIntFieldUpdateOperationsInput | number | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    ethnicity?: NullableStringFieldUpdateOperationsInput | string | null
    educationLevel?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DemographicsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    academicYear?: NullableStringFieldUpdateOperationsInput | string | null
    yearsInProgram?: NullableStringFieldUpdateOperationsInput | string | null
    classesTaken?: NullableStringFieldUpdateOperationsInput | string | null
    otherScienceCourses?: NullableStringFieldUpdateOperationsInput | string | null
    age?: NullableIntFieldUpdateOperationsInput | number | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    ethnicity?: NullableStringFieldUpdateOperationsInput | string | null
    educationLevel?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LoginLogCreateInput = {
    loginTime?: Date | string
    ipAddress?: string | null
    userAgent?: string | null
    success?: boolean
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutLoginLogsInput
  }

  export type LoginLogUncheckedCreateInput = {
    id?: number
    userId: number
    loginTime?: Date | string
    ipAddress?: string | null
    userAgent?: string | null
    success?: boolean
    createdAt?: Date | string
  }

  export type LoginLogUpdateInput = {
    loginTime?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    success?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutLoginLogsNestedInput
  }

  export type LoginLogUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    loginTime?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    success?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LoginLogCreateManyInput = {
    id?: number
    userId: number
    loginTime?: Date | string
    ipAddress?: string | null
    userAgent?: string | null
    success?: boolean
    createdAt?: Date | string
  }

  export type LoginLogUpdateManyMutationInput = {
    loginTime?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    success?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LoginLogUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    loginTime?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    success?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AnalysisQuestionCreateInput = {
    id?: string
    step: string
    text: string
    type: string
    options?: string | null
    required?: boolean
    order?: number
    conditionalLogic?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    HelpTopic?: HelpTopicCreateNestedManyWithoutAnalysisQuestionInput
  }

  export type AnalysisQuestionUncheckedCreateInput = {
    id?: string
    step: string
    text: string
    type: string
    options?: string | null
    required?: boolean
    order?: number
    conditionalLogic?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    HelpTopic?: HelpTopicUncheckedCreateNestedManyWithoutAnalysisQuestionInput
  }

  export type AnalysisQuestionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    step?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    options?: NullableStringFieldUpdateOperationsInput | string | null
    required?: BoolFieldUpdateOperationsInput | boolean
    order?: IntFieldUpdateOperationsInput | number
    conditionalLogic?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    HelpTopic?: HelpTopicUpdateManyWithoutAnalysisQuestionNestedInput
  }

  export type AnalysisQuestionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    step?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    options?: NullableStringFieldUpdateOperationsInput | string | null
    required?: BoolFieldUpdateOperationsInput | boolean
    order?: IntFieldUpdateOperationsInput | number
    conditionalLogic?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    HelpTopic?: HelpTopicUncheckedUpdateManyWithoutAnalysisQuestionNestedInput
  }

  export type AnalysisQuestionCreateManyInput = {
    id?: string
    step: string
    text: string
    type: string
    options?: string | null
    required?: boolean
    order?: number
    conditionalLogic?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AnalysisQuestionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    step?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    options?: NullableStringFieldUpdateOperationsInput | string | null
    required?: BoolFieldUpdateOperationsInput | boolean
    order?: IntFieldUpdateOperationsInput | number
    conditionalLogic?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AnalysisQuestionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    step?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    options?: NullableStringFieldUpdateOperationsInput | string | null
    required?: BoolFieldUpdateOperationsInput | boolean
    order?: IntFieldUpdateOperationsInput | number
    conditionalLogic?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommonFeedbackCreateInput = {
    questionId: string
    title: string
    text: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CommonFeedbackUncheckedCreateInput = {
    id?: number
    questionId: string
    title: string
    text: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CommonFeedbackUpdateInput = {
    questionId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommonFeedbackUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    questionId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommonFeedbackCreateManyInput = {
    id?: number
    questionId: string
    title: string
    text: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CommonFeedbackUpdateManyMutationInput = {
    questionId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommonFeedbackUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    questionId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UploadedFileCreateInput = {
    filename: string
    originalName: string
    cloneName: string
    size: string
    uploadDate: string
    status?: string
    progress?: number
    analysisData?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    assignedTo?: UserCreateNestedOneWithoutAssignedFilesInput
    uploadedBy: UserCreateNestedOneWithoutUploadedFilesInput
    messages?: MessageCreateNestedManyWithoutCloneInput
    cloneDiscussions?: CloneDiscussionCreateNestedManyWithoutCloneInput
  }

  export type UploadedFileUncheckedCreateInput = {
    id?: number
    filename: string
    originalName: string
    cloneName: string
    size: string
    uploadDate: string
    status?: string
    progress?: number
    analysisData?: string | null
    assignedToId?: number | null
    uploadedById: number
    createdAt?: Date | string
    updatedAt?: Date | string
    messages?: MessageUncheckedCreateNestedManyWithoutCloneInput
    cloneDiscussions?: CloneDiscussionUncheckedCreateNestedManyWithoutCloneInput
  }

  export type UploadedFileUpdateInput = {
    filename?: StringFieldUpdateOperationsInput | string
    originalName?: StringFieldUpdateOperationsInput | string
    cloneName?: StringFieldUpdateOperationsInput | string
    size?: StringFieldUpdateOperationsInput | string
    uploadDate?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    progress?: IntFieldUpdateOperationsInput | number
    analysisData?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedTo?: UserUpdateOneWithoutAssignedFilesNestedInput
    uploadedBy?: UserUpdateOneRequiredWithoutUploadedFilesNestedInput
    messages?: MessageUpdateManyWithoutCloneNestedInput
    cloneDiscussions?: CloneDiscussionUpdateManyWithoutCloneNestedInput
  }

  export type UploadedFileUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    filename?: StringFieldUpdateOperationsInput | string
    originalName?: StringFieldUpdateOperationsInput | string
    cloneName?: StringFieldUpdateOperationsInput | string
    size?: StringFieldUpdateOperationsInput | string
    uploadDate?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    progress?: IntFieldUpdateOperationsInput | number
    analysisData?: NullableStringFieldUpdateOperationsInput | string | null
    assignedToId?: NullableIntFieldUpdateOperationsInput | number | null
    uploadedById?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    messages?: MessageUncheckedUpdateManyWithoutCloneNestedInput
    cloneDiscussions?: CloneDiscussionUncheckedUpdateManyWithoutCloneNestedInput
  }

  export type UploadedFileCreateManyInput = {
    id?: number
    filename: string
    originalName: string
    cloneName: string
    size: string
    uploadDate: string
    status?: string
    progress?: number
    analysisData?: string | null
    assignedToId?: number | null
    uploadedById: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UploadedFileUpdateManyMutationInput = {
    filename?: StringFieldUpdateOperationsInput | string
    originalName?: StringFieldUpdateOperationsInput | string
    cloneName?: StringFieldUpdateOperationsInput | string
    size?: StringFieldUpdateOperationsInput | string
    uploadDate?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    progress?: IntFieldUpdateOperationsInput | number
    analysisData?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UploadedFileUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    filename?: StringFieldUpdateOperationsInput | string
    originalName?: StringFieldUpdateOperationsInput | string
    cloneName?: StringFieldUpdateOperationsInput | string
    size?: StringFieldUpdateOperationsInput | string
    uploadDate?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    progress?: IntFieldUpdateOperationsInput | number
    analysisData?: NullableStringFieldUpdateOperationsInput | string | null
    assignedToId?: NullableIntFieldUpdateOperationsInput | number | null
    uploadedById?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CloneDiscussionCreateInput = {
    title: string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    lastMessageAt?: Date | string
    student: UserCreateNestedOneWithoutDiscussionsInput
    clone?: UploadedFileCreateNestedOneWithoutCloneDiscussionsInput
    practiceClone?: PracticeCloneCreateNestedOneWithoutCloneDiscussionsInput
    messages?: DiscussionMessageCreateNestedManyWithoutDiscussionInput
  }

  export type CloneDiscussionUncheckedCreateInput = {
    id?: number
    studentId: number
    cloneId?: number | null
    practiceCloneId?: number | null
    title: string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    lastMessageAt?: Date | string
    messages?: DiscussionMessageUncheckedCreateNestedManyWithoutDiscussionInput
  }

  export type CloneDiscussionUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastMessageAt?: DateTimeFieldUpdateOperationsInput | Date | string
    student?: UserUpdateOneRequiredWithoutDiscussionsNestedInput
    clone?: UploadedFileUpdateOneWithoutCloneDiscussionsNestedInput
    practiceClone?: PracticeCloneUpdateOneWithoutCloneDiscussionsNestedInput
    messages?: DiscussionMessageUpdateManyWithoutDiscussionNestedInput
  }

  export type CloneDiscussionUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    studentId?: IntFieldUpdateOperationsInput | number
    cloneId?: NullableIntFieldUpdateOperationsInput | number | null
    practiceCloneId?: NullableIntFieldUpdateOperationsInput | number | null
    title?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastMessageAt?: DateTimeFieldUpdateOperationsInput | Date | string
    messages?: DiscussionMessageUncheckedUpdateManyWithoutDiscussionNestedInput
  }

  export type CloneDiscussionCreateManyInput = {
    id?: number
    studentId: number
    cloneId?: number | null
    practiceCloneId?: number | null
    title: string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    lastMessageAt?: Date | string
  }

  export type CloneDiscussionUpdateManyMutationInput = {
    title?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastMessageAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CloneDiscussionUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    studentId?: IntFieldUpdateOperationsInput | number
    cloneId?: NullableIntFieldUpdateOperationsInput | number | null
    practiceCloneId?: NullableIntFieldUpdateOperationsInput | number | null
    title?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastMessageAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DiscussionMessageCreateInput = {
    content: string
    messageType?: string
    readBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    discussion: CloneDiscussionCreateNestedOneWithoutMessagesInput
    sender: UserCreateNestedOneWithoutDiscussionMessagesSentInput
  }

  export type DiscussionMessageUncheckedCreateInput = {
    id?: number
    discussionId: number
    senderId: number
    content: string
    messageType?: string
    readBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DiscussionMessageUpdateInput = {
    content?: StringFieldUpdateOperationsInput | string
    messageType?: StringFieldUpdateOperationsInput | string
    readBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    discussion?: CloneDiscussionUpdateOneRequiredWithoutMessagesNestedInput
    sender?: UserUpdateOneRequiredWithoutDiscussionMessagesSentNestedInput
  }

  export type DiscussionMessageUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    discussionId?: IntFieldUpdateOperationsInput | number
    senderId?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    messageType?: StringFieldUpdateOperationsInput | string
    readBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DiscussionMessageCreateManyInput = {
    id?: number
    discussionId: number
    senderId: number
    content: string
    messageType?: string
    readBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DiscussionMessageUpdateManyMutationInput = {
    content?: StringFieldUpdateOperationsInput | string
    messageType?: StringFieldUpdateOperationsInput | string
    readBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DiscussionMessageUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    discussionId?: IntFieldUpdateOperationsInput | number
    senderId?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    messageType?: StringFieldUpdateOperationsInput | string
    readBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageCreateInput = {
    subject: string
    content: string
    messageType?: string
    isRead?: boolean
    cloneProgress?: number | null
    currentStep?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isGroupMessage?: boolean | null
    groupParticipants?: string | null
    sender: UserCreateNestedOneWithoutSentMessagesInput
    recipient: UserCreateNestedOneWithoutReceivedMessagesInput
    clone?: UploadedFileCreateNestedOneWithoutMessagesInput
  }

  export type MessageUncheckedCreateInput = {
    id?: number
    subject: string
    content: string
    messageType?: string
    isRead?: boolean
    senderId: number
    recipientId: number
    cloneId?: number | null
    cloneProgress?: number | null
    currentStep?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isGroupMessage?: boolean | null
    groupParticipants?: string | null
  }

  export type MessageUpdateInput = {
    subject?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    messageType?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    cloneProgress?: NullableIntFieldUpdateOperationsInput | number | null
    currentStep?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isGroupMessage?: NullableBoolFieldUpdateOperationsInput | boolean | null
    groupParticipants?: NullableStringFieldUpdateOperationsInput | string | null
    sender?: UserUpdateOneRequiredWithoutSentMessagesNestedInput
    recipient?: UserUpdateOneRequiredWithoutReceivedMessagesNestedInput
    clone?: UploadedFileUpdateOneWithoutMessagesNestedInput
  }

  export type MessageUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    subject?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    messageType?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    senderId?: IntFieldUpdateOperationsInput | number
    recipientId?: IntFieldUpdateOperationsInput | number
    cloneId?: NullableIntFieldUpdateOperationsInput | number | null
    cloneProgress?: NullableIntFieldUpdateOperationsInput | number | null
    currentStep?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isGroupMessage?: NullableBoolFieldUpdateOperationsInput | boolean | null
    groupParticipants?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type MessageCreateManyInput = {
    id?: number
    subject: string
    content: string
    messageType?: string
    isRead?: boolean
    senderId: number
    recipientId: number
    cloneId?: number | null
    cloneProgress?: number | null
    currentStep?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isGroupMessage?: boolean | null
    groupParticipants?: string | null
  }

  export type MessageUpdateManyMutationInput = {
    subject?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    messageType?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    cloneProgress?: NullableIntFieldUpdateOperationsInput | number | null
    currentStep?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isGroupMessage?: NullableBoolFieldUpdateOperationsInput | boolean | null
    groupParticipants?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type MessageUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    subject?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    messageType?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    senderId?: IntFieldUpdateOperationsInput | number
    recipientId?: IntFieldUpdateOperationsInput | number
    cloneId?: NullableIntFieldUpdateOperationsInput | number | null
    cloneProgress?: NullableIntFieldUpdateOperationsInput | number | null
    currentStep?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isGroupMessage?: NullableBoolFieldUpdateOperationsInput | boolean | null
    groupParticipants?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PracticeCloneCreateInput = {
    cloneName: string
    filename: string
    originalName: string
    description?: string | null
    isActive?: boolean
    uploadDate?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    practiceAnswers?: PracticeAnswerCreateNestedManyWithoutPracticeCloneInput
    userProgress?: UserPracticeProgressCreateNestedManyWithoutPracticeCloneInput
    cloneDiscussions?: CloneDiscussionCreateNestedManyWithoutPracticeCloneInput
  }

  export type PracticeCloneUncheckedCreateInput = {
    id?: number
    cloneName: string
    filename: string
    originalName: string
    description?: string | null
    isActive?: boolean
    uploadDate?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    practiceAnswers?: PracticeAnswerUncheckedCreateNestedManyWithoutPracticeCloneInput
    userProgress?: UserPracticeProgressUncheckedCreateNestedManyWithoutPracticeCloneInput
    cloneDiscussions?: CloneDiscussionUncheckedCreateNestedManyWithoutPracticeCloneInput
  }

  export type PracticeCloneUpdateInput = {
    cloneName?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    originalName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    uploadDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    practiceAnswers?: PracticeAnswerUpdateManyWithoutPracticeCloneNestedInput
    userProgress?: UserPracticeProgressUpdateManyWithoutPracticeCloneNestedInput
    cloneDiscussions?: CloneDiscussionUpdateManyWithoutPracticeCloneNestedInput
  }

  export type PracticeCloneUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    cloneName?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    originalName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    uploadDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    practiceAnswers?: PracticeAnswerUncheckedUpdateManyWithoutPracticeCloneNestedInput
    userProgress?: UserPracticeProgressUncheckedUpdateManyWithoutPracticeCloneNestedInput
    cloneDiscussions?: CloneDiscussionUncheckedUpdateManyWithoutPracticeCloneNestedInput
  }

  export type PracticeCloneCreateManyInput = {
    id?: number
    cloneName: string
    filename: string
    originalName: string
    description?: string | null
    isActive?: boolean
    uploadDate?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PracticeCloneUpdateManyMutationInput = {
    cloneName?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    originalName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    uploadDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PracticeCloneUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    cloneName?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    originalName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    uploadDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PracticeAnswerCreateInput = {
    id?: string
    questionId: string
    correctAnswer: string
    explanation?: string | null
    practiceClone: PracticeCloneCreateNestedOneWithoutPracticeAnswersInput
  }

  export type PracticeAnswerUncheckedCreateInput = {
    id?: string
    practiceCloneId: number
    questionId: string
    correctAnswer: string
    explanation?: string | null
  }

  export type PracticeAnswerUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    questionId?: StringFieldUpdateOperationsInput | string
    correctAnswer?: StringFieldUpdateOperationsInput | string
    explanation?: NullableStringFieldUpdateOperationsInput | string | null
    practiceClone?: PracticeCloneUpdateOneRequiredWithoutPracticeAnswersNestedInput
  }

  export type PracticeAnswerUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    practiceCloneId?: IntFieldUpdateOperationsInput | number
    questionId?: StringFieldUpdateOperationsInput | string
    correctAnswer?: StringFieldUpdateOperationsInput | string
    explanation?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PracticeAnswerCreateManyInput = {
    id?: string
    practiceCloneId: number
    questionId: string
    correctAnswer: string
    explanation?: string | null
  }

  export type PracticeAnswerUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    questionId?: StringFieldUpdateOperationsInput | string
    correctAnswer?: StringFieldUpdateOperationsInput | string
    explanation?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PracticeAnswerUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    practiceCloneId?: IntFieldUpdateOperationsInput | number
    questionId?: StringFieldUpdateOperationsInput | string
    correctAnswer?: StringFieldUpdateOperationsInput | string
    explanation?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserPracticeProgressCreateInput = {
    progress?: number
    answers?: string | null
    currentStep?: string
    status?: string
    lastSaved?: Date | string | null
    submittedAt?: Date | string | null
    reviewComments?: string | null
    reviewScore?: number | null
    lastReviewed?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutPracticeProgressInput
    practiceClone: PracticeCloneCreateNestedOneWithoutUserProgressInput
  }

  export type UserPracticeProgressUncheckedCreateInput = {
    id?: number
    userId: number
    practiceCloneId: number
    progress?: number
    answers?: string | null
    currentStep?: string
    status?: string
    lastSaved?: Date | string | null
    submittedAt?: Date | string | null
    reviewComments?: string | null
    reviewScore?: number | null
    lastReviewed?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserPracticeProgressUpdateInput = {
    progress?: IntFieldUpdateOperationsInput | number
    answers?: NullableStringFieldUpdateOperationsInput | string | null
    currentStep?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    lastSaved?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reviewComments?: NullableStringFieldUpdateOperationsInput | string | null
    reviewScore?: NullableIntFieldUpdateOperationsInput | number | null
    lastReviewed?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutPracticeProgressNestedInput
    practiceClone?: PracticeCloneUpdateOneRequiredWithoutUserProgressNestedInput
  }

  export type UserPracticeProgressUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    practiceCloneId?: IntFieldUpdateOperationsInput | number
    progress?: IntFieldUpdateOperationsInput | number
    answers?: NullableStringFieldUpdateOperationsInput | string | null
    currentStep?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    lastSaved?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reviewComments?: NullableStringFieldUpdateOperationsInput | string | null
    reviewScore?: NullableIntFieldUpdateOperationsInput | number | null
    lastReviewed?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserPracticeProgressCreateManyInput = {
    id?: number
    userId: number
    practiceCloneId: number
    progress?: number
    answers?: string | null
    currentStep?: string
    status?: string
    lastSaved?: Date | string | null
    submittedAt?: Date | string | null
    reviewComments?: string | null
    reviewScore?: number | null
    lastReviewed?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserPracticeProgressUpdateManyMutationInput = {
    progress?: IntFieldUpdateOperationsInput | number
    answers?: NullableStringFieldUpdateOperationsInput | string | null
    currentStep?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    lastSaved?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reviewComments?: NullableStringFieldUpdateOperationsInput | string | null
    reviewScore?: NullableIntFieldUpdateOperationsInput | number | null
    lastReviewed?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserPracticeProgressUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    practiceCloneId?: IntFieldUpdateOperationsInput | number
    progress?: IntFieldUpdateOperationsInput | number
    answers?: NullableStringFieldUpdateOperationsInput | string | null
    currentStep?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    lastSaved?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reviewComments?: NullableStringFieldUpdateOperationsInput | string | null
    reviewScore?: NullableIntFieldUpdateOperationsInput | number | null
    lastReviewed?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HelpTopicCreateInput = {
    id?: string
    title: string
    videoBoxUrl: string
    helpDocumentUrl: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    analysisQuestion: AnalysisQuestionCreateNestedOneWithoutHelpTopicInput
  }

  export type HelpTopicUncheckedCreateInput = {
    id?: string
    analysisQuestionId: string
    title: string
    videoBoxUrl: string
    helpDocumentUrl: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type HelpTopicUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    videoBoxUrl?: StringFieldUpdateOperationsInput | string
    helpDocumentUrl?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    analysisQuestion?: AnalysisQuestionUpdateOneRequiredWithoutHelpTopicNestedInput
  }

  export type HelpTopicUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    analysisQuestionId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    videoBoxUrl?: StringFieldUpdateOperationsInput | string
    helpDocumentUrl?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HelpTopicCreateManyInput = {
    id?: string
    analysisQuestionId: string
    title: string
    videoBoxUrl: string
    helpDocumentUrl: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type HelpTopicUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    videoBoxUrl?: StringFieldUpdateOperationsInput | string
    helpDocumentUrl?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HelpTopicUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    analysisQuestionId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    videoBoxUrl?: StringFieldUpdateOperationsInput | string
    helpDocumentUrl?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StepHelpCreateInput = {
    id?: string
    step: string
    title: string
    description?: string | null
    videoBoxUrl: string
    helpDocumentUrl: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StepHelpUncheckedCreateInput = {
    id?: string
    step: string
    title: string
    description?: string | null
    videoBoxUrl: string
    helpDocumentUrl: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StepHelpUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    step?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    videoBoxUrl?: StringFieldUpdateOperationsInput | string
    helpDocumentUrl?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StepHelpUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    step?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    videoBoxUrl?: StringFieldUpdateOperationsInput | string
    helpDocumentUrl?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StepHelpCreateManyInput = {
    id?: string
    step: string
    title: string
    description?: string | null
    videoBoxUrl: string
    helpDocumentUrl: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StepHelpUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    step?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    videoBoxUrl?: StringFieldUpdateOperationsInput | string
    helpDocumentUrl?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StepHelpUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    step?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    videoBoxUrl?: StringFieldUpdateOperationsInput | string
    helpDocumentUrl?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type SchoolNullableScalarRelationFilter = {
    is?: SchoolWhereInput | null
    isNot?: SchoolWhereInput | null
  }

  export type DemographicsNullableScalarRelationFilter = {
    is?: DemographicsWhereInput | null
    isNot?: DemographicsWhereInput | null
  }

  export type UploadedFileListRelationFilter = {
    every?: UploadedFileWhereInput
    some?: UploadedFileWhereInput
    none?: UploadedFileWhereInput
  }

  export type MessageListRelationFilter = {
    every?: MessageWhereInput
    some?: MessageWhereInput
    none?: MessageWhereInput
  }

  export type UserPracticeProgressListRelationFilter = {
    every?: UserPracticeProgressWhereInput
    some?: UserPracticeProgressWhereInput
    none?: UserPracticeProgressWhereInput
  }

  export type LoginLogListRelationFilter = {
    every?: LoginLogWhereInput
    some?: LoginLogWhereInput
    none?: LoginLogWhereInput
  }

  export type CloneDiscussionListRelationFilter = {
    every?: CloneDiscussionWhereInput
    some?: CloneDiscussionWhereInput
    none?: CloneDiscussionWhereInput
  }

  export type DiscussionMessageListRelationFilter = {
    every?: DiscussionMessageWhereInput
    some?: DiscussionMessageWhereInput
    none?: DiscussionMessageWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type UploadedFileOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MessageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserPracticeProgressOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LoginLogOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CloneDiscussionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DiscussionMessageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    name?: SortOrder
    role?: SortOrder
    status?: SortOrder
    schoolId?: SortOrder
    resetToken?: SortOrder
    resetTokenExpiry?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserAvgOrderByAggregateInput = {
    id?: SortOrder
    schoolId?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    name?: SortOrder
    role?: SortOrder
    status?: SortOrder
    schoolId?: SortOrder
    resetToken?: SortOrder
    resetTokenExpiry?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    name?: SortOrder
    role?: SortOrder
    status?: SortOrder
    schoolId?: SortOrder
    resetToken?: SortOrder
    resetTokenExpiry?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserSumOrderByAggregateInput = {
    id?: SortOrder
    schoolId?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type UserListRelationFilter = {
    every?: UserWhereInput
    some?: UserWhereInput
    none?: UserWhereInput
  }

  export type UserOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SchoolCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    schoolId?: SortOrder
    instructor?: SortOrder
    students?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SchoolAvgOrderByAggregateInput = {
    id?: SortOrder
    students?: SortOrder
  }

  export type SchoolMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    schoolId?: SortOrder
    instructor?: SortOrder
    students?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SchoolMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    schoolId?: SortOrder
    instructor?: SortOrder
    students?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SchoolSumOrderByAggregateInput = {
    id?: SortOrder
    students?: SortOrder
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type ProgramSettingsCountOrderByAggregateInput = {
    id?: SortOrder
    projectHeader?: SortOrder
    principalInvestigator?: SortOrder
    projectName?: SortOrder
    staffEmail?: SortOrder
    organismName?: SortOrder
    orfContactInformation?: SortOrder
    cloningVector?: SortOrder
    sequencePrimer?: SortOrder
    libraryName?: SortOrder
    restrictionEnzyme?: SortOrder
    description?: SortOrder
    welcomeText?: SortOrder
    overview?: SortOrder
    collectDemographics?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProgramSettingsAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type ProgramSettingsMaxOrderByAggregateInput = {
    id?: SortOrder
    projectHeader?: SortOrder
    principalInvestigator?: SortOrder
    projectName?: SortOrder
    staffEmail?: SortOrder
    organismName?: SortOrder
    orfContactInformation?: SortOrder
    cloningVector?: SortOrder
    sequencePrimer?: SortOrder
    libraryName?: SortOrder
    restrictionEnzyme?: SortOrder
    description?: SortOrder
    welcomeText?: SortOrder
    overview?: SortOrder
    collectDemographics?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProgramSettingsMinOrderByAggregateInput = {
    id?: SortOrder
    projectHeader?: SortOrder
    principalInvestigator?: SortOrder
    projectName?: SortOrder
    staffEmail?: SortOrder
    organismName?: SortOrder
    orfContactInformation?: SortOrder
    cloningVector?: SortOrder
    sequencePrimer?: SortOrder
    libraryName?: SortOrder
    restrictionEnzyme?: SortOrder
    description?: SortOrder
    welcomeText?: SortOrder
    overview?: SortOrder
    collectDemographics?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProgramSettingsSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type UserScalarRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type DemographicsCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    academicYear?: SortOrder
    yearsInProgram?: SortOrder
    classesTaken?: SortOrder
    otherScienceCourses?: SortOrder
    age?: SortOrder
    gender?: SortOrder
    ethnicity?: SortOrder
    educationLevel?: SortOrder
    city?: SortOrder
    state?: SortOrder
    country?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DemographicsAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    age?: SortOrder
  }

  export type DemographicsMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    academicYear?: SortOrder
    yearsInProgram?: SortOrder
    classesTaken?: SortOrder
    otherScienceCourses?: SortOrder
    age?: SortOrder
    gender?: SortOrder
    ethnicity?: SortOrder
    educationLevel?: SortOrder
    city?: SortOrder
    state?: SortOrder
    country?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DemographicsMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    academicYear?: SortOrder
    yearsInProgram?: SortOrder
    classesTaken?: SortOrder
    otherScienceCourses?: SortOrder
    age?: SortOrder
    gender?: SortOrder
    ethnicity?: SortOrder
    educationLevel?: SortOrder
    city?: SortOrder
    state?: SortOrder
    country?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DemographicsSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    age?: SortOrder
  }

  export type LoginLogCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    loginTime?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    success?: SortOrder
    createdAt?: SortOrder
  }

  export type LoginLogAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type LoginLogMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    loginTime?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    success?: SortOrder
    createdAt?: SortOrder
  }

  export type LoginLogMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    loginTime?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    success?: SortOrder
    createdAt?: SortOrder
  }

  export type LoginLogSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type HelpTopicListRelationFilter = {
    every?: HelpTopicWhereInput
    some?: HelpTopicWhereInput
    none?: HelpTopicWhereInput
  }

  export type HelpTopicOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AnalysisQuestionCountOrderByAggregateInput = {
    id?: SortOrder
    step?: SortOrder
    text?: SortOrder
    type?: SortOrder
    options?: SortOrder
    required?: SortOrder
    order?: SortOrder
    conditionalLogic?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AnalysisQuestionAvgOrderByAggregateInput = {
    order?: SortOrder
  }

  export type AnalysisQuestionMaxOrderByAggregateInput = {
    id?: SortOrder
    step?: SortOrder
    text?: SortOrder
    type?: SortOrder
    options?: SortOrder
    required?: SortOrder
    order?: SortOrder
    conditionalLogic?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AnalysisQuestionMinOrderByAggregateInput = {
    id?: SortOrder
    step?: SortOrder
    text?: SortOrder
    type?: SortOrder
    options?: SortOrder
    required?: SortOrder
    order?: SortOrder
    conditionalLogic?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AnalysisQuestionSumOrderByAggregateInput = {
    order?: SortOrder
  }

  export type CommonFeedbackCountOrderByAggregateInput = {
    id?: SortOrder
    questionId?: SortOrder
    title?: SortOrder
    text?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CommonFeedbackAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type CommonFeedbackMaxOrderByAggregateInput = {
    id?: SortOrder
    questionId?: SortOrder
    title?: SortOrder
    text?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CommonFeedbackMinOrderByAggregateInput = {
    id?: SortOrder
    questionId?: SortOrder
    title?: SortOrder
    text?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CommonFeedbackSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type UserNullableScalarRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type UploadedFileCountOrderByAggregateInput = {
    id?: SortOrder
    filename?: SortOrder
    originalName?: SortOrder
    cloneName?: SortOrder
    size?: SortOrder
    uploadDate?: SortOrder
    status?: SortOrder
    progress?: SortOrder
    analysisData?: SortOrder
    assignedToId?: SortOrder
    uploadedById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UploadedFileAvgOrderByAggregateInput = {
    id?: SortOrder
    progress?: SortOrder
    assignedToId?: SortOrder
    uploadedById?: SortOrder
  }

  export type UploadedFileMaxOrderByAggregateInput = {
    id?: SortOrder
    filename?: SortOrder
    originalName?: SortOrder
    cloneName?: SortOrder
    size?: SortOrder
    uploadDate?: SortOrder
    status?: SortOrder
    progress?: SortOrder
    analysisData?: SortOrder
    assignedToId?: SortOrder
    uploadedById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UploadedFileMinOrderByAggregateInput = {
    id?: SortOrder
    filename?: SortOrder
    originalName?: SortOrder
    cloneName?: SortOrder
    size?: SortOrder
    uploadDate?: SortOrder
    status?: SortOrder
    progress?: SortOrder
    analysisData?: SortOrder
    assignedToId?: SortOrder
    uploadedById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UploadedFileSumOrderByAggregateInput = {
    id?: SortOrder
    progress?: SortOrder
    assignedToId?: SortOrder
    uploadedById?: SortOrder
  }

  export type UploadedFileNullableScalarRelationFilter = {
    is?: UploadedFileWhereInput | null
    isNot?: UploadedFileWhereInput | null
  }

  export type PracticeCloneNullableScalarRelationFilter = {
    is?: PracticeCloneWhereInput | null
    isNot?: PracticeCloneWhereInput | null
  }

  export type CloneDiscussionStudentIdCloneIdCompoundUniqueInput = {
    studentId: number
    cloneId: number
  }

  export type CloneDiscussionStudentIdPracticeCloneIdCompoundUniqueInput = {
    studentId: number
    practiceCloneId: number
  }

  export type CloneDiscussionCountOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    cloneId?: SortOrder
    practiceCloneId?: SortOrder
    title?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    lastMessageAt?: SortOrder
  }

  export type CloneDiscussionAvgOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    cloneId?: SortOrder
    practiceCloneId?: SortOrder
  }

  export type CloneDiscussionMaxOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    cloneId?: SortOrder
    practiceCloneId?: SortOrder
    title?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    lastMessageAt?: SortOrder
  }

  export type CloneDiscussionMinOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    cloneId?: SortOrder
    practiceCloneId?: SortOrder
    title?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    lastMessageAt?: SortOrder
  }

  export type CloneDiscussionSumOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    cloneId?: SortOrder
    practiceCloneId?: SortOrder
  }

  export type CloneDiscussionScalarRelationFilter = {
    is?: CloneDiscussionWhereInput
    isNot?: CloneDiscussionWhereInput
  }

  export type DiscussionMessageCountOrderByAggregateInput = {
    id?: SortOrder
    discussionId?: SortOrder
    senderId?: SortOrder
    content?: SortOrder
    messageType?: SortOrder
    readBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DiscussionMessageAvgOrderByAggregateInput = {
    id?: SortOrder
    discussionId?: SortOrder
    senderId?: SortOrder
  }

  export type DiscussionMessageMaxOrderByAggregateInput = {
    id?: SortOrder
    discussionId?: SortOrder
    senderId?: SortOrder
    content?: SortOrder
    messageType?: SortOrder
    readBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DiscussionMessageMinOrderByAggregateInput = {
    id?: SortOrder
    discussionId?: SortOrder
    senderId?: SortOrder
    content?: SortOrder
    messageType?: SortOrder
    readBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DiscussionMessageSumOrderByAggregateInput = {
    id?: SortOrder
    discussionId?: SortOrder
    senderId?: SortOrder
  }

  export type BoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type MessageCountOrderByAggregateInput = {
    id?: SortOrder
    subject?: SortOrder
    content?: SortOrder
    messageType?: SortOrder
    isRead?: SortOrder
    senderId?: SortOrder
    recipientId?: SortOrder
    cloneId?: SortOrder
    cloneProgress?: SortOrder
    currentStep?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isGroupMessage?: SortOrder
    groupParticipants?: SortOrder
  }

  export type MessageAvgOrderByAggregateInput = {
    id?: SortOrder
    senderId?: SortOrder
    recipientId?: SortOrder
    cloneId?: SortOrder
    cloneProgress?: SortOrder
  }

  export type MessageMaxOrderByAggregateInput = {
    id?: SortOrder
    subject?: SortOrder
    content?: SortOrder
    messageType?: SortOrder
    isRead?: SortOrder
    senderId?: SortOrder
    recipientId?: SortOrder
    cloneId?: SortOrder
    cloneProgress?: SortOrder
    currentStep?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isGroupMessage?: SortOrder
    groupParticipants?: SortOrder
  }

  export type MessageMinOrderByAggregateInput = {
    id?: SortOrder
    subject?: SortOrder
    content?: SortOrder
    messageType?: SortOrder
    isRead?: SortOrder
    senderId?: SortOrder
    recipientId?: SortOrder
    cloneId?: SortOrder
    cloneProgress?: SortOrder
    currentStep?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isGroupMessage?: SortOrder
    groupParticipants?: SortOrder
  }

  export type MessageSumOrderByAggregateInput = {
    id?: SortOrder
    senderId?: SortOrder
    recipientId?: SortOrder
    cloneId?: SortOrder
    cloneProgress?: SortOrder
  }

  export type BoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type PracticeAnswerListRelationFilter = {
    every?: PracticeAnswerWhereInput
    some?: PracticeAnswerWhereInput
    none?: PracticeAnswerWhereInput
  }

  export type PracticeAnswerOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PracticeCloneCountOrderByAggregateInput = {
    id?: SortOrder
    cloneName?: SortOrder
    filename?: SortOrder
    originalName?: SortOrder
    description?: SortOrder
    isActive?: SortOrder
    uploadDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PracticeCloneAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type PracticeCloneMaxOrderByAggregateInput = {
    id?: SortOrder
    cloneName?: SortOrder
    filename?: SortOrder
    originalName?: SortOrder
    description?: SortOrder
    isActive?: SortOrder
    uploadDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PracticeCloneMinOrderByAggregateInput = {
    id?: SortOrder
    cloneName?: SortOrder
    filename?: SortOrder
    originalName?: SortOrder
    description?: SortOrder
    isActive?: SortOrder
    uploadDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PracticeCloneSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type PracticeCloneScalarRelationFilter = {
    is?: PracticeCloneWhereInput
    isNot?: PracticeCloneWhereInput
  }

  export type PracticeAnswerPracticeCloneIdQuestionIdCompoundUniqueInput = {
    practiceCloneId: number
    questionId: string
  }

  export type PracticeAnswerCountOrderByAggregateInput = {
    id?: SortOrder
    practiceCloneId?: SortOrder
    questionId?: SortOrder
    correctAnswer?: SortOrder
    explanation?: SortOrder
  }

  export type PracticeAnswerAvgOrderByAggregateInput = {
    practiceCloneId?: SortOrder
  }

  export type PracticeAnswerMaxOrderByAggregateInput = {
    id?: SortOrder
    practiceCloneId?: SortOrder
    questionId?: SortOrder
    correctAnswer?: SortOrder
    explanation?: SortOrder
  }

  export type PracticeAnswerMinOrderByAggregateInput = {
    id?: SortOrder
    practiceCloneId?: SortOrder
    questionId?: SortOrder
    correctAnswer?: SortOrder
    explanation?: SortOrder
  }

  export type PracticeAnswerSumOrderByAggregateInput = {
    practiceCloneId?: SortOrder
  }

  export type UserPracticeProgressUserIdPracticeCloneIdCompoundUniqueInput = {
    userId: number
    practiceCloneId: number
  }

  export type UserPracticeProgressCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    practiceCloneId?: SortOrder
    progress?: SortOrder
    answers?: SortOrder
    currentStep?: SortOrder
    status?: SortOrder
    lastSaved?: SortOrder
    submittedAt?: SortOrder
    reviewComments?: SortOrder
    reviewScore?: SortOrder
    lastReviewed?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserPracticeProgressAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    practiceCloneId?: SortOrder
    progress?: SortOrder
    reviewScore?: SortOrder
  }

  export type UserPracticeProgressMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    practiceCloneId?: SortOrder
    progress?: SortOrder
    answers?: SortOrder
    currentStep?: SortOrder
    status?: SortOrder
    lastSaved?: SortOrder
    submittedAt?: SortOrder
    reviewComments?: SortOrder
    reviewScore?: SortOrder
    lastReviewed?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserPracticeProgressMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    practiceCloneId?: SortOrder
    progress?: SortOrder
    answers?: SortOrder
    currentStep?: SortOrder
    status?: SortOrder
    lastSaved?: SortOrder
    submittedAt?: SortOrder
    reviewComments?: SortOrder
    reviewScore?: SortOrder
    lastReviewed?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserPracticeProgressSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    practiceCloneId?: SortOrder
    progress?: SortOrder
    reviewScore?: SortOrder
  }

  export type AnalysisQuestionScalarRelationFilter = {
    is?: AnalysisQuestionWhereInput
    isNot?: AnalysisQuestionWhereInput
  }

  export type HelpTopicCountOrderByAggregateInput = {
    id?: SortOrder
    analysisQuestionId?: SortOrder
    title?: SortOrder
    videoBoxUrl?: SortOrder
    helpDocumentUrl?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type HelpTopicMaxOrderByAggregateInput = {
    id?: SortOrder
    analysisQuestionId?: SortOrder
    title?: SortOrder
    videoBoxUrl?: SortOrder
    helpDocumentUrl?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type HelpTopicMinOrderByAggregateInput = {
    id?: SortOrder
    analysisQuestionId?: SortOrder
    title?: SortOrder
    videoBoxUrl?: SortOrder
    helpDocumentUrl?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StepHelpCountOrderByAggregateInput = {
    id?: SortOrder
    step?: SortOrder
    title?: SortOrder
    description?: SortOrder
    videoBoxUrl?: SortOrder
    helpDocumentUrl?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StepHelpMaxOrderByAggregateInput = {
    id?: SortOrder
    step?: SortOrder
    title?: SortOrder
    description?: SortOrder
    videoBoxUrl?: SortOrder
    helpDocumentUrl?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StepHelpMinOrderByAggregateInput = {
    id?: SortOrder
    step?: SortOrder
    title?: SortOrder
    description?: SortOrder
    videoBoxUrl?: SortOrder
    helpDocumentUrl?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SchoolCreateNestedOneWithoutUsersInput = {
    create?: XOR<SchoolCreateWithoutUsersInput, SchoolUncheckedCreateWithoutUsersInput>
    connectOrCreate?: SchoolCreateOrConnectWithoutUsersInput
    connect?: SchoolWhereUniqueInput
  }

  export type DemographicsCreateNestedOneWithoutUserInput = {
    create?: XOR<DemographicsCreateWithoutUserInput, DemographicsUncheckedCreateWithoutUserInput>
    connectOrCreate?: DemographicsCreateOrConnectWithoutUserInput
    connect?: DemographicsWhereUniqueInput
  }

  export type UploadedFileCreateNestedManyWithoutAssignedToInput = {
    create?: XOR<UploadedFileCreateWithoutAssignedToInput, UploadedFileUncheckedCreateWithoutAssignedToInput> | UploadedFileCreateWithoutAssignedToInput[] | UploadedFileUncheckedCreateWithoutAssignedToInput[]
    connectOrCreate?: UploadedFileCreateOrConnectWithoutAssignedToInput | UploadedFileCreateOrConnectWithoutAssignedToInput[]
    createMany?: UploadedFileCreateManyAssignedToInputEnvelope
    connect?: UploadedFileWhereUniqueInput | UploadedFileWhereUniqueInput[]
  }

  export type UploadedFileCreateNestedManyWithoutUploadedByInput = {
    create?: XOR<UploadedFileCreateWithoutUploadedByInput, UploadedFileUncheckedCreateWithoutUploadedByInput> | UploadedFileCreateWithoutUploadedByInput[] | UploadedFileUncheckedCreateWithoutUploadedByInput[]
    connectOrCreate?: UploadedFileCreateOrConnectWithoutUploadedByInput | UploadedFileCreateOrConnectWithoutUploadedByInput[]
    createMany?: UploadedFileCreateManyUploadedByInputEnvelope
    connect?: UploadedFileWhereUniqueInput | UploadedFileWhereUniqueInput[]
  }

  export type MessageCreateNestedManyWithoutSenderInput = {
    create?: XOR<MessageCreateWithoutSenderInput, MessageUncheckedCreateWithoutSenderInput> | MessageCreateWithoutSenderInput[] | MessageUncheckedCreateWithoutSenderInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutSenderInput | MessageCreateOrConnectWithoutSenderInput[]
    createMany?: MessageCreateManySenderInputEnvelope
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
  }

  export type MessageCreateNestedManyWithoutRecipientInput = {
    create?: XOR<MessageCreateWithoutRecipientInput, MessageUncheckedCreateWithoutRecipientInput> | MessageCreateWithoutRecipientInput[] | MessageUncheckedCreateWithoutRecipientInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutRecipientInput | MessageCreateOrConnectWithoutRecipientInput[]
    createMany?: MessageCreateManyRecipientInputEnvelope
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
  }

  export type UserPracticeProgressCreateNestedManyWithoutUserInput = {
    create?: XOR<UserPracticeProgressCreateWithoutUserInput, UserPracticeProgressUncheckedCreateWithoutUserInput> | UserPracticeProgressCreateWithoutUserInput[] | UserPracticeProgressUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserPracticeProgressCreateOrConnectWithoutUserInput | UserPracticeProgressCreateOrConnectWithoutUserInput[]
    createMany?: UserPracticeProgressCreateManyUserInputEnvelope
    connect?: UserPracticeProgressWhereUniqueInput | UserPracticeProgressWhereUniqueInput[]
  }

  export type LoginLogCreateNestedManyWithoutUserInput = {
    create?: XOR<LoginLogCreateWithoutUserInput, LoginLogUncheckedCreateWithoutUserInput> | LoginLogCreateWithoutUserInput[] | LoginLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: LoginLogCreateOrConnectWithoutUserInput | LoginLogCreateOrConnectWithoutUserInput[]
    createMany?: LoginLogCreateManyUserInputEnvelope
    connect?: LoginLogWhereUniqueInput | LoginLogWhereUniqueInput[]
  }

  export type CloneDiscussionCreateNestedManyWithoutStudentInput = {
    create?: XOR<CloneDiscussionCreateWithoutStudentInput, CloneDiscussionUncheckedCreateWithoutStudentInput> | CloneDiscussionCreateWithoutStudentInput[] | CloneDiscussionUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: CloneDiscussionCreateOrConnectWithoutStudentInput | CloneDiscussionCreateOrConnectWithoutStudentInput[]
    createMany?: CloneDiscussionCreateManyStudentInputEnvelope
    connect?: CloneDiscussionWhereUniqueInput | CloneDiscussionWhereUniqueInput[]
  }

  export type DiscussionMessageCreateNestedManyWithoutSenderInput = {
    create?: XOR<DiscussionMessageCreateWithoutSenderInput, DiscussionMessageUncheckedCreateWithoutSenderInput> | DiscussionMessageCreateWithoutSenderInput[] | DiscussionMessageUncheckedCreateWithoutSenderInput[]
    connectOrCreate?: DiscussionMessageCreateOrConnectWithoutSenderInput | DiscussionMessageCreateOrConnectWithoutSenderInput[]
    createMany?: DiscussionMessageCreateManySenderInputEnvelope
    connect?: DiscussionMessageWhereUniqueInput | DiscussionMessageWhereUniqueInput[]
  }

  export type DemographicsUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<DemographicsCreateWithoutUserInput, DemographicsUncheckedCreateWithoutUserInput>
    connectOrCreate?: DemographicsCreateOrConnectWithoutUserInput
    connect?: DemographicsWhereUniqueInput
  }

  export type UploadedFileUncheckedCreateNestedManyWithoutAssignedToInput = {
    create?: XOR<UploadedFileCreateWithoutAssignedToInput, UploadedFileUncheckedCreateWithoutAssignedToInput> | UploadedFileCreateWithoutAssignedToInput[] | UploadedFileUncheckedCreateWithoutAssignedToInput[]
    connectOrCreate?: UploadedFileCreateOrConnectWithoutAssignedToInput | UploadedFileCreateOrConnectWithoutAssignedToInput[]
    createMany?: UploadedFileCreateManyAssignedToInputEnvelope
    connect?: UploadedFileWhereUniqueInput | UploadedFileWhereUniqueInput[]
  }

  export type UploadedFileUncheckedCreateNestedManyWithoutUploadedByInput = {
    create?: XOR<UploadedFileCreateWithoutUploadedByInput, UploadedFileUncheckedCreateWithoutUploadedByInput> | UploadedFileCreateWithoutUploadedByInput[] | UploadedFileUncheckedCreateWithoutUploadedByInput[]
    connectOrCreate?: UploadedFileCreateOrConnectWithoutUploadedByInput | UploadedFileCreateOrConnectWithoutUploadedByInput[]
    createMany?: UploadedFileCreateManyUploadedByInputEnvelope
    connect?: UploadedFileWhereUniqueInput | UploadedFileWhereUniqueInput[]
  }

  export type MessageUncheckedCreateNestedManyWithoutSenderInput = {
    create?: XOR<MessageCreateWithoutSenderInput, MessageUncheckedCreateWithoutSenderInput> | MessageCreateWithoutSenderInput[] | MessageUncheckedCreateWithoutSenderInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutSenderInput | MessageCreateOrConnectWithoutSenderInput[]
    createMany?: MessageCreateManySenderInputEnvelope
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
  }

  export type MessageUncheckedCreateNestedManyWithoutRecipientInput = {
    create?: XOR<MessageCreateWithoutRecipientInput, MessageUncheckedCreateWithoutRecipientInput> | MessageCreateWithoutRecipientInput[] | MessageUncheckedCreateWithoutRecipientInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutRecipientInput | MessageCreateOrConnectWithoutRecipientInput[]
    createMany?: MessageCreateManyRecipientInputEnvelope
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
  }

  export type UserPracticeProgressUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<UserPracticeProgressCreateWithoutUserInput, UserPracticeProgressUncheckedCreateWithoutUserInput> | UserPracticeProgressCreateWithoutUserInput[] | UserPracticeProgressUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserPracticeProgressCreateOrConnectWithoutUserInput | UserPracticeProgressCreateOrConnectWithoutUserInput[]
    createMany?: UserPracticeProgressCreateManyUserInputEnvelope
    connect?: UserPracticeProgressWhereUniqueInput | UserPracticeProgressWhereUniqueInput[]
  }

  export type LoginLogUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<LoginLogCreateWithoutUserInput, LoginLogUncheckedCreateWithoutUserInput> | LoginLogCreateWithoutUserInput[] | LoginLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: LoginLogCreateOrConnectWithoutUserInput | LoginLogCreateOrConnectWithoutUserInput[]
    createMany?: LoginLogCreateManyUserInputEnvelope
    connect?: LoginLogWhereUniqueInput | LoginLogWhereUniqueInput[]
  }

  export type CloneDiscussionUncheckedCreateNestedManyWithoutStudentInput = {
    create?: XOR<CloneDiscussionCreateWithoutStudentInput, CloneDiscussionUncheckedCreateWithoutStudentInput> | CloneDiscussionCreateWithoutStudentInput[] | CloneDiscussionUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: CloneDiscussionCreateOrConnectWithoutStudentInput | CloneDiscussionCreateOrConnectWithoutStudentInput[]
    createMany?: CloneDiscussionCreateManyStudentInputEnvelope
    connect?: CloneDiscussionWhereUniqueInput | CloneDiscussionWhereUniqueInput[]
  }

  export type DiscussionMessageUncheckedCreateNestedManyWithoutSenderInput = {
    create?: XOR<DiscussionMessageCreateWithoutSenderInput, DiscussionMessageUncheckedCreateWithoutSenderInput> | DiscussionMessageCreateWithoutSenderInput[] | DiscussionMessageUncheckedCreateWithoutSenderInput[]
    connectOrCreate?: DiscussionMessageCreateOrConnectWithoutSenderInput | DiscussionMessageCreateOrConnectWithoutSenderInput[]
    createMany?: DiscussionMessageCreateManySenderInputEnvelope
    connect?: DiscussionMessageWhereUniqueInput | DiscussionMessageWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type SchoolUpdateOneWithoutUsersNestedInput = {
    create?: XOR<SchoolCreateWithoutUsersInput, SchoolUncheckedCreateWithoutUsersInput>
    connectOrCreate?: SchoolCreateOrConnectWithoutUsersInput
    upsert?: SchoolUpsertWithoutUsersInput
    disconnect?: SchoolWhereInput | boolean
    delete?: SchoolWhereInput | boolean
    connect?: SchoolWhereUniqueInput
    update?: XOR<XOR<SchoolUpdateToOneWithWhereWithoutUsersInput, SchoolUpdateWithoutUsersInput>, SchoolUncheckedUpdateWithoutUsersInput>
  }

  export type DemographicsUpdateOneWithoutUserNestedInput = {
    create?: XOR<DemographicsCreateWithoutUserInput, DemographicsUncheckedCreateWithoutUserInput>
    connectOrCreate?: DemographicsCreateOrConnectWithoutUserInput
    upsert?: DemographicsUpsertWithoutUserInput
    disconnect?: DemographicsWhereInput | boolean
    delete?: DemographicsWhereInput | boolean
    connect?: DemographicsWhereUniqueInput
    update?: XOR<XOR<DemographicsUpdateToOneWithWhereWithoutUserInput, DemographicsUpdateWithoutUserInput>, DemographicsUncheckedUpdateWithoutUserInput>
  }

  export type UploadedFileUpdateManyWithoutAssignedToNestedInput = {
    create?: XOR<UploadedFileCreateWithoutAssignedToInput, UploadedFileUncheckedCreateWithoutAssignedToInput> | UploadedFileCreateWithoutAssignedToInput[] | UploadedFileUncheckedCreateWithoutAssignedToInput[]
    connectOrCreate?: UploadedFileCreateOrConnectWithoutAssignedToInput | UploadedFileCreateOrConnectWithoutAssignedToInput[]
    upsert?: UploadedFileUpsertWithWhereUniqueWithoutAssignedToInput | UploadedFileUpsertWithWhereUniqueWithoutAssignedToInput[]
    createMany?: UploadedFileCreateManyAssignedToInputEnvelope
    set?: UploadedFileWhereUniqueInput | UploadedFileWhereUniqueInput[]
    disconnect?: UploadedFileWhereUniqueInput | UploadedFileWhereUniqueInput[]
    delete?: UploadedFileWhereUniqueInput | UploadedFileWhereUniqueInput[]
    connect?: UploadedFileWhereUniqueInput | UploadedFileWhereUniqueInput[]
    update?: UploadedFileUpdateWithWhereUniqueWithoutAssignedToInput | UploadedFileUpdateWithWhereUniqueWithoutAssignedToInput[]
    updateMany?: UploadedFileUpdateManyWithWhereWithoutAssignedToInput | UploadedFileUpdateManyWithWhereWithoutAssignedToInput[]
    deleteMany?: UploadedFileScalarWhereInput | UploadedFileScalarWhereInput[]
  }

  export type UploadedFileUpdateManyWithoutUploadedByNestedInput = {
    create?: XOR<UploadedFileCreateWithoutUploadedByInput, UploadedFileUncheckedCreateWithoutUploadedByInput> | UploadedFileCreateWithoutUploadedByInput[] | UploadedFileUncheckedCreateWithoutUploadedByInput[]
    connectOrCreate?: UploadedFileCreateOrConnectWithoutUploadedByInput | UploadedFileCreateOrConnectWithoutUploadedByInput[]
    upsert?: UploadedFileUpsertWithWhereUniqueWithoutUploadedByInput | UploadedFileUpsertWithWhereUniqueWithoutUploadedByInput[]
    createMany?: UploadedFileCreateManyUploadedByInputEnvelope
    set?: UploadedFileWhereUniqueInput | UploadedFileWhereUniqueInput[]
    disconnect?: UploadedFileWhereUniqueInput | UploadedFileWhereUniqueInput[]
    delete?: UploadedFileWhereUniqueInput | UploadedFileWhereUniqueInput[]
    connect?: UploadedFileWhereUniqueInput | UploadedFileWhereUniqueInput[]
    update?: UploadedFileUpdateWithWhereUniqueWithoutUploadedByInput | UploadedFileUpdateWithWhereUniqueWithoutUploadedByInput[]
    updateMany?: UploadedFileUpdateManyWithWhereWithoutUploadedByInput | UploadedFileUpdateManyWithWhereWithoutUploadedByInput[]
    deleteMany?: UploadedFileScalarWhereInput | UploadedFileScalarWhereInput[]
  }

  export type MessageUpdateManyWithoutSenderNestedInput = {
    create?: XOR<MessageCreateWithoutSenderInput, MessageUncheckedCreateWithoutSenderInput> | MessageCreateWithoutSenderInput[] | MessageUncheckedCreateWithoutSenderInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutSenderInput | MessageCreateOrConnectWithoutSenderInput[]
    upsert?: MessageUpsertWithWhereUniqueWithoutSenderInput | MessageUpsertWithWhereUniqueWithoutSenderInput[]
    createMany?: MessageCreateManySenderInputEnvelope
    set?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    disconnect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    delete?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    update?: MessageUpdateWithWhereUniqueWithoutSenderInput | MessageUpdateWithWhereUniqueWithoutSenderInput[]
    updateMany?: MessageUpdateManyWithWhereWithoutSenderInput | MessageUpdateManyWithWhereWithoutSenderInput[]
    deleteMany?: MessageScalarWhereInput | MessageScalarWhereInput[]
  }

  export type MessageUpdateManyWithoutRecipientNestedInput = {
    create?: XOR<MessageCreateWithoutRecipientInput, MessageUncheckedCreateWithoutRecipientInput> | MessageCreateWithoutRecipientInput[] | MessageUncheckedCreateWithoutRecipientInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutRecipientInput | MessageCreateOrConnectWithoutRecipientInput[]
    upsert?: MessageUpsertWithWhereUniqueWithoutRecipientInput | MessageUpsertWithWhereUniqueWithoutRecipientInput[]
    createMany?: MessageCreateManyRecipientInputEnvelope
    set?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    disconnect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    delete?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    update?: MessageUpdateWithWhereUniqueWithoutRecipientInput | MessageUpdateWithWhereUniqueWithoutRecipientInput[]
    updateMany?: MessageUpdateManyWithWhereWithoutRecipientInput | MessageUpdateManyWithWhereWithoutRecipientInput[]
    deleteMany?: MessageScalarWhereInput | MessageScalarWhereInput[]
  }

  export type UserPracticeProgressUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserPracticeProgressCreateWithoutUserInput, UserPracticeProgressUncheckedCreateWithoutUserInput> | UserPracticeProgressCreateWithoutUserInput[] | UserPracticeProgressUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserPracticeProgressCreateOrConnectWithoutUserInput | UserPracticeProgressCreateOrConnectWithoutUserInput[]
    upsert?: UserPracticeProgressUpsertWithWhereUniqueWithoutUserInput | UserPracticeProgressUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserPracticeProgressCreateManyUserInputEnvelope
    set?: UserPracticeProgressWhereUniqueInput | UserPracticeProgressWhereUniqueInput[]
    disconnect?: UserPracticeProgressWhereUniqueInput | UserPracticeProgressWhereUniqueInput[]
    delete?: UserPracticeProgressWhereUniqueInput | UserPracticeProgressWhereUniqueInput[]
    connect?: UserPracticeProgressWhereUniqueInput | UserPracticeProgressWhereUniqueInput[]
    update?: UserPracticeProgressUpdateWithWhereUniqueWithoutUserInput | UserPracticeProgressUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserPracticeProgressUpdateManyWithWhereWithoutUserInput | UserPracticeProgressUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserPracticeProgressScalarWhereInput | UserPracticeProgressScalarWhereInput[]
  }

  export type LoginLogUpdateManyWithoutUserNestedInput = {
    create?: XOR<LoginLogCreateWithoutUserInput, LoginLogUncheckedCreateWithoutUserInput> | LoginLogCreateWithoutUserInput[] | LoginLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: LoginLogCreateOrConnectWithoutUserInput | LoginLogCreateOrConnectWithoutUserInput[]
    upsert?: LoginLogUpsertWithWhereUniqueWithoutUserInput | LoginLogUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: LoginLogCreateManyUserInputEnvelope
    set?: LoginLogWhereUniqueInput | LoginLogWhereUniqueInput[]
    disconnect?: LoginLogWhereUniqueInput | LoginLogWhereUniqueInput[]
    delete?: LoginLogWhereUniqueInput | LoginLogWhereUniqueInput[]
    connect?: LoginLogWhereUniqueInput | LoginLogWhereUniqueInput[]
    update?: LoginLogUpdateWithWhereUniqueWithoutUserInput | LoginLogUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: LoginLogUpdateManyWithWhereWithoutUserInput | LoginLogUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: LoginLogScalarWhereInput | LoginLogScalarWhereInput[]
  }

  export type CloneDiscussionUpdateManyWithoutStudentNestedInput = {
    create?: XOR<CloneDiscussionCreateWithoutStudentInput, CloneDiscussionUncheckedCreateWithoutStudentInput> | CloneDiscussionCreateWithoutStudentInput[] | CloneDiscussionUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: CloneDiscussionCreateOrConnectWithoutStudentInput | CloneDiscussionCreateOrConnectWithoutStudentInput[]
    upsert?: CloneDiscussionUpsertWithWhereUniqueWithoutStudentInput | CloneDiscussionUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: CloneDiscussionCreateManyStudentInputEnvelope
    set?: CloneDiscussionWhereUniqueInput | CloneDiscussionWhereUniqueInput[]
    disconnect?: CloneDiscussionWhereUniqueInput | CloneDiscussionWhereUniqueInput[]
    delete?: CloneDiscussionWhereUniqueInput | CloneDiscussionWhereUniqueInput[]
    connect?: CloneDiscussionWhereUniqueInput | CloneDiscussionWhereUniqueInput[]
    update?: CloneDiscussionUpdateWithWhereUniqueWithoutStudentInput | CloneDiscussionUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: CloneDiscussionUpdateManyWithWhereWithoutStudentInput | CloneDiscussionUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: CloneDiscussionScalarWhereInput | CloneDiscussionScalarWhereInput[]
  }

  export type DiscussionMessageUpdateManyWithoutSenderNestedInput = {
    create?: XOR<DiscussionMessageCreateWithoutSenderInput, DiscussionMessageUncheckedCreateWithoutSenderInput> | DiscussionMessageCreateWithoutSenderInput[] | DiscussionMessageUncheckedCreateWithoutSenderInput[]
    connectOrCreate?: DiscussionMessageCreateOrConnectWithoutSenderInput | DiscussionMessageCreateOrConnectWithoutSenderInput[]
    upsert?: DiscussionMessageUpsertWithWhereUniqueWithoutSenderInput | DiscussionMessageUpsertWithWhereUniqueWithoutSenderInput[]
    createMany?: DiscussionMessageCreateManySenderInputEnvelope
    set?: DiscussionMessageWhereUniqueInput | DiscussionMessageWhereUniqueInput[]
    disconnect?: DiscussionMessageWhereUniqueInput | DiscussionMessageWhereUniqueInput[]
    delete?: DiscussionMessageWhereUniqueInput | DiscussionMessageWhereUniqueInput[]
    connect?: DiscussionMessageWhereUniqueInput | DiscussionMessageWhereUniqueInput[]
    update?: DiscussionMessageUpdateWithWhereUniqueWithoutSenderInput | DiscussionMessageUpdateWithWhereUniqueWithoutSenderInput[]
    updateMany?: DiscussionMessageUpdateManyWithWhereWithoutSenderInput | DiscussionMessageUpdateManyWithWhereWithoutSenderInput[]
    deleteMany?: DiscussionMessageScalarWhereInput | DiscussionMessageScalarWhereInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type DemographicsUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<DemographicsCreateWithoutUserInput, DemographicsUncheckedCreateWithoutUserInput>
    connectOrCreate?: DemographicsCreateOrConnectWithoutUserInput
    upsert?: DemographicsUpsertWithoutUserInput
    disconnect?: DemographicsWhereInput | boolean
    delete?: DemographicsWhereInput | boolean
    connect?: DemographicsWhereUniqueInput
    update?: XOR<XOR<DemographicsUpdateToOneWithWhereWithoutUserInput, DemographicsUpdateWithoutUserInput>, DemographicsUncheckedUpdateWithoutUserInput>
  }

  export type UploadedFileUncheckedUpdateManyWithoutAssignedToNestedInput = {
    create?: XOR<UploadedFileCreateWithoutAssignedToInput, UploadedFileUncheckedCreateWithoutAssignedToInput> | UploadedFileCreateWithoutAssignedToInput[] | UploadedFileUncheckedCreateWithoutAssignedToInput[]
    connectOrCreate?: UploadedFileCreateOrConnectWithoutAssignedToInput | UploadedFileCreateOrConnectWithoutAssignedToInput[]
    upsert?: UploadedFileUpsertWithWhereUniqueWithoutAssignedToInput | UploadedFileUpsertWithWhereUniqueWithoutAssignedToInput[]
    createMany?: UploadedFileCreateManyAssignedToInputEnvelope
    set?: UploadedFileWhereUniqueInput | UploadedFileWhereUniqueInput[]
    disconnect?: UploadedFileWhereUniqueInput | UploadedFileWhereUniqueInput[]
    delete?: UploadedFileWhereUniqueInput | UploadedFileWhereUniqueInput[]
    connect?: UploadedFileWhereUniqueInput | UploadedFileWhereUniqueInput[]
    update?: UploadedFileUpdateWithWhereUniqueWithoutAssignedToInput | UploadedFileUpdateWithWhereUniqueWithoutAssignedToInput[]
    updateMany?: UploadedFileUpdateManyWithWhereWithoutAssignedToInput | UploadedFileUpdateManyWithWhereWithoutAssignedToInput[]
    deleteMany?: UploadedFileScalarWhereInput | UploadedFileScalarWhereInput[]
  }

  export type UploadedFileUncheckedUpdateManyWithoutUploadedByNestedInput = {
    create?: XOR<UploadedFileCreateWithoutUploadedByInput, UploadedFileUncheckedCreateWithoutUploadedByInput> | UploadedFileCreateWithoutUploadedByInput[] | UploadedFileUncheckedCreateWithoutUploadedByInput[]
    connectOrCreate?: UploadedFileCreateOrConnectWithoutUploadedByInput | UploadedFileCreateOrConnectWithoutUploadedByInput[]
    upsert?: UploadedFileUpsertWithWhereUniqueWithoutUploadedByInput | UploadedFileUpsertWithWhereUniqueWithoutUploadedByInput[]
    createMany?: UploadedFileCreateManyUploadedByInputEnvelope
    set?: UploadedFileWhereUniqueInput | UploadedFileWhereUniqueInput[]
    disconnect?: UploadedFileWhereUniqueInput | UploadedFileWhereUniqueInput[]
    delete?: UploadedFileWhereUniqueInput | UploadedFileWhereUniqueInput[]
    connect?: UploadedFileWhereUniqueInput | UploadedFileWhereUniqueInput[]
    update?: UploadedFileUpdateWithWhereUniqueWithoutUploadedByInput | UploadedFileUpdateWithWhereUniqueWithoutUploadedByInput[]
    updateMany?: UploadedFileUpdateManyWithWhereWithoutUploadedByInput | UploadedFileUpdateManyWithWhereWithoutUploadedByInput[]
    deleteMany?: UploadedFileScalarWhereInput | UploadedFileScalarWhereInput[]
  }

  export type MessageUncheckedUpdateManyWithoutSenderNestedInput = {
    create?: XOR<MessageCreateWithoutSenderInput, MessageUncheckedCreateWithoutSenderInput> | MessageCreateWithoutSenderInput[] | MessageUncheckedCreateWithoutSenderInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutSenderInput | MessageCreateOrConnectWithoutSenderInput[]
    upsert?: MessageUpsertWithWhereUniqueWithoutSenderInput | MessageUpsertWithWhereUniqueWithoutSenderInput[]
    createMany?: MessageCreateManySenderInputEnvelope
    set?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    disconnect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    delete?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    update?: MessageUpdateWithWhereUniqueWithoutSenderInput | MessageUpdateWithWhereUniqueWithoutSenderInput[]
    updateMany?: MessageUpdateManyWithWhereWithoutSenderInput | MessageUpdateManyWithWhereWithoutSenderInput[]
    deleteMany?: MessageScalarWhereInput | MessageScalarWhereInput[]
  }

  export type MessageUncheckedUpdateManyWithoutRecipientNestedInput = {
    create?: XOR<MessageCreateWithoutRecipientInput, MessageUncheckedCreateWithoutRecipientInput> | MessageCreateWithoutRecipientInput[] | MessageUncheckedCreateWithoutRecipientInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutRecipientInput | MessageCreateOrConnectWithoutRecipientInput[]
    upsert?: MessageUpsertWithWhereUniqueWithoutRecipientInput | MessageUpsertWithWhereUniqueWithoutRecipientInput[]
    createMany?: MessageCreateManyRecipientInputEnvelope
    set?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    disconnect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    delete?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    update?: MessageUpdateWithWhereUniqueWithoutRecipientInput | MessageUpdateWithWhereUniqueWithoutRecipientInput[]
    updateMany?: MessageUpdateManyWithWhereWithoutRecipientInput | MessageUpdateManyWithWhereWithoutRecipientInput[]
    deleteMany?: MessageScalarWhereInput | MessageScalarWhereInput[]
  }

  export type UserPracticeProgressUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserPracticeProgressCreateWithoutUserInput, UserPracticeProgressUncheckedCreateWithoutUserInput> | UserPracticeProgressCreateWithoutUserInput[] | UserPracticeProgressUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserPracticeProgressCreateOrConnectWithoutUserInput | UserPracticeProgressCreateOrConnectWithoutUserInput[]
    upsert?: UserPracticeProgressUpsertWithWhereUniqueWithoutUserInput | UserPracticeProgressUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserPracticeProgressCreateManyUserInputEnvelope
    set?: UserPracticeProgressWhereUniqueInput | UserPracticeProgressWhereUniqueInput[]
    disconnect?: UserPracticeProgressWhereUniqueInput | UserPracticeProgressWhereUniqueInput[]
    delete?: UserPracticeProgressWhereUniqueInput | UserPracticeProgressWhereUniqueInput[]
    connect?: UserPracticeProgressWhereUniqueInput | UserPracticeProgressWhereUniqueInput[]
    update?: UserPracticeProgressUpdateWithWhereUniqueWithoutUserInput | UserPracticeProgressUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserPracticeProgressUpdateManyWithWhereWithoutUserInput | UserPracticeProgressUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserPracticeProgressScalarWhereInput | UserPracticeProgressScalarWhereInput[]
  }

  export type LoginLogUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<LoginLogCreateWithoutUserInput, LoginLogUncheckedCreateWithoutUserInput> | LoginLogCreateWithoutUserInput[] | LoginLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: LoginLogCreateOrConnectWithoutUserInput | LoginLogCreateOrConnectWithoutUserInput[]
    upsert?: LoginLogUpsertWithWhereUniqueWithoutUserInput | LoginLogUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: LoginLogCreateManyUserInputEnvelope
    set?: LoginLogWhereUniqueInput | LoginLogWhereUniqueInput[]
    disconnect?: LoginLogWhereUniqueInput | LoginLogWhereUniqueInput[]
    delete?: LoginLogWhereUniqueInput | LoginLogWhereUniqueInput[]
    connect?: LoginLogWhereUniqueInput | LoginLogWhereUniqueInput[]
    update?: LoginLogUpdateWithWhereUniqueWithoutUserInput | LoginLogUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: LoginLogUpdateManyWithWhereWithoutUserInput | LoginLogUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: LoginLogScalarWhereInput | LoginLogScalarWhereInput[]
  }

  export type CloneDiscussionUncheckedUpdateManyWithoutStudentNestedInput = {
    create?: XOR<CloneDiscussionCreateWithoutStudentInput, CloneDiscussionUncheckedCreateWithoutStudentInput> | CloneDiscussionCreateWithoutStudentInput[] | CloneDiscussionUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: CloneDiscussionCreateOrConnectWithoutStudentInput | CloneDiscussionCreateOrConnectWithoutStudentInput[]
    upsert?: CloneDiscussionUpsertWithWhereUniqueWithoutStudentInput | CloneDiscussionUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: CloneDiscussionCreateManyStudentInputEnvelope
    set?: CloneDiscussionWhereUniqueInput | CloneDiscussionWhereUniqueInput[]
    disconnect?: CloneDiscussionWhereUniqueInput | CloneDiscussionWhereUniqueInput[]
    delete?: CloneDiscussionWhereUniqueInput | CloneDiscussionWhereUniqueInput[]
    connect?: CloneDiscussionWhereUniqueInput | CloneDiscussionWhereUniqueInput[]
    update?: CloneDiscussionUpdateWithWhereUniqueWithoutStudentInput | CloneDiscussionUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: CloneDiscussionUpdateManyWithWhereWithoutStudentInput | CloneDiscussionUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: CloneDiscussionScalarWhereInput | CloneDiscussionScalarWhereInput[]
  }

  export type DiscussionMessageUncheckedUpdateManyWithoutSenderNestedInput = {
    create?: XOR<DiscussionMessageCreateWithoutSenderInput, DiscussionMessageUncheckedCreateWithoutSenderInput> | DiscussionMessageCreateWithoutSenderInput[] | DiscussionMessageUncheckedCreateWithoutSenderInput[]
    connectOrCreate?: DiscussionMessageCreateOrConnectWithoutSenderInput | DiscussionMessageCreateOrConnectWithoutSenderInput[]
    upsert?: DiscussionMessageUpsertWithWhereUniqueWithoutSenderInput | DiscussionMessageUpsertWithWhereUniqueWithoutSenderInput[]
    createMany?: DiscussionMessageCreateManySenderInputEnvelope
    set?: DiscussionMessageWhereUniqueInput | DiscussionMessageWhereUniqueInput[]
    disconnect?: DiscussionMessageWhereUniqueInput | DiscussionMessageWhereUniqueInput[]
    delete?: DiscussionMessageWhereUniqueInput | DiscussionMessageWhereUniqueInput[]
    connect?: DiscussionMessageWhereUniqueInput | DiscussionMessageWhereUniqueInput[]
    update?: DiscussionMessageUpdateWithWhereUniqueWithoutSenderInput | DiscussionMessageUpdateWithWhereUniqueWithoutSenderInput[]
    updateMany?: DiscussionMessageUpdateManyWithWhereWithoutSenderInput | DiscussionMessageUpdateManyWithWhereWithoutSenderInput[]
    deleteMany?: DiscussionMessageScalarWhereInput | DiscussionMessageScalarWhereInput[]
  }

  export type UserCreateNestedManyWithoutSchoolInput = {
    create?: XOR<UserCreateWithoutSchoolInput, UserUncheckedCreateWithoutSchoolInput> | UserCreateWithoutSchoolInput[] | UserUncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: UserCreateOrConnectWithoutSchoolInput | UserCreateOrConnectWithoutSchoolInput[]
    createMany?: UserCreateManySchoolInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type UserUncheckedCreateNestedManyWithoutSchoolInput = {
    create?: XOR<UserCreateWithoutSchoolInput, UserUncheckedCreateWithoutSchoolInput> | UserCreateWithoutSchoolInput[] | UserUncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: UserCreateOrConnectWithoutSchoolInput | UserCreateOrConnectWithoutSchoolInput[]
    createMany?: UserCreateManySchoolInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type UserUpdateManyWithoutSchoolNestedInput = {
    create?: XOR<UserCreateWithoutSchoolInput, UserUncheckedCreateWithoutSchoolInput> | UserCreateWithoutSchoolInput[] | UserUncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: UserCreateOrConnectWithoutSchoolInput | UserCreateOrConnectWithoutSchoolInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutSchoolInput | UserUpsertWithWhereUniqueWithoutSchoolInput[]
    createMany?: UserCreateManySchoolInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutSchoolInput | UserUpdateWithWhereUniqueWithoutSchoolInput[]
    updateMany?: UserUpdateManyWithWhereWithoutSchoolInput | UserUpdateManyWithWhereWithoutSchoolInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type UserUncheckedUpdateManyWithoutSchoolNestedInput = {
    create?: XOR<UserCreateWithoutSchoolInput, UserUncheckedCreateWithoutSchoolInput> | UserCreateWithoutSchoolInput[] | UserUncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: UserCreateOrConnectWithoutSchoolInput | UserCreateOrConnectWithoutSchoolInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutSchoolInput | UserUpsertWithWhereUniqueWithoutSchoolInput[]
    createMany?: UserCreateManySchoolInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutSchoolInput | UserUpdateWithWhereUniqueWithoutSchoolInput[]
    updateMany?: UserUpdateManyWithWhereWithoutSchoolInput | UserUpdateManyWithWhereWithoutSchoolInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type UserCreateNestedOneWithoutDemographicsInput = {
    create?: XOR<UserCreateWithoutDemographicsInput, UserUncheckedCreateWithoutDemographicsInput>
    connectOrCreate?: UserCreateOrConnectWithoutDemographicsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutDemographicsNestedInput = {
    create?: XOR<UserCreateWithoutDemographicsInput, UserUncheckedCreateWithoutDemographicsInput>
    connectOrCreate?: UserCreateOrConnectWithoutDemographicsInput
    upsert?: UserUpsertWithoutDemographicsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutDemographicsInput, UserUpdateWithoutDemographicsInput>, UserUncheckedUpdateWithoutDemographicsInput>
  }

  export type UserCreateNestedOneWithoutLoginLogsInput = {
    create?: XOR<UserCreateWithoutLoginLogsInput, UserUncheckedCreateWithoutLoginLogsInput>
    connectOrCreate?: UserCreateOrConnectWithoutLoginLogsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutLoginLogsNestedInput = {
    create?: XOR<UserCreateWithoutLoginLogsInput, UserUncheckedCreateWithoutLoginLogsInput>
    connectOrCreate?: UserCreateOrConnectWithoutLoginLogsInput
    upsert?: UserUpsertWithoutLoginLogsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutLoginLogsInput, UserUpdateWithoutLoginLogsInput>, UserUncheckedUpdateWithoutLoginLogsInput>
  }

  export type HelpTopicCreateNestedManyWithoutAnalysisQuestionInput = {
    create?: XOR<HelpTopicCreateWithoutAnalysisQuestionInput, HelpTopicUncheckedCreateWithoutAnalysisQuestionInput> | HelpTopicCreateWithoutAnalysisQuestionInput[] | HelpTopicUncheckedCreateWithoutAnalysisQuestionInput[]
    connectOrCreate?: HelpTopicCreateOrConnectWithoutAnalysisQuestionInput | HelpTopicCreateOrConnectWithoutAnalysisQuestionInput[]
    createMany?: HelpTopicCreateManyAnalysisQuestionInputEnvelope
    connect?: HelpTopicWhereUniqueInput | HelpTopicWhereUniqueInput[]
  }

  export type HelpTopicUncheckedCreateNestedManyWithoutAnalysisQuestionInput = {
    create?: XOR<HelpTopicCreateWithoutAnalysisQuestionInput, HelpTopicUncheckedCreateWithoutAnalysisQuestionInput> | HelpTopicCreateWithoutAnalysisQuestionInput[] | HelpTopicUncheckedCreateWithoutAnalysisQuestionInput[]
    connectOrCreate?: HelpTopicCreateOrConnectWithoutAnalysisQuestionInput | HelpTopicCreateOrConnectWithoutAnalysisQuestionInput[]
    createMany?: HelpTopicCreateManyAnalysisQuestionInputEnvelope
    connect?: HelpTopicWhereUniqueInput | HelpTopicWhereUniqueInput[]
  }

  export type HelpTopicUpdateManyWithoutAnalysisQuestionNestedInput = {
    create?: XOR<HelpTopicCreateWithoutAnalysisQuestionInput, HelpTopicUncheckedCreateWithoutAnalysisQuestionInput> | HelpTopicCreateWithoutAnalysisQuestionInput[] | HelpTopicUncheckedCreateWithoutAnalysisQuestionInput[]
    connectOrCreate?: HelpTopicCreateOrConnectWithoutAnalysisQuestionInput | HelpTopicCreateOrConnectWithoutAnalysisQuestionInput[]
    upsert?: HelpTopicUpsertWithWhereUniqueWithoutAnalysisQuestionInput | HelpTopicUpsertWithWhereUniqueWithoutAnalysisQuestionInput[]
    createMany?: HelpTopicCreateManyAnalysisQuestionInputEnvelope
    set?: HelpTopicWhereUniqueInput | HelpTopicWhereUniqueInput[]
    disconnect?: HelpTopicWhereUniqueInput | HelpTopicWhereUniqueInput[]
    delete?: HelpTopicWhereUniqueInput | HelpTopicWhereUniqueInput[]
    connect?: HelpTopicWhereUniqueInput | HelpTopicWhereUniqueInput[]
    update?: HelpTopicUpdateWithWhereUniqueWithoutAnalysisQuestionInput | HelpTopicUpdateWithWhereUniqueWithoutAnalysisQuestionInput[]
    updateMany?: HelpTopicUpdateManyWithWhereWithoutAnalysisQuestionInput | HelpTopicUpdateManyWithWhereWithoutAnalysisQuestionInput[]
    deleteMany?: HelpTopicScalarWhereInput | HelpTopicScalarWhereInput[]
  }

  export type HelpTopicUncheckedUpdateManyWithoutAnalysisQuestionNestedInput = {
    create?: XOR<HelpTopicCreateWithoutAnalysisQuestionInput, HelpTopicUncheckedCreateWithoutAnalysisQuestionInput> | HelpTopicCreateWithoutAnalysisQuestionInput[] | HelpTopicUncheckedCreateWithoutAnalysisQuestionInput[]
    connectOrCreate?: HelpTopicCreateOrConnectWithoutAnalysisQuestionInput | HelpTopicCreateOrConnectWithoutAnalysisQuestionInput[]
    upsert?: HelpTopicUpsertWithWhereUniqueWithoutAnalysisQuestionInput | HelpTopicUpsertWithWhereUniqueWithoutAnalysisQuestionInput[]
    createMany?: HelpTopicCreateManyAnalysisQuestionInputEnvelope
    set?: HelpTopicWhereUniqueInput | HelpTopicWhereUniqueInput[]
    disconnect?: HelpTopicWhereUniqueInput | HelpTopicWhereUniqueInput[]
    delete?: HelpTopicWhereUniqueInput | HelpTopicWhereUniqueInput[]
    connect?: HelpTopicWhereUniqueInput | HelpTopicWhereUniqueInput[]
    update?: HelpTopicUpdateWithWhereUniqueWithoutAnalysisQuestionInput | HelpTopicUpdateWithWhereUniqueWithoutAnalysisQuestionInput[]
    updateMany?: HelpTopicUpdateManyWithWhereWithoutAnalysisQuestionInput | HelpTopicUpdateManyWithWhereWithoutAnalysisQuestionInput[]
    deleteMany?: HelpTopicScalarWhereInput | HelpTopicScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutAssignedFilesInput = {
    create?: XOR<UserCreateWithoutAssignedFilesInput, UserUncheckedCreateWithoutAssignedFilesInput>
    connectOrCreate?: UserCreateOrConnectWithoutAssignedFilesInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutUploadedFilesInput = {
    create?: XOR<UserCreateWithoutUploadedFilesInput, UserUncheckedCreateWithoutUploadedFilesInput>
    connectOrCreate?: UserCreateOrConnectWithoutUploadedFilesInput
    connect?: UserWhereUniqueInput
  }

  export type MessageCreateNestedManyWithoutCloneInput = {
    create?: XOR<MessageCreateWithoutCloneInput, MessageUncheckedCreateWithoutCloneInput> | MessageCreateWithoutCloneInput[] | MessageUncheckedCreateWithoutCloneInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutCloneInput | MessageCreateOrConnectWithoutCloneInput[]
    createMany?: MessageCreateManyCloneInputEnvelope
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
  }

  export type CloneDiscussionCreateNestedManyWithoutCloneInput = {
    create?: XOR<CloneDiscussionCreateWithoutCloneInput, CloneDiscussionUncheckedCreateWithoutCloneInput> | CloneDiscussionCreateWithoutCloneInput[] | CloneDiscussionUncheckedCreateWithoutCloneInput[]
    connectOrCreate?: CloneDiscussionCreateOrConnectWithoutCloneInput | CloneDiscussionCreateOrConnectWithoutCloneInput[]
    createMany?: CloneDiscussionCreateManyCloneInputEnvelope
    connect?: CloneDiscussionWhereUniqueInput | CloneDiscussionWhereUniqueInput[]
  }

  export type MessageUncheckedCreateNestedManyWithoutCloneInput = {
    create?: XOR<MessageCreateWithoutCloneInput, MessageUncheckedCreateWithoutCloneInput> | MessageCreateWithoutCloneInput[] | MessageUncheckedCreateWithoutCloneInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutCloneInput | MessageCreateOrConnectWithoutCloneInput[]
    createMany?: MessageCreateManyCloneInputEnvelope
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
  }

  export type CloneDiscussionUncheckedCreateNestedManyWithoutCloneInput = {
    create?: XOR<CloneDiscussionCreateWithoutCloneInput, CloneDiscussionUncheckedCreateWithoutCloneInput> | CloneDiscussionCreateWithoutCloneInput[] | CloneDiscussionUncheckedCreateWithoutCloneInput[]
    connectOrCreate?: CloneDiscussionCreateOrConnectWithoutCloneInput | CloneDiscussionCreateOrConnectWithoutCloneInput[]
    createMany?: CloneDiscussionCreateManyCloneInputEnvelope
    connect?: CloneDiscussionWhereUniqueInput | CloneDiscussionWhereUniqueInput[]
  }

  export type UserUpdateOneWithoutAssignedFilesNestedInput = {
    create?: XOR<UserCreateWithoutAssignedFilesInput, UserUncheckedCreateWithoutAssignedFilesInput>
    connectOrCreate?: UserCreateOrConnectWithoutAssignedFilesInput
    upsert?: UserUpsertWithoutAssignedFilesInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAssignedFilesInput, UserUpdateWithoutAssignedFilesInput>, UserUncheckedUpdateWithoutAssignedFilesInput>
  }

  export type UserUpdateOneRequiredWithoutUploadedFilesNestedInput = {
    create?: XOR<UserCreateWithoutUploadedFilesInput, UserUncheckedCreateWithoutUploadedFilesInput>
    connectOrCreate?: UserCreateOrConnectWithoutUploadedFilesInput
    upsert?: UserUpsertWithoutUploadedFilesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutUploadedFilesInput, UserUpdateWithoutUploadedFilesInput>, UserUncheckedUpdateWithoutUploadedFilesInput>
  }

  export type MessageUpdateManyWithoutCloneNestedInput = {
    create?: XOR<MessageCreateWithoutCloneInput, MessageUncheckedCreateWithoutCloneInput> | MessageCreateWithoutCloneInput[] | MessageUncheckedCreateWithoutCloneInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutCloneInput | MessageCreateOrConnectWithoutCloneInput[]
    upsert?: MessageUpsertWithWhereUniqueWithoutCloneInput | MessageUpsertWithWhereUniqueWithoutCloneInput[]
    createMany?: MessageCreateManyCloneInputEnvelope
    set?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    disconnect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    delete?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    update?: MessageUpdateWithWhereUniqueWithoutCloneInput | MessageUpdateWithWhereUniqueWithoutCloneInput[]
    updateMany?: MessageUpdateManyWithWhereWithoutCloneInput | MessageUpdateManyWithWhereWithoutCloneInput[]
    deleteMany?: MessageScalarWhereInput | MessageScalarWhereInput[]
  }

  export type CloneDiscussionUpdateManyWithoutCloneNestedInput = {
    create?: XOR<CloneDiscussionCreateWithoutCloneInput, CloneDiscussionUncheckedCreateWithoutCloneInput> | CloneDiscussionCreateWithoutCloneInput[] | CloneDiscussionUncheckedCreateWithoutCloneInput[]
    connectOrCreate?: CloneDiscussionCreateOrConnectWithoutCloneInput | CloneDiscussionCreateOrConnectWithoutCloneInput[]
    upsert?: CloneDiscussionUpsertWithWhereUniqueWithoutCloneInput | CloneDiscussionUpsertWithWhereUniqueWithoutCloneInput[]
    createMany?: CloneDiscussionCreateManyCloneInputEnvelope
    set?: CloneDiscussionWhereUniqueInput | CloneDiscussionWhereUniqueInput[]
    disconnect?: CloneDiscussionWhereUniqueInput | CloneDiscussionWhereUniqueInput[]
    delete?: CloneDiscussionWhereUniqueInput | CloneDiscussionWhereUniqueInput[]
    connect?: CloneDiscussionWhereUniqueInput | CloneDiscussionWhereUniqueInput[]
    update?: CloneDiscussionUpdateWithWhereUniqueWithoutCloneInput | CloneDiscussionUpdateWithWhereUniqueWithoutCloneInput[]
    updateMany?: CloneDiscussionUpdateManyWithWhereWithoutCloneInput | CloneDiscussionUpdateManyWithWhereWithoutCloneInput[]
    deleteMany?: CloneDiscussionScalarWhereInput | CloneDiscussionScalarWhereInput[]
  }

  export type MessageUncheckedUpdateManyWithoutCloneNestedInput = {
    create?: XOR<MessageCreateWithoutCloneInput, MessageUncheckedCreateWithoutCloneInput> | MessageCreateWithoutCloneInput[] | MessageUncheckedCreateWithoutCloneInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutCloneInput | MessageCreateOrConnectWithoutCloneInput[]
    upsert?: MessageUpsertWithWhereUniqueWithoutCloneInput | MessageUpsertWithWhereUniqueWithoutCloneInput[]
    createMany?: MessageCreateManyCloneInputEnvelope
    set?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    disconnect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    delete?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    update?: MessageUpdateWithWhereUniqueWithoutCloneInput | MessageUpdateWithWhereUniqueWithoutCloneInput[]
    updateMany?: MessageUpdateManyWithWhereWithoutCloneInput | MessageUpdateManyWithWhereWithoutCloneInput[]
    deleteMany?: MessageScalarWhereInput | MessageScalarWhereInput[]
  }

  export type CloneDiscussionUncheckedUpdateManyWithoutCloneNestedInput = {
    create?: XOR<CloneDiscussionCreateWithoutCloneInput, CloneDiscussionUncheckedCreateWithoutCloneInput> | CloneDiscussionCreateWithoutCloneInput[] | CloneDiscussionUncheckedCreateWithoutCloneInput[]
    connectOrCreate?: CloneDiscussionCreateOrConnectWithoutCloneInput | CloneDiscussionCreateOrConnectWithoutCloneInput[]
    upsert?: CloneDiscussionUpsertWithWhereUniqueWithoutCloneInput | CloneDiscussionUpsertWithWhereUniqueWithoutCloneInput[]
    createMany?: CloneDiscussionCreateManyCloneInputEnvelope
    set?: CloneDiscussionWhereUniqueInput | CloneDiscussionWhereUniqueInput[]
    disconnect?: CloneDiscussionWhereUniqueInput | CloneDiscussionWhereUniqueInput[]
    delete?: CloneDiscussionWhereUniqueInput | CloneDiscussionWhereUniqueInput[]
    connect?: CloneDiscussionWhereUniqueInput | CloneDiscussionWhereUniqueInput[]
    update?: CloneDiscussionUpdateWithWhereUniqueWithoutCloneInput | CloneDiscussionUpdateWithWhereUniqueWithoutCloneInput[]
    updateMany?: CloneDiscussionUpdateManyWithWhereWithoutCloneInput | CloneDiscussionUpdateManyWithWhereWithoutCloneInput[]
    deleteMany?: CloneDiscussionScalarWhereInput | CloneDiscussionScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutDiscussionsInput = {
    create?: XOR<UserCreateWithoutDiscussionsInput, UserUncheckedCreateWithoutDiscussionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutDiscussionsInput
    connect?: UserWhereUniqueInput
  }

  export type UploadedFileCreateNestedOneWithoutCloneDiscussionsInput = {
    create?: XOR<UploadedFileCreateWithoutCloneDiscussionsInput, UploadedFileUncheckedCreateWithoutCloneDiscussionsInput>
    connectOrCreate?: UploadedFileCreateOrConnectWithoutCloneDiscussionsInput
    connect?: UploadedFileWhereUniqueInput
  }

  export type PracticeCloneCreateNestedOneWithoutCloneDiscussionsInput = {
    create?: XOR<PracticeCloneCreateWithoutCloneDiscussionsInput, PracticeCloneUncheckedCreateWithoutCloneDiscussionsInput>
    connectOrCreate?: PracticeCloneCreateOrConnectWithoutCloneDiscussionsInput
    connect?: PracticeCloneWhereUniqueInput
  }

  export type DiscussionMessageCreateNestedManyWithoutDiscussionInput = {
    create?: XOR<DiscussionMessageCreateWithoutDiscussionInput, DiscussionMessageUncheckedCreateWithoutDiscussionInput> | DiscussionMessageCreateWithoutDiscussionInput[] | DiscussionMessageUncheckedCreateWithoutDiscussionInput[]
    connectOrCreate?: DiscussionMessageCreateOrConnectWithoutDiscussionInput | DiscussionMessageCreateOrConnectWithoutDiscussionInput[]
    createMany?: DiscussionMessageCreateManyDiscussionInputEnvelope
    connect?: DiscussionMessageWhereUniqueInput | DiscussionMessageWhereUniqueInput[]
  }

  export type DiscussionMessageUncheckedCreateNestedManyWithoutDiscussionInput = {
    create?: XOR<DiscussionMessageCreateWithoutDiscussionInput, DiscussionMessageUncheckedCreateWithoutDiscussionInput> | DiscussionMessageCreateWithoutDiscussionInput[] | DiscussionMessageUncheckedCreateWithoutDiscussionInput[]
    connectOrCreate?: DiscussionMessageCreateOrConnectWithoutDiscussionInput | DiscussionMessageCreateOrConnectWithoutDiscussionInput[]
    createMany?: DiscussionMessageCreateManyDiscussionInputEnvelope
    connect?: DiscussionMessageWhereUniqueInput | DiscussionMessageWhereUniqueInput[]
  }

  export type UserUpdateOneRequiredWithoutDiscussionsNestedInput = {
    create?: XOR<UserCreateWithoutDiscussionsInput, UserUncheckedCreateWithoutDiscussionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutDiscussionsInput
    upsert?: UserUpsertWithoutDiscussionsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutDiscussionsInput, UserUpdateWithoutDiscussionsInput>, UserUncheckedUpdateWithoutDiscussionsInput>
  }

  export type UploadedFileUpdateOneWithoutCloneDiscussionsNestedInput = {
    create?: XOR<UploadedFileCreateWithoutCloneDiscussionsInput, UploadedFileUncheckedCreateWithoutCloneDiscussionsInput>
    connectOrCreate?: UploadedFileCreateOrConnectWithoutCloneDiscussionsInput
    upsert?: UploadedFileUpsertWithoutCloneDiscussionsInput
    disconnect?: UploadedFileWhereInput | boolean
    delete?: UploadedFileWhereInput | boolean
    connect?: UploadedFileWhereUniqueInput
    update?: XOR<XOR<UploadedFileUpdateToOneWithWhereWithoutCloneDiscussionsInput, UploadedFileUpdateWithoutCloneDiscussionsInput>, UploadedFileUncheckedUpdateWithoutCloneDiscussionsInput>
  }

  export type PracticeCloneUpdateOneWithoutCloneDiscussionsNestedInput = {
    create?: XOR<PracticeCloneCreateWithoutCloneDiscussionsInput, PracticeCloneUncheckedCreateWithoutCloneDiscussionsInput>
    connectOrCreate?: PracticeCloneCreateOrConnectWithoutCloneDiscussionsInput
    upsert?: PracticeCloneUpsertWithoutCloneDiscussionsInput
    disconnect?: PracticeCloneWhereInput | boolean
    delete?: PracticeCloneWhereInput | boolean
    connect?: PracticeCloneWhereUniqueInput
    update?: XOR<XOR<PracticeCloneUpdateToOneWithWhereWithoutCloneDiscussionsInput, PracticeCloneUpdateWithoutCloneDiscussionsInput>, PracticeCloneUncheckedUpdateWithoutCloneDiscussionsInput>
  }

  export type DiscussionMessageUpdateManyWithoutDiscussionNestedInput = {
    create?: XOR<DiscussionMessageCreateWithoutDiscussionInput, DiscussionMessageUncheckedCreateWithoutDiscussionInput> | DiscussionMessageCreateWithoutDiscussionInput[] | DiscussionMessageUncheckedCreateWithoutDiscussionInput[]
    connectOrCreate?: DiscussionMessageCreateOrConnectWithoutDiscussionInput | DiscussionMessageCreateOrConnectWithoutDiscussionInput[]
    upsert?: DiscussionMessageUpsertWithWhereUniqueWithoutDiscussionInput | DiscussionMessageUpsertWithWhereUniqueWithoutDiscussionInput[]
    createMany?: DiscussionMessageCreateManyDiscussionInputEnvelope
    set?: DiscussionMessageWhereUniqueInput | DiscussionMessageWhereUniqueInput[]
    disconnect?: DiscussionMessageWhereUniqueInput | DiscussionMessageWhereUniqueInput[]
    delete?: DiscussionMessageWhereUniqueInput | DiscussionMessageWhereUniqueInput[]
    connect?: DiscussionMessageWhereUniqueInput | DiscussionMessageWhereUniqueInput[]
    update?: DiscussionMessageUpdateWithWhereUniqueWithoutDiscussionInput | DiscussionMessageUpdateWithWhereUniqueWithoutDiscussionInput[]
    updateMany?: DiscussionMessageUpdateManyWithWhereWithoutDiscussionInput | DiscussionMessageUpdateManyWithWhereWithoutDiscussionInput[]
    deleteMany?: DiscussionMessageScalarWhereInput | DiscussionMessageScalarWhereInput[]
  }

  export type DiscussionMessageUncheckedUpdateManyWithoutDiscussionNestedInput = {
    create?: XOR<DiscussionMessageCreateWithoutDiscussionInput, DiscussionMessageUncheckedCreateWithoutDiscussionInput> | DiscussionMessageCreateWithoutDiscussionInput[] | DiscussionMessageUncheckedCreateWithoutDiscussionInput[]
    connectOrCreate?: DiscussionMessageCreateOrConnectWithoutDiscussionInput | DiscussionMessageCreateOrConnectWithoutDiscussionInput[]
    upsert?: DiscussionMessageUpsertWithWhereUniqueWithoutDiscussionInput | DiscussionMessageUpsertWithWhereUniqueWithoutDiscussionInput[]
    createMany?: DiscussionMessageCreateManyDiscussionInputEnvelope
    set?: DiscussionMessageWhereUniqueInput | DiscussionMessageWhereUniqueInput[]
    disconnect?: DiscussionMessageWhereUniqueInput | DiscussionMessageWhereUniqueInput[]
    delete?: DiscussionMessageWhereUniqueInput | DiscussionMessageWhereUniqueInput[]
    connect?: DiscussionMessageWhereUniqueInput | DiscussionMessageWhereUniqueInput[]
    update?: DiscussionMessageUpdateWithWhereUniqueWithoutDiscussionInput | DiscussionMessageUpdateWithWhereUniqueWithoutDiscussionInput[]
    updateMany?: DiscussionMessageUpdateManyWithWhereWithoutDiscussionInput | DiscussionMessageUpdateManyWithWhereWithoutDiscussionInput[]
    deleteMany?: DiscussionMessageScalarWhereInput | DiscussionMessageScalarWhereInput[]
  }

  export type CloneDiscussionCreateNestedOneWithoutMessagesInput = {
    create?: XOR<CloneDiscussionCreateWithoutMessagesInput, CloneDiscussionUncheckedCreateWithoutMessagesInput>
    connectOrCreate?: CloneDiscussionCreateOrConnectWithoutMessagesInput
    connect?: CloneDiscussionWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutDiscussionMessagesSentInput = {
    create?: XOR<UserCreateWithoutDiscussionMessagesSentInput, UserUncheckedCreateWithoutDiscussionMessagesSentInput>
    connectOrCreate?: UserCreateOrConnectWithoutDiscussionMessagesSentInput
    connect?: UserWhereUniqueInput
  }

  export type CloneDiscussionUpdateOneRequiredWithoutMessagesNestedInput = {
    create?: XOR<CloneDiscussionCreateWithoutMessagesInput, CloneDiscussionUncheckedCreateWithoutMessagesInput>
    connectOrCreate?: CloneDiscussionCreateOrConnectWithoutMessagesInput
    upsert?: CloneDiscussionUpsertWithoutMessagesInput
    connect?: CloneDiscussionWhereUniqueInput
    update?: XOR<XOR<CloneDiscussionUpdateToOneWithWhereWithoutMessagesInput, CloneDiscussionUpdateWithoutMessagesInput>, CloneDiscussionUncheckedUpdateWithoutMessagesInput>
  }

  export type UserUpdateOneRequiredWithoutDiscussionMessagesSentNestedInput = {
    create?: XOR<UserCreateWithoutDiscussionMessagesSentInput, UserUncheckedCreateWithoutDiscussionMessagesSentInput>
    connectOrCreate?: UserCreateOrConnectWithoutDiscussionMessagesSentInput
    upsert?: UserUpsertWithoutDiscussionMessagesSentInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutDiscussionMessagesSentInput, UserUpdateWithoutDiscussionMessagesSentInput>, UserUncheckedUpdateWithoutDiscussionMessagesSentInput>
  }

  export type UserCreateNestedOneWithoutSentMessagesInput = {
    create?: XOR<UserCreateWithoutSentMessagesInput, UserUncheckedCreateWithoutSentMessagesInput>
    connectOrCreate?: UserCreateOrConnectWithoutSentMessagesInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutReceivedMessagesInput = {
    create?: XOR<UserCreateWithoutReceivedMessagesInput, UserUncheckedCreateWithoutReceivedMessagesInput>
    connectOrCreate?: UserCreateOrConnectWithoutReceivedMessagesInput
    connect?: UserWhereUniqueInput
  }

  export type UploadedFileCreateNestedOneWithoutMessagesInput = {
    create?: XOR<UploadedFileCreateWithoutMessagesInput, UploadedFileUncheckedCreateWithoutMessagesInput>
    connectOrCreate?: UploadedFileCreateOrConnectWithoutMessagesInput
    connect?: UploadedFileWhereUniqueInput
  }

  export type NullableBoolFieldUpdateOperationsInput = {
    set?: boolean | null
  }

  export type UserUpdateOneRequiredWithoutSentMessagesNestedInput = {
    create?: XOR<UserCreateWithoutSentMessagesInput, UserUncheckedCreateWithoutSentMessagesInput>
    connectOrCreate?: UserCreateOrConnectWithoutSentMessagesInput
    upsert?: UserUpsertWithoutSentMessagesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSentMessagesInput, UserUpdateWithoutSentMessagesInput>, UserUncheckedUpdateWithoutSentMessagesInput>
  }

  export type UserUpdateOneRequiredWithoutReceivedMessagesNestedInput = {
    create?: XOR<UserCreateWithoutReceivedMessagesInput, UserUncheckedCreateWithoutReceivedMessagesInput>
    connectOrCreate?: UserCreateOrConnectWithoutReceivedMessagesInput
    upsert?: UserUpsertWithoutReceivedMessagesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutReceivedMessagesInput, UserUpdateWithoutReceivedMessagesInput>, UserUncheckedUpdateWithoutReceivedMessagesInput>
  }

  export type UploadedFileUpdateOneWithoutMessagesNestedInput = {
    create?: XOR<UploadedFileCreateWithoutMessagesInput, UploadedFileUncheckedCreateWithoutMessagesInput>
    connectOrCreate?: UploadedFileCreateOrConnectWithoutMessagesInput
    upsert?: UploadedFileUpsertWithoutMessagesInput
    disconnect?: UploadedFileWhereInput | boolean
    delete?: UploadedFileWhereInput | boolean
    connect?: UploadedFileWhereUniqueInput
    update?: XOR<XOR<UploadedFileUpdateToOneWithWhereWithoutMessagesInput, UploadedFileUpdateWithoutMessagesInput>, UploadedFileUncheckedUpdateWithoutMessagesInput>
  }

  export type PracticeAnswerCreateNestedManyWithoutPracticeCloneInput = {
    create?: XOR<PracticeAnswerCreateWithoutPracticeCloneInput, PracticeAnswerUncheckedCreateWithoutPracticeCloneInput> | PracticeAnswerCreateWithoutPracticeCloneInput[] | PracticeAnswerUncheckedCreateWithoutPracticeCloneInput[]
    connectOrCreate?: PracticeAnswerCreateOrConnectWithoutPracticeCloneInput | PracticeAnswerCreateOrConnectWithoutPracticeCloneInput[]
    createMany?: PracticeAnswerCreateManyPracticeCloneInputEnvelope
    connect?: PracticeAnswerWhereUniqueInput | PracticeAnswerWhereUniqueInput[]
  }

  export type UserPracticeProgressCreateNestedManyWithoutPracticeCloneInput = {
    create?: XOR<UserPracticeProgressCreateWithoutPracticeCloneInput, UserPracticeProgressUncheckedCreateWithoutPracticeCloneInput> | UserPracticeProgressCreateWithoutPracticeCloneInput[] | UserPracticeProgressUncheckedCreateWithoutPracticeCloneInput[]
    connectOrCreate?: UserPracticeProgressCreateOrConnectWithoutPracticeCloneInput | UserPracticeProgressCreateOrConnectWithoutPracticeCloneInput[]
    createMany?: UserPracticeProgressCreateManyPracticeCloneInputEnvelope
    connect?: UserPracticeProgressWhereUniqueInput | UserPracticeProgressWhereUniqueInput[]
  }

  export type CloneDiscussionCreateNestedManyWithoutPracticeCloneInput = {
    create?: XOR<CloneDiscussionCreateWithoutPracticeCloneInput, CloneDiscussionUncheckedCreateWithoutPracticeCloneInput> | CloneDiscussionCreateWithoutPracticeCloneInput[] | CloneDiscussionUncheckedCreateWithoutPracticeCloneInput[]
    connectOrCreate?: CloneDiscussionCreateOrConnectWithoutPracticeCloneInput | CloneDiscussionCreateOrConnectWithoutPracticeCloneInput[]
    createMany?: CloneDiscussionCreateManyPracticeCloneInputEnvelope
    connect?: CloneDiscussionWhereUniqueInput | CloneDiscussionWhereUniqueInput[]
  }

  export type PracticeAnswerUncheckedCreateNestedManyWithoutPracticeCloneInput = {
    create?: XOR<PracticeAnswerCreateWithoutPracticeCloneInput, PracticeAnswerUncheckedCreateWithoutPracticeCloneInput> | PracticeAnswerCreateWithoutPracticeCloneInput[] | PracticeAnswerUncheckedCreateWithoutPracticeCloneInput[]
    connectOrCreate?: PracticeAnswerCreateOrConnectWithoutPracticeCloneInput | PracticeAnswerCreateOrConnectWithoutPracticeCloneInput[]
    createMany?: PracticeAnswerCreateManyPracticeCloneInputEnvelope
    connect?: PracticeAnswerWhereUniqueInput | PracticeAnswerWhereUniqueInput[]
  }

  export type UserPracticeProgressUncheckedCreateNestedManyWithoutPracticeCloneInput = {
    create?: XOR<UserPracticeProgressCreateWithoutPracticeCloneInput, UserPracticeProgressUncheckedCreateWithoutPracticeCloneInput> | UserPracticeProgressCreateWithoutPracticeCloneInput[] | UserPracticeProgressUncheckedCreateWithoutPracticeCloneInput[]
    connectOrCreate?: UserPracticeProgressCreateOrConnectWithoutPracticeCloneInput | UserPracticeProgressCreateOrConnectWithoutPracticeCloneInput[]
    createMany?: UserPracticeProgressCreateManyPracticeCloneInputEnvelope
    connect?: UserPracticeProgressWhereUniqueInput | UserPracticeProgressWhereUniqueInput[]
  }

  export type CloneDiscussionUncheckedCreateNestedManyWithoutPracticeCloneInput = {
    create?: XOR<CloneDiscussionCreateWithoutPracticeCloneInput, CloneDiscussionUncheckedCreateWithoutPracticeCloneInput> | CloneDiscussionCreateWithoutPracticeCloneInput[] | CloneDiscussionUncheckedCreateWithoutPracticeCloneInput[]
    connectOrCreate?: CloneDiscussionCreateOrConnectWithoutPracticeCloneInput | CloneDiscussionCreateOrConnectWithoutPracticeCloneInput[]
    createMany?: CloneDiscussionCreateManyPracticeCloneInputEnvelope
    connect?: CloneDiscussionWhereUniqueInput | CloneDiscussionWhereUniqueInput[]
  }

  export type PracticeAnswerUpdateManyWithoutPracticeCloneNestedInput = {
    create?: XOR<PracticeAnswerCreateWithoutPracticeCloneInput, PracticeAnswerUncheckedCreateWithoutPracticeCloneInput> | PracticeAnswerCreateWithoutPracticeCloneInput[] | PracticeAnswerUncheckedCreateWithoutPracticeCloneInput[]
    connectOrCreate?: PracticeAnswerCreateOrConnectWithoutPracticeCloneInput | PracticeAnswerCreateOrConnectWithoutPracticeCloneInput[]
    upsert?: PracticeAnswerUpsertWithWhereUniqueWithoutPracticeCloneInput | PracticeAnswerUpsertWithWhereUniqueWithoutPracticeCloneInput[]
    createMany?: PracticeAnswerCreateManyPracticeCloneInputEnvelope
    set?: PracticeAnswerWhereUniqueInput | PracticeAnswerWhereUniqueInput[]
    disconnect?: PracticeAnswerWhereUniqueInput | PracticeAnswerWhereUniqueInput[]
    delete?: PracticeAnswerWhereUniqueInput | PracticeAnswerWhereUniqueInput[]
    connect?: PracticeAnswerWhereUniqueInput | PracticeAnswerWhereUniqueInput[]
    update?: PracticeAnswerUpdateWithWhereUniqueWithoutPracticeCloneInput | PracticeAnswerUpdateWithWhereUniqueWithoutPracticeCloneInput[]
    updateMany?: PracticeAnswerUpdateManyWithWhereWithoutPracticeCloneInput | PracticeAnswerUpdateManyWithWhereWithoutPracticeCloneInput[]
    deleteMany?: PracticeAnswerScalarWhereInput | PracticeAnswerScalarWhereInput[]
  }

  export type UserPracticeProgressUpdateManyWithoutPracticeCloneNestedInput = {
    create?: XOR<UserPracticeProgressCreateWithoutPracticeCloneInput, UserPracticeProgressUncheckedCreateWithoutPracticeCloneInput> | UserPracticeProgressCreateWithoutPracticeCloneInput[] | UserPracticeProgressUncheckedCreateWithoutPracticeCloneInput[]
    connectOrCreate?: UserPracticeProgressCreateOrConnectWithoutPracticeCloneInput | UserPracticeProgressCreateOrConnectWithoutPracticeCloneInput[]
    upsert?: UserPracticeProgressUpsertWithWhereUniqueWithoutPracticeCloneInput | UserPracticeProgressUpsertWithWhereUniqueWithoutPracticeCloneInput[]
    createMany?: UserPracticeProgressCreateManyPracticeCloneInputEnvelope
    set?: UserPracticeProgressWhereUniqueInput | UserPracticeProgressWhereUniqueInput[]
    disconnect?: UserPracticeProgressWhereUniqueInput | UserPracticeProgressWhereUniqueInput[]
    delete?: UserPracticeProgressWhereUniqueInput | UserPracticeProgressWhereUniqueInput[]
    connect?: UserPracticeProgressWhereUniqueInput | UserPracticeProgressWhereUniqueInput[]
    update?: UserPracticeProgressUpdateWithWhereUniqueWithoutPracticeCloneInput | UserPracticeProgressUpdateWithWhereUniqueWithoutPracticeCloneInput[]
    updateMany?: UserPracticeProgressUpdateManyWithWhereWithoutPracticeCloneInput | UserPracticeProgressUpdateManyWithWhereWithoutPracticeCloneInput[]
    deleteMany?: UserPracticeProgressScalarWhereInput | UserPracticeProgressScalarWhereInput[]
  }

  export type CloneDiscussionUpdateManyWithoutPracticeCloneNestedInput = {
    create?: XOR<CloneDiscussionCreateWithoutPracticeCloneInput, CloneDiscussionUncheckedCreateWithoutPracticeCloneInput> | CloneDiscussionCreateWithoutPracticeCloneInput[] | CloneDiscussionUncheckedCreateWithoutPracticeCloneInput[]
    connectOrCreate?: CloneDiscussionCreateOrConnectWithoutPracticeCloneInput | CloneDiscussionCreateOrConnectWithoutPracticeCloneInput[]
    upsert?: CloneDiscussionUpsertWithWhereUniqueWithoutPracticeCloneInput | CloneDiscussionUpsertWithWhereUniqueWithoutPracticeCloneInput[]
    createMany?: CloneDiscussionCreateManyPracticeCloneInputEnvelope
    set?: CloneDiscussionWhereUniqueInput | CloneDiscussionWhereUniqueInput[]
    disconnect?: CloneDiscussionWhereUniqueInput | CloneDiscussionWhereUniqueInput[]
    delete?: CloneDiscussionWhereUniqueInput | CloneDiscussionWhereUniqueInput[]
    connect?: CloneDiscussionWhereUniqueInput | CloneDiscussionWhereUniqueInput[]
    update?: CloneDiscussionUpdateWithWhereUniqueWithoutPracticeCloneInput | CloneDiscussionUpdateWithWhereUniqueWithoutPracticeCloneInput[]
    updateMany?: CloneDiscussionUpdateManyWithWhereWithoutPracticeCloneInput | CloneDiscussionUpdateManyWithWhereWithoutPracticeCloneInput[]
    deleteMany?: CloneDiscussionScalarWhereInput | CloneDiscussionScalarWhereInput[]
  }

  export type PracticeAnswerUncheckedUpdateManyWithoutPracticeCloneNestedInput = {
    create?: XOR<PracticeAnswerCreateWithoutPracticeCloneInput, PracticeAnswerUncheckedCreateWithoutPracticeCloneInput> | PracticeAnswerCreateWithoutPracticeCloneInput[] | PracticeAnswerUncheckedCreateWithoutPracticeCloneInput[]
    connectOrCreate?: PracticeAnswerCreateOrConnectWithoutPracticeCloneInput | PracticeAnswerCreateOrConnectWithoutPracticeCloneInput[]
    upsert?: PracticeAnswerUpsertWithWhereUniqueWithoutPracticeCloneInput | PracticeAnswerUpsertWithWhereUniqueWithoutPracticeCloneInput[]
    createMany?: PracticeAnswerCreateManyPracticeCloneInputEnvelope
    set?: PracticeAnswerWhereUniqueInput | PracticeAnswerWhereUniqueInput[]
    disconnect?: PracticeAnswerWhereUniqueInput | PracticeAnswerWhereUniqueInput[]
    delete?: PracticeAnswerWhereUniqueInput | PracticeAnswerWhereUniqueInput[]
    connect?: PracticeAnswerWhereUniqueInput | PracticeAnswerWhereUniqueInput[]
    update?: PracticeAnswerUpdateWithWhereUniqueWithoutPracticeCloneInput | PracticeAnswerUpdateWithWhereUniqueWithoutPracticeCloneInput[]
    updateMany?: PracticeAnswerUpdateManyWithWhereWithoutPracticeCloneInput | PracticeAnswerUpdateManyWithWhereWithoutPracticeCloneInput[]
    deleteMany?: PracticeAnswerScalarWhereInput | PracticeAnswerScalarWhereInput[]
  }

  export type UserPracticeProgressUncheckedUpdateManyWithoutPracticeCloneNestedInput = {
    create?: XOR<UserPracticeProgressCreateWithoutPracticeCloneInput, UserPracticeProgressUncheckedCreateWithoutPracticeCloneInput> | UserPracticeProgressCreateWithoutPracticeCloneInput[] | UserPracticeProgressUncheckedCreateWithoutPracticeCloneInput[]
    connectOrCreate?: UserPracticeProgressCreateOrConnectWithoutPracticeCloneInput | UserPracticeProgressCreateOrConnectWithoutPracticeCloneInput[]
    upsert?: UserPracticeProgressUpsertWithWhereUniqueWithoutPracticeCloneInput | UserPracticeProgressUpsertWithWhereUniqueWithoutPracticeCloneInput[]
    createMany?: UserPracticeProgressCreateManyPracticeCloneInputEnvelope
    set?: UserPracticeProgressWhereUniqueInput | UserPracticeProgressWhereUniqueInput[]
    disconnect?: UserPracticeProgressWhereUniqueInput | UserPracticeProgressWhereUniqueInput[]
    delete?: UserPracticeProgressWhereUniqueInput | UserPracticeProgressWhereUniqueInput[]
    connect?: UserPracticeProgressWhereUniqueInput | UserPracticeProgressWhereUniqueInput[]
    update?: UserPracticeProgressUpdateWithWhereUniqueWithoutPracticeCloneInput | UserPracticeProgressUpdateWithWhereUniqueWithoutPracticeCloneInput[]
    updateMany?: UserPracticeProgressUpdateManyWithWhereWithoutPracticeCloneInput | UserPracticeProgressUpdateManyWithWhereWithoutPracticeCloneInput[]
    deleteMany?: UserPracticeProgressScalarWhereInput | UserPracticeProgressScalarWhereInput[]
  }

  export type CloneDiscussionUncheckedUpdateManyWithoutPracticeCloneNestedInput = {
    create?: XOR<CloneDiscussionCreateWithoutPracticeCloneInput, CloneDiscussionUncheckedCreateWithoutPracticeCloneInput> | CloneDiscussionCreateWithoutPracticeCloneInput[] | CloneDiscussionUncheckedCreateWithoutPracticeCloneInput[]
    connectOrCreate?: CloneDiscussionCreateOrConnectWithoutPracticeCloneInput | CloneDiscussionCreateOrConnectWithoutPracticeCloneInput[]
    upsert?: CloneDiscussionUpsertWithWhereUniqueWithoutPracticeCloneInput | CloneDiscussionUpsertWithWhereUniqueWithoutPracticeCloneInput[]
    createMany?: CloneDiscussionCreateManyPracticeCloneInputEnvelope
    set?: CloneDiscussionWhereUniqueInput | CloneDiscussionWhereUniqueInput[]
    disconnect?: CloneDiscussionWhereUniqueInput | CloneDiscussionWhereUniqueInput[]
    delete?: CloneDiscussionWhereUniqueInput | CloneDiscussionWhereUniqueInput[]
    connect?: CloneDiscussionWhereUniqueInput | CloneDiscussionWhereUniqueInput[]
    update?: CloneDiscussionUpdateWithWhereUniqueWithoutPracticeCloneInput | CloneDiscussionUpdateWithWhereUniqueWithoutPracticeCloneInput[]
    updateMany?: CloneDiscussionUpdateManyWithWhereWithoutPracticeCloneInput | CloneDiscussionUpdateManyWithWhereWithoutPracticeCloneInput[]
    deleteMany?: CloneDiscussionScalarWhereInput | CloneDiscussionScalarWhereInput[]
  }

  export type PracticeCloneCreateNestedOneWithoutPracticeAnswersInput = {
    create?: XOR<PracticeCloneCreateWithoutPracticeAnswersInput, PracticeCloneUncheckedCreateWithoutPracticeAnswersInput>
    connectOrCreate?: PracticeCloneCreateOrConnectWithoutPracticeAnswersInput
    connect?: PracticeCloneWhereUniqueInput
  }

  export type PracticeCloneUpdateOneRequiredWithoutPracticeAnswersNestedInput = {
    create?: XOR<PracticeCloneCreateWithoutPracticeAnswersInput, PracticeCloneUncheckedCreateWithoutPracticeAnswersInput>
    connectOrCreate?: PracticeCloneCreateOrConnectWithoutPracticeAnswersInput
    upsert?: PracticeCloneUpsertWithoutPracticeAnswersInput
    connect?: PracticeCloneWhereUniqueInput
    update?: XOR<XOR<PracticeCloneUpdateToOneWithWhereWithoutPracticeAnswersInput, PracticeCloneUpdateWithoutPracticeAnswersInput>, PracticeCloneUncheckedUpdateWithoutPracticeAnswersInput>
  }

  export type UserCreateNestedOneWithoutPracticeProgressInput = {
    create?: XOR<UserCreateWithoutPracticeProgressInput, UserUncheckedCreateWithoutPracticeProgressInput>
    connectOrCreate?: UserCreateOrConnectWithoutPracticeProgressInput
    connect?: UserWhereUniqueInput
  }

  export type PracticeCloneCreateNestedOneWithoutUserProgressInput = {
    create?: XOR<PracticeCloneCreateWithoutUserProgressInput, PracticeCloneUncheckedCreateWithoutUserProgressInput>
    connectOrCreate?: PracticeCloneCreateOrConnectWithoutUserProgressInput
    connect?: PracticeCloneWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutPracticeProgressNestedInput = {
    create?: XOR<UserCreateWithoutPracticeProgressInput, UserUncheckedCreateWithoutPracticeProgressInput>
    connectOrCreate?: UserCreateOrConnectWithoutPracticeProgressInput
    upsert?: UserUpsertWithoutPracticeProgressInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutPracticeProgressInput, UserUpdateWithoutPracticeProgressInput>, UserUncheckedUpdateWithoutPracticeProgressInput>
  }

  export type PracticeCloneUpdateOneRequiredWithoutUserProgressNestedInput = {
    create?: XOR<PracticeCloneCreateWithoutUserProgressInput, PracticeCloneUncheckedCreateWithoutUserProgressInput>
    connectOrCreate?: PracticeCloneCreateOrConnectWithoutUserProgressInput
    upsert?: PracticeCloneUpsertWithoutUserProgressInput
    connect?: PracticeCloneWhereUniqueInput
    update?: XOR<XOR<PracticeCloneUpdateToOneWithWhereWithoutUserProgressInput, PracticeCloneUpdateWithoutUserProgressInput>, PracticeCloneUncheckedUpdateWithoutUserProgressInput>
  }

  export type AnalysisQuestionCreateNestedOneWithoutHelpTopicInput = {
    create?: XOR<AnalysisQuestionCreateWithoutHelpTopicInput, AnalysisQuestionUncheckedCreateWithoutHelpTopicInput>
    connectOrCreate?: AnalysisQuestionCreateOrConnectWithoutHelpTopicInput
    connect?: AnalysisQuestionWhereUniqueInput
  }

  export type AnalysisQuestionUpdateOneRequiredWithoutHelpTopicNestedInput = {
    create?: XOR<AnalysisQuestionCreateWithoutHelpTopicInput, AnalysisQuestionUncheckedCreateWithoutHelpTopicInput>
    connectOrCreate?: AnalysisQuestionCreateOrConnectWithoutHelpTopicInput
    upsert?: AnalysisQuestionUpsertWithoutHelpTopicInput
    connect?: AnalysisQuestionWhereUniqueInput
    update?: XOR<XOR<AnalysisQuestionUpdateToOneWithWhereWithoutHelpTopicInput, AnalysisQuestionUpdateWithoutHelpTopicInput>, AnalysisQuestionUncheckedUpdateWithoutHelpTopicInput>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedBoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type NestedBoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type SchoolCreateWithoutUsersInput = {
    name: string
    schoolId: string
    instructor: string
    students?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SchoolUncheckedCreateWithoutUsersInput = {
    id?: number
    name: string
    schoolId: string
    instructor: string
    students?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SchoolCreateOrConnectWithoutUsersInput = {
    where: SchoolWhereUniqueInput
    create: XOR<SchoolCreateWithoutUsersInput, SchoolUncheckedCreateWithoutUsersInput>
  }

  export type DemographicsCreateWithoutUserInput = {
    academicYear?: string | null
    yearsInProgram?: string | null
    classesTaken?: string | null
    otherScienceCourses?: string | null
    age?: number | null
    gender?: string | null
    ethnicity?: string | null
    educationLevel?: string | null
    city?: string | null
    state?: string | null
    country?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DemographicsUncheckedCreateWithoutUserInput = {
    id?: number
    academicYear?: string | null
    yearsInProgram?: string | null
    classesTaken?: string | null
    otherScienceCourses?: string | null
    age?: number | null
    gender?: string | null
    ethnicity?: string | null
    educationLevel?: string | null
    city?: string | null
    state?: string | null
    country?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DemographicsCreateOrConnectWithoutUserInput = {
    where: DemographicsWhereUniqueInput
    create: XOR<DemographicsCreateWithoutUserInput, DemographicsUncheckedCreateWithoutUserInput>
  }

  export type UploadedFileCreateWithoutAssignedToInput = {
    filename: string
    originalName: string
    cloneName: string
    size: string
    uploadDate: string
    status?: string
    progress?: number
    analysisData?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    uploadedBy: UserCreateNestedOneWithoutUploadedFilesInput
    messages?: MessageCreateNestedManyWithoutCloneInput
    cloneDiscussions?: CloneDiscussionCreateNestedManyWithoutCloneInput
  }

  export type UploadedFileUncheckedCreateWithoutAssignedToInput = {
    id?: number
    filename: string
    originalName: string
    cloneName: string
    size: string
    uploadDate: string
    status?: string
    progress?: number
    analysisData?: string | null
    uploadedById: number
    createdAt?: Date | string
    updatedAt?: Date | string
    messages?: MessageUncheckedCreateNestedManyWithoutCloneInput
    cloneDiscussions?: CloneDiscussionUncheckedCreateNestedManyWithoutCloneInput
  }

  export type UploadedFileCreateOrConnectWithoutAssignedToInput = {
    where: UploadedFileWhereUniqueInput
    create: XOR<UploadedFileCreateWithoutAssignedToInput, UploadedFileUncheckedCreateWithoutAssignedToInput>
  }

  export type UploadedFileCreateManyAssignedToInputEnvelope = {
    data: UploadedFileCreateManyAssignedToInput | UploadedFileCreateManyAssignedToInput[]
  }

  export type UploadedFileCreateWithoutUploadedByInput = {
    filename: string
    originalName: string
    cloneName: string
    size: string
    uploadDate: string
    status?: string
    progress?: number
    analysisData?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    assignedTo?: UserCreateNestedOneWithoutAssignedFilesInput
    messages?: MessageCreateNestedManyWithoutCloneInput
    cloneDiscussions?: CloneDiscussionCreateNestedManyWithoutCloneInput
  }

  export type UploadedFileUncheckedCreateWithoutUploadedByInput = {
    id?: number
    filename: string
    originalName: string
    cloneName: string
    size: string
    uploadDate: string
    status?: string
    progress?: number
    analysisData?: string | null
    assignedToId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    messages?: MessageUncheckedCreateNestedManyWithoutCloneInput
    cloneDiscussions?: CloneDiscussionUncheckedCreateNestedManyWithoutCloneInput
  }

  export type UploadedFileCreateOrConnectWithoutUploadedByInput = {
    where: UploadedFileWhereUniqueInput
    create: XOR<UploadedFileCreateWithoutUploadedByInput, UploadedFileUncheckedCreateWithoutUploadedByInput>
  }

  export type UploadedFileCreateManyUploadedByInputEnvelope = {
    data: UploadedFileCreateManyUploadedByInput | UploadedFileCreateManyUploadedByInput[]
  }

  export type MessageCreateWithoutSenderInput = {
    subject: string
    content: string
    messageType?: string
    isRead?: boolean
    cloneProgress?: number | null
    currentStep?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isGroupMessage?: boolean | null
    groupParticipants?: string | null
    recipient: UserCreateNestedOneWithoutReceivedMessagesInput
    clone?: UploadedFileCreateNestedOneWithoutMessagesInput
  }

  export type MessageUncheckedCreateWithoutSenderInput = {
    id?: number
    subject: string
    content: string
    messageType?: string
    isRead?: boolean
    recipientId: number
    cloneId?: number | null
    cloneProgress?: number | null
    currentStep?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isGroupMessage?: boolean | null
    groupParticipants?: string | null
  }

  export type MessageCreateOrConnectWithoutSenderInput = {
    where: MessageWhereUniqueInput
    create: XOR<MessageCreateWithoutSenderInput, MessageUncheckedCreateWithoutSenderInput>
  }

  export type MessageCreateManySenderInputEnvelope = {
    data: MessageCreateManySenderInput | MessageCreateManySenderInput[]
  }

  export type MessageCreateWithoutRecipientInput = {
    subject: string
    content: string
    messageType?: string
    isRead?: boolean
    cloneProgress?: number | null
    currentStep?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isGroupMessage?: boolean | null
    groupParticipants?: string | null
    sender: UserCreateNestedOneWithoutSentMessagesInput
    clone?: UploadedFileCreateNestedOneWithoutMessagesInput
  }

  export type MessageUncheckedCreateWithoutRecipientInput = {
    id?: number
    subject: string
    content: string
    messageType?: string
    isRead?: boolean
    senderId: number
    cloneId?: number | null
    cloneProgress?: number | null
    currentStep?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isGroupMessage?: boolean | null
    groupParticipants?: string | null
  }

  export type MessageCreateOrConnectWithoutRecipientInput = {
    where: MessageWhereUniqueInput
    create: XOR<MessageCreateWithoutRecipientInput, MessageUncheckedCreateWithoutRecipientInput>
  }

  export type MessageCreateManyRecipientInputEnvelope = {
    data: MessageCreateManyRecipientInput | MessageCreateManyRecipientInput[]
  }

  export type UserPracticeProgressCreateWithoutUserInput = {
    progress?: number
    answers?: string | null
    currentStep?: string
    status?: string
    lastSaved?: Date | string | null
    submittedAt?: Date | string | null
    reviewComments?: string | null
    reviewScore?: number | null
    lastReviewed?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    practiceClone: PracticeCloneCreateNestedOneWithoutUserProgressInput
  }

  export type UserPracticeProgressUncheckedCreateWithoutUserInput = {
    id?: number
    practiceCloneId: number
    progress?: number
    answers?: string | null
    currentStep?: string
    status?: string
    lastSaved?: Date | string | null
    submittedAt?: Date | string | null
    reviewComments?: string | null
    reviewScore?: number | null
    lastReviewed?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserPracticeProgressCreateOrConnectWithoutUserInput = {
    where: UserPracticeProgressWhereUniqueInput
    create: XOR<UserPracticeProgressCreateWithoutUserInput, UserPracticeProgressUncheckedCreateWithoutUserInput>
  }

  export type UserPracticeProgressCreateManyUserInputEnvelope = {
    data: UserPracticeProgressCreateManyUserInput | UserPracticeProgressCreateManyUserInput[]
  }

  export type LoginLogCreateWithoutUserInput = {
    loginTime?: Date | string
    ipAddress?: string | null
    userAgent?: string | null
    success?: boolean
    createdAt?: Date | string
  }

  export type LoginLogUncheckedCreateWithoutUserInput = {
    id?: number
    loginTime?: Date | string
    ipAddress?: string | null
    userAgent?: string | null
    success?: boolean
    createdAt?: Date | string
  }

  export type LoginLogCreateOrConnectWithoutUserInput = {
    where: LoginLogWhereUniqueInput
    create: XOR<LoginLogCreateWithoutUserInput, LoginLogUncheckedCreateWithoutUserInput>
  }

  export type LoginLogCreateManyUserInputEnvelope = {
    data: LoginLogCreateManyUserInput | LoginLogCreateManyUserInput[]
  }

  export type CloneDiscussionCreateWithoutStudentInput = {
    title: string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    lastMessageAt?: Date | string
    clone?: UploadedFileCreateNestedOneWithoutCloneDiscussionsInput
    practiceClone?: PracticeCloneCreateNestedOneWithoutCloneDiscussionsInput
    messages?: DiscussionMessageCreateNestedManyWithoutDiscussionInput
  }

  export type CloneDiscussionUncheckedCreateWithoutStudentInput = {
    id?: number
    cloneId?: number | null
    practiceCloneId?: number | null
    title: string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    lastMessageAt?: Date | string
    messages?: DiscussionMessageUncheckedCreateNestedManyWithoutDiscussionInput
  }

  export type CloneDiscussionCreateOrConnectWithoutStudentInput = {
    where: CloneDiscussionWhereUniqueInput
    create: XOR<CloneDiscussionCreateWithoutStudentInput, CloneDiscussionUncheckedCreateWithoutStudentInput>
  }

  export type CloneDiscussionCreateManyStudentInputEnvelope = {
    data: CloneDiscussionCreateManyStudentInput | CloneDiscussionCreateManyStudentInput[]
  }

  export type DiscussionMessageCreateWithoutSenderInput = {
    content: string
    messageType?: string
    readBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    discussion: CloneDiscussionCreateNestedOneWithoutMessagesInput
  }

  export type DiscussionMessageUncheckedCreateWithoutSenderInput = {
    id?: number
    discussionId: number
    content: string
    messageType?: string
    readBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DiscussionMessageCreateOrConnectWithoutSenderInput = {
    where: DiscussionMessageWhereUniqueInput
    create: XOR<DiscussionMessageCreateWithoutSenderInput, DiscussionMessageUncheckedCreateWithoutSenderInput>
  }

  export type DiscussionMessageCreateManySenderInputEnvelope = {
    data: DiscussionMessageCreateManySenderInput | DiscussionMessageCreateManySenderInput[]
  }

  export type SchoolUpsertWithoutUsersInput = {
    update: XOR<SchoolUpdateWithoutUsersInput, SchoolUncheckedUpdateWithoutUsersInput>
    create: XOR<SchoolCreateWithoutUsersInput, SchoolUncheckedCreateWithoutUsersInput>
    where?: SchoolWhereInput
  }

  export type SchoolUpdateToOneWithWhereWithoutUsersInput = {
    where?: SchoolWhereInput
    data: XOR<SchoolUpdateWithoutUsersInput, SchoolUncheckedUpdateWithoutUsersInput>
  }

  export type SchoolUpdateWithoutUsersInput = {
    name?: StringFieldUpdateOperationsInput | string
    schoolId?: StringFieldUpdateOperationsInput | string
    instructor?: StringFieldUpdateOperationsInput | string
    students?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SchoolUncheckedUpdateWithoutUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    schoolId?: StringFieldUpdateOperationsInput | string
    instructor?: StringFieldUpdateOperationsInput | string
    students?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DemographicsUpsertWithoutUserInput = {
    update: XOR<DemographicsUpdateWithoutUserInput, DemographicsUncheckedUpdateWithoutUserInput>
    create: XOR<DemographicsCreateWithoutUserInput, DemographicsUncheckedCreateWithoutUserInput>
    where?: DemographicsWhereInput
  }

  export type DemographicsUpdateToOneWithWhereWithoutUserInput = {
    where?: DemographicsWhereInput
    data: XOR<DemographicsUpdateWithoutUserInput, DemographicsUncheckedUpdateWithoutUserInput>
  }

  export type DemographicsUpdateWithoutUserInput = {
    academicYear?: NullableStringFieldUpdateOperationsInput | string | null
    yearsInProgram?: NullableStringFieldUpdateOperationsInput | string | null
    classesTaken?: NullableStringFieldUpdateOperationsInput | string | null
    otherScienceCourses?: NullableStringFieldUpdateOperationsInput | string | null
    age?: NullableIntFieldUpdateOperationsInput | number | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    ethnicity?: NullableStringFieldUpdateOperationsInput | string | null
    educationLevel?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DemographicsUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    academicYear?: NullableStringFieldUpdateOperationsInput | string | null
    yearsInProgram?: NullableStringFieldUpdateOperationsInput | string | null
    classesTaken?: NullableStringFieldUpdateOperationsInput | string | null
    otherScienceCourses?: NullableStringFieldUpdateOperationsInput | string | null
    age?: NullableIntFieldUpdateOperationsInput | number | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    ethnicity?: NullableStringFieldUpdateOperationsInput | string | null
    educationLevel?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UploadedFileUpsertWithWhereUniqueWithoutAssignedToInput = {
    where: UploadedFileWhereUniqueInput
    update: XOR<UploadedFileUpdateWithoutAssignedToInput, UploadedFileUncheckedUpdateWithoutAssignedToInput>
    create: XOR<UploadedFileCreateWithoutAssignedToInput, UploadedFileUncheckedCreateWithoutAssignedToInput>
  }

  export type UploadedFileUpdateWithWhereUniqueWithoutAssignedToInput = {
    where: UploadedFileWhereUniqueInput
    data: XOR<UploadedFileUpdateWithoutAssignedToInput, UploadedFileUncheckedUpdateWithoutAssignedToInput>
  }

  export type UploadedFileUpdateManyWithWhereWithoutAssignedToInput = {
    where: UploadedFileScalarWhereInput
    data: XOR<UploadedFileUpdateManyMutationInput, UploadedFileUncheckedUpdateManyWithoutAssignedToInput>
  }

  export type UploadedFileScalarWhereInput = {
    AND?: UploadedFileScalarWhereInput | UploadedFileScalarWhereInput[]
    OR?: UploadedFileScalarWhereInput[]
    NOT?: UploadedFileScalarWhereInput | UploadedFileScalarWhereInput[]
    id?: IntFilter<"UploadedFile"> | number
    filename?: StringFilter<"UploadedFile"> | string
    originalName?: StringFilter<"UploadedFile"> | string
    cloneName?: StringFilter<"UploadedFile"> | string
    size?: StringFilter<"UploadedFile"> | string
    uploadDate?: StringFilter<"UploadedFile"> | string
    status?: StringFilter<"UploadedFile"> | string
    progress?: IntFilter<"UploadedFile"> | number
    analysisData?: StringNullableFilter<"UploadedFile"> | string | null
    assignedToId?: IntNullableFilter<"UploadedFile"> | number | null
    uploadedById?: IntFilter<"UploadedFile"> | number
    createdAt?: DateTimeFilter<"UploadedFile"> | Date | string
    updatedAt?: DateTimeFilter<"UploadedFile"> | Date | string
  }

  export type UploadedFileUpsertWithWhereUniqueWithoutUploadedByInput = {
    where: UploadedFileWhereUniqueInput
    update: XOR<UploadedFileUpdateWithoutUploadedByInput, UploadedFileUncheckedUpdateWithoutUploadedByInput>
    create: XOR<UploadedFileCreateWithoutUploadedByInput, UploadedFileUncheckedCreateWithoutUploadedByInput>
  }

  export type UploadedFileUpdateWithWhereUniqueWithoutUploadedByInput = {
    where: UploadedFileWhereUniqueInput
    data: XOR<UploadedFileUpdateWithoutUploadedByInput, UploadedFileUncheckedUpdateWithoutUploadedByInput>
  }

  export type UploadedFileUpdateManyWithWhereWithoutUploadedByInput = {
    where: UploadedFileScalarWhereInput
    data: XOR<UploadedFileUpdateManyMutationInput, UploadedFileUncheckedUpdateManyWithoutUploadedByInput>
  }

  export type MessageUpsertWithWhereUniqueWithoutSenderInput = {
    where: MessageWhereUniqueInput
    update: XOR<MessageUpdateWithoutSenderInput, MessageUncheckedUpdateWithoutSenderInput>
    create: XOR<MessageCreateWithoutSenderInput, MessageUncheckedCreateWithoutSenderInput>
  }

  export type MessageUpdateWithWhereUniqueWithoutSenderInput = {
    where: MessageWhereUniqueInput
    data: XOR<MessageUpdateWithoutSenderInput, MessageUncheckedUpdateWithoutSenderInput>
  }

  export type MessageUpdateManyWithWhereWithoutSenderInput = {
    where: MessageScalarWhereInput
    data: XOR<MessageUpdateManyMutationInput, MessageUncheckedUpdateManyWithoutSenderInput>
  }

  export type MessageScalarWhereInput = {
    AND?: MessageScalarWhereInput | MessageScalarWhereInput[]
    OR?: MessageScalarWhereInput[]
    NOT?: MessageScalarWhereInput | MessageScalarWhereInput[]
    id?: IntFilter<"Message"> | number
    subject?: StringFilter<"Message"> | string
    content?: StringFilter<"Message"> | string
    messageType?: StringFilter<"Message"> | string
    isRead?: BoolFilter<"Message"> | boolean
    senderId?: IntFilter<"Message"> | number
    recipientId?: IntFilter<"Message"> | number
    cloneId?: IntNullableFilter<"Message"> | number | null
    cloneProgress?: IntNullableFilter<"Message"> | number | null
    currentStep?: StringNullableFilter<"Message"> | string | null
    createdAt?: DateTimeFilter<"Message"> | Date | string
    updatedAt?: DateTimeFilter<"Message"> | Date | string
    isGroupMessage?: BoolNullableFilter<"Message"> | boolean | null
    groupParticipants?: StringNullableFilter<"Message"> | string | null
  }

  export type MessageUpsertWithWhereUniqueWithoutRecipientInput = {
    where: MessageWhereUniqueInput
    update: XOR<MessageUpdateWithoutRecipientInput, MessageUncheckedUpdateWithoutRecipientInput>
    create: XOR<MessageCreateWithoutRecipientInput, MessageUncheckedCreateWithoutRecipientInput>
  }

  export type MessageUpdateWithWhereUniqueWithoutRecipientInput = {
    where: MessageWhereUniqueInput
    data: XOR<MessageUpdateWithoutRecipientInput, MessageUncheckedUpdateWithoutRecipientInput>
  }

  export type MessageUpdateManyWithWhereWithoutRecipientInput = {
    where: MessageScalarWhereInput
    data: XOR<MessageUpdateManyMutationInput, MessageUncheckedUpdateManyWithoutRecipientInput>
  }

  export type UserPracticeProgressUpsertWithWhereUniqueWithoutUserInput = {
    where: UserPracticeProgressWhereUniqueInput
    update: XOR<UserPracticeProgressUpdateWithoutUserInput, UserPracticeProgressUncheckedUpdateWithoutUserInput>
    create: XOR<UserPracticeProgressCreateWithoutUserInput, UserPracticeProgressUncheckedCreateWithoutUserInput>
  }

  export type UserPracticeProgressUpdateWithWhereUniqueWithoutUserInput = {
    where: UserPracticeProgressWhereUniqueInput
    data: XOR<UserPracticeProgressUpdateWithoutUserInput, UserPracticeProgressUncheckedUpdateWithoutUserInput>
  }

  export type UserPracticeProgressUpdateManyWithWhereWithoutUserInput = {
    where: UserPracticeProgressScalarWhereInput
    data: XOR<UserPracticeProgressUpdateManyMutationInput, UserPracticeProgressUncheckedUpdateManyWithoutUserInput>
  }

  export type UserPracticeProgressScalarWhereInput = {
    AND?: UserPracticeProgressScalarWhereInput | UserPracticeProgressScalarWhereInput[]
    OR?: UserPracticeProgressScalarWhereInput[]
    NOT?: UserPracticeProgressScalarWhereInput | UserPracticeProgressScalarWhereInput[]
    id?: IntFilter<"UserPracticeProgress"> | number
    userId?: IntFilter<"UserPracticeProgress"> | number
    practiceCloneId?: IntFilter<"UserPracticeProgress"> | number
    progress?: IntFilter<"UserPracticeProgress"> | number
    answers?: StringNullableFilter<"UserPracticeProgress"> | string | null
    currentStep?: StringFilter<"UserPracticeProgress"> | string
    status?: StringFilter<"UserPracticeProgress"> | string
    lastSaved?: DateTimeNullableFilter<"UserPracticeProgress"> | Date | string | null
    submittedAt?: DateTimeNullableFilter<"UserPracticeProgress"> | Date | string | null
    reviewComments?: StringNullableFilter<"UserPracticeProgress"> | string | null
    reviewScore?: IntNullableFilter<"UserPracticeProgress"> | number | null
    lastReviewed?: DateTimeNullableFilter<"UserPracticeProgress"> | Date | string | null
    createdAt?: DateTimeFilter<"UserPracticeProgress"> | Date | string
    updatedAt?: DateTimeFilter<"UserPracticeProgress"> | Date | string
  }

  export type LoginLogUpsertWithWhereUniqueWithoutUserInput = {
    where: LoginLogWhereUniqueInput
    update: XOR<LoginLogUpdateWithoutUserInput, LoginLogUncheckedUpdateWithoutUserInput>
    create: XOR<LoginLogCreateWithoutUserInput, LoginLogUncheckedCreateWithoutUserInput>
  }

  export type LoginLogUpdateWithWhereUniqueWithoutUserInput = {
    where: LoginLogWhereUniqueInput
    data: XOR<LoginLogUpdateWithoutUserInput, LoginLogUncheckedUpdateWithoutUserInput>
  }

  export type LoginLogUpdateManyWithWhereWithoutUserInput = {
    where: LoginLogScalarWhereInput
    data: XOR<LoginLogUpdateManyMutationInput, LoginLogUncheckedUpdateManyWithoutUserInput>
  }

  export type LoginLogScalarWhereInput = {
    AND?: LoginLogScalarWhereInput | LoginLogScalarWhereInput[]
    OR?: LoginLogScalarWhereInput[]
    NOT?: LoginLogScalarWhereInput | LoginLogScalarWhereInput[]
    id?: IntFilter<"LoginLog"> | number
    userId?: IntFilter<"LoginLog"> | number
    loginTime?: DateTimeFilter<"LoginLog"> | Date | string
    ipAddress?: StringNullableFilter<"LoginLog"> | string | null
    userAgent?: StringNullableFilter<"LoginLog"> | string | null
    success?: BoolFilter<"LoginLog"> | boolean
    createdAt?: DateTimeFilter<"LoginLog"> | Date | string
  }

  export type CloneDiscussionUpsertWithWhereUniqueWithoutStudentInput = {
    where: CloneDiscussionWhereUniqueInput
    update: XOR<CloneDiscussionUpdateWithoutStudentInput, CloneDiscussionUncheckedUpdateWithoutStudentInput>
    create: XOR<CloneDiscussionCreateWithoutStudentInput, CloneDiscussionUncheckedCreateWithoutStudentInput>
  }

  export type CloneDiscussionUpdateWithWhereUniqueWithoutStudentInput = {
    where: CloneDiscussionWhereUniqueInput
    data: XOR<CloneDiscussionUpdateWithoutStudentInput, CloneDiscussionUncheckedUpdateWithoutStudentInput>
  }

  export type CloneDiscussionUpdateManyWithWhereWithoutStudentInput = {
    where: CloneDiscussionScalarWhereInput
    data: XOR<CloneDiscussionUpdateManyMutationInput, CloneDiscussionUncheckedUpdateManyWithoutStudentInput>
  }

  export type CloneDiscussionScalarWhereInput = {
    AND?: CloneDiscussionScalarWhereInput | CloneDiscussionScalarWhereInput[]
    OR?: CloneDiscussionScalarWhereInput[]
    NOT?: CloneDiscussionScalarWhereInput | CloneDiscussionScalarWhereInput[]
    id?: IntFilter<"CloneDiscussion"> | number
    studentId?: IntFilter<"CloneDiscussion"> | number
    cloneId?: IntNullableFilter<"CloneDiscussion"> | number | null
    practiceCloneId?: IntNullableFilter<"CloneDiscussion"> | number | null
    title?: StringFilter<"CloneDiscussion"> | string
    status?: StringFilter<"CloneDiscussion"> | string
    createdAt?: DateTimeFilter<"CloneDiscussion"> | Date | string
    updatedAt?: DateTimeFilter<"CloneDiscussion"> | Date | string
    lastMessageAt?: DateTimeFilter<"CloneDiscussion"> | Date | string
  }

  export type DiscussionMessageUpsertWithWhereUniqueWithoutSenderInput = {
    where: DiscussionMessageWhereUniqueInput
    update: XOR<DiscussionMessageUpdateWithoutSenderInput, DiscussionMessageUncheckedUpdateWithoutSenderInput>
    create: XOR<DiscussionMessageCreateWithoutSenderInput, DiscussionMessageUncheckedCreateWithoutSenderInput>
  }

  export type DiscussionMessageUpdateWithWhereUniqueWithoutSenderInput = {
    where: DiscussionMessageWhereUniqueInput
    data: XOR<DiscussionMessageUpdateWithoutSenderInput, DiscussionMessageUncheckedUpdateWithoutSenderInput>
  }

  export type DiscussionMessageUpdateManyWithWhereWithoutSenderInput = {
    where: DiscussionMessageScalarWhereInput
    data: XOR<DiscussionMessageUpdateManyMutationInput, DiscussionMessageUncheckedUpdateManyWithoutSenderInput>
  }

  export type DiscussionMessageScalarWhereInput = {
    AND?: DiscussionMessageScalarWhereInput | DiscussionMessageScalarWhereInput[]
    OR?: DiscussionMessageScalarWhereInput[]
    NOT?: DiscussionMessageScalarWhereInput | DiscussionMessageScalarWhereInput[]
    id?: IntFilter<"DiscussionMessage"> | number
    discussionId?: IntFilter<"DiscussionMessage"> | number
    senderId?: IntFilter<"DiscussionMessage"> | number
    content?: StringFilter<"DiscussionMessage"> | string
    messageType?: StringFilter<"DiscussionMessage"> | string
    readBy?: StringNullableFilter<"DiscussionMessage"> | string | null
    createdAt?: DateTimeFilter<"DiscussionMessage"> | Date | string
    updatedAt?: DateTimeFilter<"DiscussionMessage"> | Date | string
  }

  export type UserCreateWithoutSchoolInput = {
    email: string
    password: string
    name: string
    role: string
    status?: string
    resetToken?: string | null
    resetTokenExpiry?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    demographics?: DemographicsCreateNestedOneWithoutUserInput
    assignedFiles?: UploadedFileCreateNestedManyWithoutAssignedToInput
    uploadedFiles?: UploadedFileCreateNestedManyWithoutUploadedByInput
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    receivedMessages?: MessageCreateNestedManyWithoutRecipientInput
    practiceProgress?: UserPracticeProgressCreateNestedManyWithoutUserInput
    loginLogs?: LoginLogCreateNestedManyWithoutUserInput
    discussions?: CloneDiscussionCreateNestedManyWithoutStudentInput
    discussionMessagesSent?: DiscussionMessageCreateNestedManyWithoutSenderInput
  }

  export type UserUncheckedCreateWithoutSchoolInput = {
    id?: number
    email: string
    password: string
    name: string
    role: string
    status?: string
    resetToken?: string | null
    resetTokenExpiry?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    demographics?: DemographicsUncheckedCreateNestedOneWithoutUserInput
    assignedFiles?: UploadedFileUncheckedCreateNestedManyWithoutAssignedToInput
    uploadedFiles?: UploadedFileUncheckedCreateNestedManyWithoutUploadedByInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    receivedMessages?: MessageUncheckedCreateNestedManyWithoutRecipientInput
    practiceProgress?: UserPracticeProgressUncheckedCreateNestedManyWithoutUserInput
    loginLogs?: LoginLogUncheckedCreateNestedManyWithoutUserInput
    discussions?: CloneDiscussionUncheckedCreateNestedManyWithoutStudentInput
    discussionMessagesSent?: DiscussionMessageUncheckedCreateNestedManyWithoutSenderInput
  }

  export type UserCreateOrConnectWithoutSchoolInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSchoolInput, UserUncheckedCreateWithoutSchoolInput>
  }

  export type UserCreateManySchoolInputEnvelope = {
    data: UserCreateManySchoolInput | UserCreateManySchoolInput[]
  }

  export type UserUpsertWithWhereUniqueWithoutSchoolInput = {
    where: UserWhereUniqueInput
    update: XOR<UserUpdateWithoutSchoolInput, UserUncheckedUpdateWithoutSchoolInput>
    create: XOR<UserCreateWithoutSchoolInput, UserUncheckedCreateWithoutSchoolInput>
  }

  export type UserUpdateWithWhereUniqueWithoutSchoolInput = {
    where: UserWhereUniqueInput
    data: XOR<UserUpdateWithoutSchoolInput, UserUncheckedUpdateWithoutSchoolInput>
  }

  export type UserUpdateManyWithWhereWithoutSchoolInput = {
    where: UserScalarWhereInput
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyWithoutSchoolInput>
  }

  export type UserScalarWhereInput = {
    AND?: UserScalarWhereInput | UserScalarWhereInput[]
    OR?: UserScalarWhereInput[]
    NOT?: UserScalarWhereInput | UserScalarWhereInput[]
    id?: IntFilter<"User"> | number
    email?: StringFilter<"User"> | string
    password?: StringFilter<"User"> | string
    name?: StringFilter<"User"> | string
    role?: StringFilter<"User"> | string
    status?: StringFilter<"User"> | string
    schoolId?: IntNullableFilter<"User"> | number | null
    resetToken?: StringNullableFilter<"User"> | string | null
    resetTokenExpiry?: DateTimeNullableFilter<"User"> | Date | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
  }

  export type UserCreateWithoutDemographicsInput = {
    email: string
    password: string
    name: string
    role: string
    status?: string
    resetToken?: string | null
    resetTokenExpiry?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    school?: SchoolCreateNestedOneWithoutUsersInput
    assignedFiles?: UploadedFileCreateNestedManyWithoutAssignedToInput
    uploadedFiles?: UploadedFileCreateNestedManyWithoutUploadedByInput
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    receivedMessages?: MessageCreateNestedManyWithoutRecipientInput
    practiceProgress?: UserPracticeProgressCreateNestedManyWithoutUserInput
    loginLogs?: LoginLogCreateNestedManyWithoutUserInput
    discussions?: CloneDiscussionCreateNestedManyWithoutStudentInput
    discussionMessagesSent?: DiscussionMessageCreateNestedManyWithoutSenderInput
  }

  export type UserUncheckedCreateWithoutDemographicsInput = {
    id?: number
    email: string
    password: string
    name: string
    role: string
    status?: string
    schoolId?: number | null
    resetToken?: string | null
    resetTokenExpiry?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    assignedFiles?: UploadedFileUncheckedCreateNestedManyWithoutAssignedToInput
    uploadedFiles?: UploadedFileUncheckedCreateNestedManyWithoutUploadedByInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    receivedMessages?: MessageUncheckedCreateNestedManyWithoutRecipientInput
    practiceProgress?: UserPracticeProgressUncheckedCreateNestedManyWithoutUserInput
    loginLogs?: LoginLogUncheckedCreateNestedManyWithoutUserInput
    discussions?: CloneDiscussionUncheckedCreateNestedManyWithoutStudentInput
    discussionMessagesSent?: DiscussionMessageUncheckedCreateNestedManyWithoutSenderInput
  }

  export type UserCreateOrConnectWithoutDemographicsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutDemographicsInput, UserUncheckedCreateWithoutDemographicsInput>
  }

  export type UserUpsertWithoutDemographicsInput = {
    update: XOR<UserUpdateWithoutDemographicsInput, UserUncheckedUpdateWithoutDemographicsInput>
    create: XOR<UserCreateWithoutDemographicsInput, UserUncheckedCreateWithoutDemographicsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutDemographicsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutDemographicsInput, UserUncheckedUpdateWithoutDemographicsInput>
  }

  export type UserUpdateWithoutDemographicsInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    school?: SchoolUpdateOneWithoutUsersNestedInput
    assignedFiles?: UploadedFileUpdateManyWithoutAssignedToNestedInput
    uploadedFiles?: UploadedFileUpdateManyWithoutUploadedByNestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    receivedMessages?: MessageUpdateManyWithoutRecipientNestedInput
    practiceProgress?: UserPracticeProgressUpdateManyWithoutUserNestedInput
    loginLogs?: LoginLogUpdateManyWithoutUserNestedInput
    discussions?: CloneDiscussionUpdateManyWithoutStudentNestedInput
    discussionMessagesSent?: DiscussionMessageUpdateManyWithoutSenderNestedInput
  }

  export type UserUncheckedUpdateWithoutDemographicsInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    schoolId?: NullableIntFieldUpdateOperationsInput | number | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedFiles?: UploadedFileUncheckedUpdateManyWithoutAssignedToNestedInput
    uploadedFiles?: UploadedFileUncheckedUpdateManyWithoutUploadedByNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    receivedMessages?: MessageUncheckedUpdateManyWithoutRecipientNestedInput
    practiceProgress?: UserPracticeProgressUncheckedUpdateManyWithoutUserNestedInput
    loginLogs?: LoginLogUncheckedUpdateManyWithoutUserNestedInput
    discussions?: CloneDiscussionUncheckedUpdateManyWithoutStudentNestedInput
    discussionMessagesSent?: DiscussionMessageUncheckedUpdateManyWithoutSenderNestedInput
  }

  export type UserCreateWithoutLoginLogsInput = {
    email: string
    password: string
    name: string
    role: string
    status?: string
    resetToken?: string | null
    resetTokenExpiry?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    school?: SchoolCreateNestedOneWithoutUsersInput
    demographics?: DemographicsCreateNestedOneWithoutUserInput
    assignedFiles?: UploadedFileCreateNestedManyWithoutAssignedToInput
    uploadedFiles?: UploadedFileCreateNestedManyWithoutUploadedByInput
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    receivedMessages?: MessageCreateNestedManyWithoutRecipientInput
    practiceProgress?: UserPracticeProgressCreateNestedManyWithoutUserInput
    discussions?: CloneDiscussionCreateNestedManyWithoutStudentInput
    discussionMessagesSent?: DiscussionMessageCreateNestedManyWithoutSenderInput
  }

  export type UserUncheckedCreateWithoutLoginLogsInput = {
    id?: number
    email: string
    password: string
    name: string
    role: string
    status?: string
    schoolId?: number | null
    resetToken?: string | null
    resetTokenExpiry?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    demographics?: DemographicsUncheckedCreateNestedOneWithoutUserInput
    assignedFiles?: UploadedFileUncheckedCreateNestedManyWithoutAssignedToInput
    uploadedFiles?: UploadedFileUncheckedCreateNestedManyWithoutUploadedByInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    receivedMessages?: MessageUncheckedCreateNestedManyWithoutRecipientInput
    practiceProgress?: UserPracticeProgressUncheckedCreateNestedManyWithoutUserInput
    discussions?: CloneDiscussionUncheckedCreateNestedManyWithoutStudentInput
    discussionMessagesSent?: DiscussionMessageUncheckedCreateNestedManyWithoutSenderInput
  }

  export type UserCreateOrConnectWithoutLoginLogsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutLoginLogsInput, UserUncheckedCreateWithoutLoginLogsInput>
  }

  export type UserUpsertWithoutLoginLogsInput = {
    update: XOR<UserUpdateWithoutLoginLogsInput, UserUncheckedUpdateWithoutLoginLogsInput>
    create: XOR<UserCreateWithoutLoginLogsInput, UserUncheckedCreateWithoutLoginLogsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutLoginLogsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutLoginLogsInput, UserUncheckedUpdateWithoutLoginLogsInput>
  }

  export type UserUpdateWithoutLoginLogsInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    school?: SchoolUpdateOneWithoutUsersNestedInput
    demographics?: DemographicsUpdateOneWithoutUserNestedInput
    assignedFiles?: UploadedFileUpdateManyWithoutAssignedToNestedInput
    uploadedFiles?: UploadedFileUpdateManyWithoutUploadedByNestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    receivedMessages?: MessageUpdateManyWithoutRecipientNestedInput
    practiceProgress?: UserPracticeProgressUpdateManyWithoutUserNestedInput
    discussions?: CloneDiscussionUpdateManyWithoutStudentNestedInput
    discussionMessagesSent?: DiscussionMessageUpdateManyWithoutSenderNestedInput
  }

  export type UserUncheckedUpdateWithoutLoginLogsInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    schoolId?: NullableIntFieldUpdateOperationsInput | number | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    demographics?: DemographicsUncheckedUpdateOneWithoutUserNestedInput
    assignedFiles?: UploadedFileUncheckedUpdateManyWithoutAssignedToNestedInput
    uploadedFiles?: UploadedFileUncheckedUpdateManyWithoutUploadedByNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    receivedMessages?: MessageUncheckedUpdateManyWithoutRecipientNestedInput
    practiceProgress?: UserPracticeProgressUncheckedUpdateManyWithoutUserNestedInput
    discussions?: CloneDiscussionUncheckedUpdateManyWithoutStudentNestedInput
    discussionMessagesSent?: DiscussionMessageUncheckedUpdateManyWithoutSenderNestedInput
  }

  export type HelpTopicCreateWithoutAnalysisQuestionInput = {
    id?: string
    title: string
    videoBoxUrl: string
    helpDocumentUrl: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type HelpTopicUncheckedCreateWithoutAnalysisQuestionInput = {
    id?: string
    title: string
    videoBoxUrl: string
    helpDocumentUrl: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type HelpTopicCreateOrConnectWithoutAnalysisQuestionInput = {
    where: HelpTopicWhereUniqueInput
    create: XOR<HelpTopicCreateWithoutAnalysisQuestionInput, HelpTopicUncheckedCreateWithoutAnalysisQuestionInput>
  }

  export type HelpTopicCreateManyAnalysisQuestionInputEnvelope = {
    data: HelpTopicCreateManyAnalysisQuestionInput | HelpTopicCreateManyAnalysisQuestionInput[]
  }

  export type HelpTopicUpsertWithWhereUniqueWithoutAnalysisQuestionInput = {
    where: HelpTopicWhereUniqueInput
    update: XOR<HelpTopicUpdateWithoutAnalysisQuestionInput, HelpTopicUncheckedUpdateWithoutAnalysisQuestionInput>
    create: XOR<HelpTopicCreateWithoutAnalysisQuestionInput, HelpTopicUncheckedCreateWithoutAnalysisQuestionInput>
  }

  export type HelpTopicUpdateWithWhereUniqueWithoutAnalysisQuestionInput = {
    where: HelpTopicWhereUniqueInput
    data: XOR<HelpTopicUpdateWithoutAnalysisQuestionInput, HelpTopicUncheckedUpdateWithoutAnalysisQuestionInput>
  }

  export type HelpTopicUpdateManyWithWhereWithoutAnalysisQuestionInput = {
    where: HelpTopicScalarWhereInput
    data: XOR<HelpTopicUpdateManyMutationInput, HelpTopicUncheckedUpdateManyWithoutAnalysisQuestionInput>
  }

  export type HelpTopicScalarWhereInput = {
    AND?: HelpTopicScalarWhereInput | HelpTopicScalarWhereInput[]
    OR?: HelpTopicScalarWhereInput[]
    NOT?: HelpTopicScalarWhereInput | HelpTopicScalarWhereInput[]
    id?: StringFilter<"HelpTopic"> | string
    analysisQuestionId?: StringFilter<"HelpTopic"> | string
    title?: StringFilter<"HelpTopic"> | string
    videoBoxUrl?: StringFilter<"HelpTopic"> | string
    helpDocumentUrl?: StringFilter<"HelpTopic"> | string
    isActive?: BoolFilter<"HelpTopic"> | boolean
    createdAt?: DateTimeFilter<"HelpTopic"> | Date | string
    updatedAt?: DateTimeFilter<"HelpTopic"> | Date | string
  }

  export type UserCreateWithoutAssignedFilesInput = {
    email: string
    password: string
    name: string
    role: string
    status?: string
    resetToken?: string | null
    resetTokenExpiry?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    school?: SchoolCreateNestedOneWithoutUsersInput
    demographics?: DemographicsCreateNestedOneWithoutUserInput
    uploadedFiles?: UploadedFileCreateNestedManyWithoutUploadedByInput
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    receivedMessages?: MessageCreateNestedManyWithoutRecipientInput
    practiceProgress?: UserPracticeProgressCreateNestedManyWithoutUserInput
    loginLogs?: LoginLogCreateNestedManyWithoutUserInput
    discussions?: CloneDiscussionCreateNestedManyWithoutStudentInput
    discussionMessagesSent?: DiscussionMessageCreateNestedManyWithoutSenderInput
  }

  export type UserUncheckedCreateWithoutAssignedFilesInput = {
    id?: number
    email: string
    password: string
    name: string
    role: string
    status?: string
    schoolId?: number | null
    resetToken?: string | null
    resetTokenExpiry?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    demographics?: DemographicsUncheckedCreateNestedOneWithoutUserInput
    uploadedFiles?: UploadedFileUncheckedCreateNestedManyWithoutUploadedByInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    receivedMessages?: MessageUncheckedCreateNestedManyWithoutRecipientInput
    practiceProgress?: UserPracticeProgressUncheckedCreateNestedManyWithoutUserInput
    loginLogs?: LoginLogUncheckedCreateNestedManyWithoutUserInput
    discussions?: CloneDiscussionUncheckedCreateNestedManyWithoutStudentInput
    discussionMessagesSent?: DiscussionMessageUncheckedCreateNestedManyWithoutSenderInput
  }

  export type UserCreateOrConnectWithoutAssignedFilesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAssignedFilesInput, UserUncheckedCreateWithoutAssignedFilesInput>
  }

  export type UserCreateWithoutUploadedFilesInput = {
    email: string
    password: string
    name: string
    role: string
    status?: string
    resetToken?: string | null
    resetTokenExpiry?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    school?: SchoolCreateNestedOneWithoutUsersInput
    demographics?: DemographicsCreateNestedOneWithoutUserInput
    assignedFiles?: UploadedFileCreateNestedManyWithoutAssignedToInput
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    receivedMessages?: MessageCreateNestedManyWithoutRecipientInput
    practiceProgress?: UserPracticeProgressCreateNestedManyWithoutUserInput
    loginLogs?: LoginLogCreateNestedManyWithoutUserInput
    discussions?: CloneDiscussionCreateNestedManyWithoutStudentInput
    discussionMessagesSent?: DiscussionMessageCreateNestedManyWithoutSenderInput
  }

  export type UserUncheckedCreateWithoutUploadedFilesInput = {
    id?: number
    email: string
    password: string
    name: string
    role: string
    status?: string
    schoolId?: number | null
    resetToken?: string | null
    resetTokenExpiry?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    demographics?: DemographicsUncheckedCreateNestedOneWithoutUserInput
    assignedFiles?: UploadedFileUncheckedCreateNestedManyWithoutAssignedToInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    receivedMessages?: MessageUncheckedCreateNestedManyWithoutRecipientInput
    practiceProgress?: UserPracticeProgressUncheckedCreateNestedManyWithoutUserInput
    loginLogs?: LoginLogUncheckedCreateNestedManyWithoutUserInput
    discussions?: CloneDiscussionUncheckedCreateNestedManyWithoutStudentInput
    discussionMessagesSent?: DiscussionMessageUncheckedCreateNestedManyWithoutSenderInput
  }

  export type UserCreateOrConnectWithoutUploadedFilesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutUploadedFilesInput, UserUncheckedCreateWithoutUploadedFilesInput>
  }

  export type MessageCreateWithoutCloneInput = {
    subject: string
    content: string
    messageType?: string
    isRead?: boolean
    cloneProgress?: number | null
    currentStep?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isGroupMessage?: boolean | null
    groupParticipants?: string | null
    sender: UserCreateNestedOneWithoutSentMessagesInput
    recipient: UserCreateNestedOneWithoutReceivedMessagesInput
  }

  export type MessageUncheckedCreateWithoutCloneInput = {
    id?: number
    subject: string
    content: string
    messageType?: string
    isRead?: boolean
    senderId: number
    recipientId: number
    cloneProgress?: number | null
    currentStep?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isGroupMessage?: boolean | null
    groupParticipants?: string | null
  }

  export type MessageCreateOrConnectWithoutCloneInput = {
    where: MessageWhereUniqueInput
    create: XOR<MessageCreateWithoutCloneInput, MessageUncheckedCreateWithoutCloneInput>
  }

  export type MessageCreateManyCloneInputEnvelope = {
    data: MessageCreateManyCloneInput | MessageCreateManyCloneInput[]
  }

  export type CloneDiscussionCreateWithoutCloneInput = {
    title: string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    lastMessageAt?: Date | string
    student: UserCreateNestedOneWithoutDiscussionsInput
    practiceClone?: PracticeCloneCreateNestedOneWithoutCloneDiscussionsInput
    messages?: DiscussionMessageCreateNestedManyWithoutDiscussionInput
  }

  export type CloneDiscussionUncheckedCreateWithoutCloneInput = {
    id?: number
    studentId: number
    practiceCloneId?: number | null
    title: string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    lastMessageAt?: Date | string
    messages?: DiscussionMessageUncheckedCreateNestedManyWithoutDiscussionInput
  }

  export type CloneDiscussionCreateOrConnectWithoutCloneInput = {
    where: CloneDiscussionWhereUniqueInput
    create: XOR<CloneDiscussionCreateWithoutCloneInput, CloneDiscussionUncheckedCreateWithoutCloneInput>
  }

  export type CloneDiscussionCreateManyCloneInputEnvelope = {
    data: CloneDiscussionCreateManyCloneInput | CloneDiscussionCreateManyCloneInput[]
  }

  export type UserUpsertWithoutAssignedFilesInput = {
    update: XOR<UserUpdateWithoutAssignedFilesInput, UserUncheckedUpdateWithoutAssignedFilesInput>
    create: XOR<UserCreateWithoutAssignedFilesInput, UserUncheckedCreateWithoutAssignedFilesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAssignedFilesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAssignedFilesInput, UserUncheckedUpdateWithoutAssignedFilesInput>
  }

  export type UserUpdateWithoutAssignedFilesInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    school?: SchoolUpdateOneWithoutUsersNestedInput
    demographics?: DemographicsUpdateOneWithoutUserNestedInput
    uploadedFiles?: UploadedFileUpdateManyWithoutUploadedByNestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    receivedMessages?: MessageUpdateManyWithoutRecipientNestedInput
    practiceProgress?: UserPracticeProgressUpdateManyWithoutUserNestedInput
    loginLogs?: LoginLogUpdateManyWithoutUserNestedInput
    discussions?: CloneDiscussionUpdateManyWithoutStudentNestedInput
    discussionMessagesSent?: DiscussionMessageUpdateManyWithoutSenderNestedInput
  }

  export type UserUncheckedUpdateWithoutAssignedFilesInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    schoolId?: NullableIntFieldUpdateOperationsInput | number | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    demographics?: DemographicsUncheckedUpdateOneWithoutUserNestedInput
    uploadedFiles?: UploadedFileUncheckedUpdateManyWithoutUploadedByNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    receivedMessages?: MessageUncheckedUpdateManyWithoutRecipientNestedInput
    practiceProgress?: UserPracticeProgressUncheckedUpdateManyWithoutUserNestedInput
    loginLogs?: LoginLogUncheckedUpdateManyWithoutUserNestedInput
    discussions?: CloneDiscussionUncheckedUpdateManyWithoutStudentNestedInput
    discussionMessagesSent?: DiscussionMessageUncheckedUpdateManyWithoutSenderNestedInput
  }

  export type UserUpsertWithoutUploadedFilesInput = {
    update: XOR<UserUpdateWithoutUploadedFilesInput, UserUncheckedUpdateWithoutUploadedFilesInput>
    create: XOR<UserCreateWithoutUploadedFilesInput, UserUncheckedCreateWithoutUploadedFilesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutUploadedFilesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutUploadedFilesInput, UserUncheckedUpdateWithoutUploadedFilesInput>
  }

  export type UserUpdateWithoutUploadedFilesInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    school?: SchoolUpdateOneWithoutUsersNestedInput
    demographics?: DemographicsUpdateOneWithoutUserNestedInput
    assignedFiles?: UploadedFileUpdateManyWithoutAssignedToNestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    receivedMessages?: MessageUpdateManyWithoutRecipientNestedInput
    practiceProgress?: UserPracticeProgressUpdateManyWithoutUserNestedInput
    loginLogs?: LoginLogUpdateManyWithoutUserNestedInput
    discussions?: CloneDiscussionUpdateManyWithoutStudentNestedInput
    discussionMessagesSent?: DiscussionMessageUpdateManyWithoutSenderNestedInput
  }

  export type UserUncheckedUpdateWithoutUploadedFilesInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    schoolId?: NullableIntFieldUpdateOperationsInput | number | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    demographics?: DemographicsUncheckedUpdateOneWithoutUserNestedInput
    assignedFiles?: UploadedFileUncheckedUpdateManyWithoutAssignedToNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    receivedMessages?: MessageUncheckedUpdateManyWithoutRecipientNestedInput
    practiceProgress?: UserPracticeProgressUncheckedUpdateManyWithoutUserNestedInput
    loginLogs?: LoginLogUncheckedUpdateManyWithoutUserNestedInput
    discussions?: CloneDiscussionUncheckedUpdateManyWithoutStudentNestedInput
    discussionMessagesSent?: DiscussionMessageUncheckedUpdateManyWithoutSenderNestedInput
  }

  export type MessageUpsertWithWhereUniqueWithoutCloneInput = {
    where: MessageWhereUniqueInput
    update: XOR<MessageUpdateWithoutCloneInput, MessageUncheckedUpdateWithoutCloneInput>
    create: XOR<MessageCreateWithoutCloneInput, MessageUncheckedCreateWithoutCloneInput>
  }

  export type MessageUpdateWithWhereUniqueWithoutCloneInput = {
    where: MessageWhereUniqueInput
    data: XOR<MessageUpdateWithoutCloneInput, MessageUncheckedUpdateWithoutCloneInput>
  }

  export type MessageUpdateManyWithWhereWithoutCloneInput = {
    where: MessageScalarWhereInput
    data: XOR<MessageUpdateManyMutationInput, MessageUncheckedUpdateManyWithoutCloneInput>
  }

  export type CloneDiscussionUpsertWithWhereUniqueWithoutCloneInput = {
    where: CloneDiscussionWhereUniqueInput
    update: XOR<CloneDiscussionUpdateWithoutCloneInput, CloneDiscussionUncheckedUpdateWithoutCloneInput>
    create: XOR<CloneDiscussionCreateWithoutCloneInput, CloneDiscussionUncheckedCreateWithoutCloneInput>
  }

  export type CloneDiscussionUpdateWithWhereUniqueWithoutCloneInput = {
    where: CloneDiscussionWhereUniqueInput
    data: XOR<CloneDiscussionUpdateWithoutCloneInput, CloneDiscussionUncheckedUpdateWithoutCloneInput>
  }

  export type CloneDiscussionUpdateManyWithWhereWithoutCloneInput = {
    where: CloneDiscussionScalarWhereInput
    data: XOR<CloneDiscussionUpdateManyMutationInput, CloneDiscussionUncheckedUpdateManyWithoutCloneInput>
  }

  export type UserCreateWithoutDiscussionsInput = {
    email: string
    password: string
    name: string
    role: string
    status?: string
    resetToken?: string | null
    resetTokenExpiry?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    school?: SchoolCreateNestedOneWithoutUsersInput
    demographics?: DemographicsCreateNestedOneWithoutUserInput
    assignedFiles?: UploadedFileCreateNestedManyWithoutAssignedToInput
    uploadedFiles?: UploadedFileCreateNestedManyWithoutUploadedByInput
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    receivedMessages?: MessageCreateNestedManyWithoutRecipientInput
    practiceProgress?: UserPracticeProgressCreateNestedManyWithoutUserInput
    loginLogs?: LoginLogCreateNestedManyWithoutUserInput
    discussionMessagesSent?: DiscussionMessageCreateNestedManyWithoutSenderInput
  }

  export type UserUncheckedCreateWithoutDiscussionsInput = {
    id?: number
    email: string
    password: string
    name: string
    role: string
    status?: string
    schoolId?: number | null
    resetToken?: string | null
    resetTokenExpiry?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    demographics?: DemographicsUncheckedCreateNestedOneWithoutUserInput
    assignedFiles?: UploadedFileUncheckedCreateNestedManyWithoutAssignedToInput
    uploadedFiles?: UploadedFileUncheckedCreateNestedManyWithoutUploadedByInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    receivedMessages?: MessageUncheckedCreateNestedManyWithoutRecipientInput
    practiceProgress?: UserPracticeProgressUncheckedCreateNestedManyWithoutUserInput
    loginLogs?: LoginLogUncheckedCreateNestedManyWithoutUserInput
    discussionMessagesSent?: DiscussionMessageUncheckedCreateNestedManyWithoutSenderInput
  }

  export type UserCreateOrConnectWithoutDiscussionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutDiscussionsInput, UserUncheckedCreateWithoutDiscussionsInput>
  }

  export type UploadedFileCreateWithoutCloneDiscussionsInput = {
    filename: string
    originalName: string
    cloneName: string
    size: string
    uploadDate: string
    status?: string
    progress?: number
    analysisData?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    assignedTo?: UserCreateNestedOneWithoutAssignedFilesInput
    uploadedBy: UserCreateNestedOneWithoutUploadedFilesInput
    messages?: MessageCreateNestedManyWithoutCloneInput
  }

  export type UploadedFileUncheckedCreateWithoutCloneDiscussionsInput = {
    id?: number
    filename: string
    originalName: string
    cloneName: string
    size: string
    uploadDate: string
    status?: string
    progress?: number
    analysisData?: string | null
    assignedToId?: number | null
    uploadedById: number
    createdAt?: Date | string
    updatedAt?: Date | string
    messages?: MessageUncheckedCreateNestedManyWithoutCloneInput
  }

  export type UploadedFileCreateOrConnectWithoutCloneDiscussionsInput = {
    where: UploadedFileWhereUniqueInput
    create: XOR<UploadedFileCreateWithoutCloneDiscussionsInput, UploadedFileUncheckedCreateWithoutCloneDiscussionsInput>
  }

  export type PracticeCloneCreateWithoutCloneDiscussionsInput = {
    cloneName: string
    filename: string
    originalName: string
    description?: string | null
    isActive?: boolean
    uploadDate?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    practiceAnswers?: PracticeAnswerCreateNestedManyWithoutPracticeCloneInput
    userProgress?: UserPracticeProgressCreateNestedManyWithoutPracticeCloneInput
  }

  export type PracticeCloneUncheckedCreateWithoutCloneDiscussionsInput = {
    id?: number
    cloneName: string
    filename: string
    originalName: string
    description?: string | null
    isActive?: boolean
    uploadDate?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    practiceAnswers?: PracticeAnswerUncheckedCreateNestedManyWithoutPracticeCloneInput
    userProgress?: UserPracticeProgressUncheckedCreateNestedManyWithoutPracticeCloneInput
  }

  export type PracticeCloneCreateOrConnectWithoutCloneDiscussionsInput = {
    where: PracticeCloneWhereUniqueInput
    create: XOR<PracticeCloneCreateWithoutCloneDiscussionsInput, PracticeCloneUncheckedCreateWithoutCloneDiscussionsInput>
  }

  export type DiscussionMessageCreateWithoutDiscussionInput = {
    content: string
    messageType?: string
    readBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sender: UserCreateNestedOneWithoutDiscussionMessagesSentInput
  }

  export type DiscussionMessageUncheckedCreateWithoutDiscussionInput = {
    id?: number
    senderId: number
    content: string
    messageType?: string
    readBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DiscussionMessageCreateOrConnectWithoutDiscussionInput = {
    where: DiscussionMessageWhereUniqueInput
    create: XOR<DiscussionMessageCreateWithoutDiscussionInput, DiscussionMessageUncheckedCreateWithoutDiscussionInput>
  }

  export type DiscussionMessageCreateManyDiscussionInputEnvelope = {
    data: DiscussionMessageCreateManyDiscussionInput | DiscussionMessageCreateManyDiscussionInput[]
  }

  export type UserUpsertWithoutDiscussionsInput = {
    update: XOR<UserUpdateWithoutDiscussionsInput, UserUncheckedUpdateWithoutDiscussionsInput>
    create: XOR<UserCreateWithoutDiscussionsInput, UserUncheckedCreateWithoutDiscussionsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutDiscussionsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutDiscussionsInput, UserUncheckedUpdateWithoutDiscussionsInput>
  }

  export type UserUpdateWithoutDiscussionsInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    school?: SchoolUpdateOneWithoutUsersNestedInput
    demographics?: DemographicsUpdateOneWithoutUserNestedInput
    assignedFiles?: UploadedFileUpdateManyWithoutAssignedToNestedInput
    uploadedFiles?: UploadedFileUpdateManyWithoutUploadedByNestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    receivedMessages?: MessageUpdateManyWithoutRecipientNestedInput
    practiceProgress?: UserPracticeProgressUpdateManyWithoutUserNestedInput
    loginLogs?: LoginLogUpdateManyWithoutUserNestedInput
    discussionMessagesSent?: DiscussionMessageUpdateManyWithoutSenderNestedInput
  }

  export type UserUncheckedUpdateWithoutDiscussionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    schoolId?: NullableIntFieldUpdateOperationsInput | number | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    demographics?: DemographicsUncheckedUpdateOneWithoutUserNestedInput
    assignedFiles?: UploadedFileUncheckedUpdateManyWithoutAssignedToNestedInput
    uploadedFiles?: UploadedFileUncheckedUpdateManyWithoutUploadedByNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    receivedMessages?: MessageUncheckedUpdateManyWithoutRecipientNestedInput
    practiceProgress?: UserPracticeProgressUncheckedUpdateManyWithoutUserNestedInput
    loginLogs?: LoginLogUncheckedUpdateManyWithoutUserNestedInput
    discussionMessagesSent?: DiscussionMessageUncheckedUpdateManyWithoutSenderNestedInput
  }

  export type UploadedFileUpsertWithoutCloneDiscussionsInput = {
    update: XOR<UploadedFileUpdateWithoutCloneDiscussionsInput, UploadedFileUncheckedUpdateWithoutCloneDiscussionsInput>
    create: XOR<UploadedFileCreateWithoutCloneDiscussionsInput, UploadedFileUncheckedCreateWithoutCloneDiscussionsInput>
    where?: UploadedFileWhereInput
  }

  export type UploadedFileUpdateToOneWithWhereWithoutCloneDiscussionsInput = {
    where?: UploadedFileWhereInput
    data: XOR<UploadedFileUpdateWithoutCloneDiscussionsInput, UploadedFileUncheckedUpdateWithoutCloneDiscussionsInput>
  }

  export type UploadedFileUpdateWithoutCloneDiscussionsInput = {
    filename?: StringFieldUpdateOperationsInput | string
    originalName?: StringFieldUpdateOperationsInput | string
    cloneName?: StringFieldUpdateOperationsInput | string
    size?: StringFieldUpdateOperationsInput | string
    uploadDate?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    progress?: IntFieldUpdateOperationsInput | number
    analysisData?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedTo?: UserUpdateOneWithoutAssignedFilesNestedInput
    uploadedBy?: UserUpdateOneRequiredWithoutUploadedFilesNestedInput
    messages?: MessageUpdateManyWithoutCloneNestedInput
  }

  export type UploadedFileUncheckedUpdateWithoutCloneDiscussionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    filename?: StringFieldUpdateOperationsInput | string
    originalName?: StringFieldUpdateOperationsInput | string
    cloneName?: StringFieldUpdateOperationsInput | string
    size?: StringFieldUpdateOperationsInput | string
    uploadDate?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    progress?: IntFieldUpdateOperationsInput | number
    analysisData?: NullableStringFieldUpdateOperationsInput | string | null
    assignedToId?: NullableIntFieldUpdateOperationsInput | number | null
    uploadedById?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    messages?: MessageUncheckedUpdateManyWithoutCloneNestedInput
  }

  export type PracticeCloneUpsertWithoutCloneDiscussionsInput = {
    update: XOR<PracticeCloneUpdateWithoutCloneDiscussionsInput, PracticeCloneUncheckedUpdateWithoutCloneDiscussionsInput>
    create: XOR<PracticeCloneCreateWithoutCloneDiscussionsInput, PracticeCloneUncheckedCreateWithoutCloneDiscussionsInput>
    where?: PracticeCloneWhereInput
  }

  export type PracticeCloneUpdateToOneWithWhereWithoutCloneDiscussionsInput = {
    where?: PracticeCloneWhereInput
    data: XOR<PracticeCloneUpdateWithoutCloneDiscussionsInput, PracticeCloneUncheckedUpdateWithoutCloneDiscussionsInput>
  }

  export type PracticeCloneUpdateWithoutCloneDiscussionsInput = {
    cloneName?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    originalName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    uploadDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    practiceAnswers?: PracticeAnswerUpdateManyWithoutPracticeCloneNestedInput
    userProgress?: UserPracticeProgressUpdateManyWithoutPracticeCloneNestedInput
  }

  export type PracticeCloneUncheckedUpdateWithoutCloneDiscussionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    cloneName?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    originalName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    uploadDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    practiceAnswers?: PracticeAnswerUncheckedUpdateManyWithoutPracticeCloneNestedInput
    userProgress?: UserPracticeProgressUncheckedUpdateManyWithoutPracticeCloneNestedInput
  }

  export type DiscussionMessageUpsertWithWhereUniqueWithoutDiscussionInput = {
    where: DiscussionMessageWhereUniqueInput
    update: XOR<DiscussionMessageUpdateWithoutDiscussionInput, DiscussionMessageUncheckedUpdateWithoutDiscussionInput>
    create: XOR<DiscussionMessageCreateWithoutDiscussionInput, DiscussionMessageUncheckedCreateWithoutDiscussionInput>
  }

  export type DiscussionMessageUpdateWithWhereUniqueWithoutDiscussionInput = {
    where: DiscussionMessageWhereUniqueInput
    data: XOR<DiscussionMessageUpdateWithoutDiscussionInput, DiscussionMessageUncheckedUpdateWithoutDiscussionInput>
  }

  export type DiscussionMessageUpdateManyWithWhereWithoutDiscussionInput = {
    where: DiscussionMessageScalarWhereInput
    data: XOR<DiscussionMessageUpdateManyMutationInput, DiscussionMessageUncheckedUpdateManyWithoutDiscussionInput>
  }

  export type CloneDiscussionCreateWithoutMessagesInput = {
    title: string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    lastMessageAt?: Date | string
    student: UserCreateNestedOneWithoutDiscussionsInput
    clone?: UploadedFileCreateNestedOneWithoutCloneDiscussionsInput
    practiceClone?: PracticeCloneCreateNestedOneWithoutCloneDiscussionsInput
  }

  export type CloneDiscussionUncheckedCreateWithoutMessagesInput = {
    id?: number
    studentId: number
    cloneId?: number | null
    practiceCloneId?: number | null
    title: string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    lastMessageAt?: Date | string
  }

  export type CloneDiscussionCreateOrConnectWithoutMessagesInput = {
    where: CloneDiscussionWhereUniqueInput
    create: XOR<CloneDiscussionCreateWithoutMessagesInput, CloneDiscussionUncheckedCreateWithoutMessagesInput>
  }

  export type UserCreateWithoutDiscussionMessagesSentInput = {
    email: string
    password: string
    name: string
    role: string
    status?: string
    resetToken?: string | null
    resetTokenExpiry?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    school?: SchoolCreateNestedOneWithoutUsersInput
    demographics?: DemographicsCreateNestedOneWithoutUserInput
    assignedFiles?: UploadedFileCreateNestedManyWithoutAssignedToInput
    uploadedFiles?: UploadedFileCreateNestedManyWithoutUploadedByInput
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    receivedMessages?: MessageCreateNestedManyWithoutRecipientInput
    practiceProgress?: UserPracticeProgressCreateNestedManyWithoutUserInput
    loginLogs?: LoginLogCreateNestedManyWithoutUserInput
    discussions?: CloneDiscussionCreateNestedManyWithoutStudentInput
  }

  export type UserUncheckedCreateWithoutDiscussionMessagesSentInput = {
    id?: number
    email: string
    password: string
    name: string
    role: string
    status?: string
    schoolId?: number | null
    resetToken?: string | null
    resetTokenExpiry?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    demographics?: DemographicsUncheckedCreateNestedOneWithoutUserInput
    assignedFiles?: UploadedFileUncheckedCreateNestedManyWithoutAssignedToInput
    uploadedFiles?: UploadedFileUncheckedCreateNestedManyWithoutUploadedByInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    receivedMessages?: MessageUncheckedCreateNestedManyWithoutRecipientInput
    practiceProgress?: UserPracticeProgressUncheckedCreateNestedManyWithoutUserInput
    loginLogs?: LoginLogUncheckedCreateNestedManyWithoutUserInput
    discussions?: CloneDiscussionUncheckedCreateNestedManyWithoutStudentInput
  }

  export type UserCreateOrConnectWithoutDiscussionMessagesSentInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutDiscussionMessagesSentInput, UserUncheckedCreateWithoutDiscussionMessagesSentInput>
  }

  export type CloneDiscussionUpsertWithoutMessagesInput = {
    update: XOR<CloneDiscussionUpdateWithoutMessagesInput, CloneDiscussionUncheckedUpdateWithoutMessagesInput>
    create: XOR<CloneDiscussionCreateWithoutMessagesInput, CloneDiscussionUncheckedCreateWithoutMessagesInput>
    where?: CloneDiscussionWhereInput
  }

  export type CloneDiscussionUpdateToOneWithWhereWithoutMessagesInput = {
    where?: CloneDiscussionWhereInput
    data: XOR<CloneDiscussionUpdateWithoutMessagesInput, CloneDiscussionUncheckedUpdateWithoutMessagesInput>
  }

  export type CloneDiscussionUpdateWithoutMessagesInput = {
    title?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastMessageAt?: DateTimeFieldUpdateOperationsInput | Date | string
    student?: UserUpdateOneRequiredWithoutDiscussionsNestedInput
    clone?: UploadedFileUpdateOneWithoutCloneDiscussionsNestedInput
    practiceClone?: PracticeCloneUpdateOneWithoutCloneDiscussionsNestedInput
  }

  export type CloneDiscussionUncheckedUpdateWithoutMessagesInput = {
    id?: IntFieldUpdateOperationsInput | number
    studentId?: IntFieldUpdateOperationsInput | number
    cloneId?: NullableIntFieldUpdateOperationsInput | number | null
    practiceCloneId?: NullableIntFieldUpdateOperationsInput | number | null
    title?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastMessageAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUpsertWithoutDiscussionMessagesSentInput = {
    update: XOR<UserUpdateWithoutDiscussionMessagesSentInput, UserUncheckedUpdateWithoutDiscussionMessagesSentInput>
    create: XOR<UserCreateWithoutDiscussionMessagesSentInput, UserUncheckedCreateWithoutDiscussionMessagesSentInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutDiscussionMessagesSentInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutDiscussionMessagesSentInput, UserUncheckedUpdateWithoutDiscussionMessagesSentInput>
  }

  export type UserUpdateWithoutDiscussionMessagesSentInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    school?: SchoolUpdateOneWithoutUsersNestedInput
    demographics?: DemographicsUpdateOneWithoutUserNestedInput
    assignedFiles?: UploadedFileUpdateManyWithoutAssignedToNestedInput
    uploadedFiles?: UploadedFileUpdateManyWithoutUploadedByNestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    receivedMessages?: MessageUpdateManyWithoutRecipientNestedInput
    practiceProgress?: UserPracticeProgressUpdateManyWithoutUserNestedInput
    loginLogs?: LoginLogUpdateManyWithoutUserNestedInput
    discussions?: CloneDiscussionUpdateManyWithoutStudentNestedInput
  }

  export type UserUncheckedUpdateWithoutDiscussionMessagesSentInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    schoolId?: NullableIntFieldUpdateOperationsInput | number | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    demographics?: DemographicsUncheckedUpdateOneWithoutUserNestedInput
    assignedFiles?: UploadedFileUncheckedUpdateManyWithoutAssignedToNestedInput
    uploadedFiles?: UploadedFileUncheckedUpdateManyWithoutUploadedByNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    receivedMessages?: MessageUncheckedUpdateManyWithoutRecipientNestedInput
    practiceProgress?: UserPracticeProgressUncheckedUpdateManyWithoutUserNestedInput
    loginLogs?: LoginLogUncheckedUpdateManyWithoutUserNestedInput
    discussions?: CloneDiscussionUncheckedUpdateManyWithoutStudentNestedInput
  }

  export type UserCreateWithoutSentMessagesInput = {
    email: string
    password: string
    name: string
    role: string
    status?: string
    resetToken?: string | null
    resetTokenExpiry?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    school?: SchoolCreateNestedOneWithoutUsersInput
    demographics?: DemographicsCreateNestedOneWithoutUserInput
    assignedFiles?: UploadedFileCreateNestedManyWithoutAssignedToInput
    uploadedFiles?: UploadedFileCreateNestedManyWithoutUploadedByInput
    receivedMessages?: MessageCreateNestedManyWithoutRecipientInput
    practiceProgress?: UserPracticeProgressCreateNestedManyWithoutUserInput
    loginLogs?: LoginLogCreateNestedManyWithoutUserInput
    discussions?: CloneDiscussionCreateNestedManyWithoutStudentInput
    discussionMessagesSent?: DiscussionMessageCreateNestedManyWithoutSenderInput
  }

  export type UserUncheckedCreateWithoutSentMessagesInput = {
    id?: number
    email: string
    password: string
    name: string
    role: string
    status?: string
    schoolId?: number | null
    resetToken?: string | null
    resetTokenExpiry?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    demographics?: DemographicsUncheckedCreateNestedOneWithoutUserInput
    assignedFiles?: UploadedFileUncheckedCreateNestedManyWithoutAssignedToInput
    uploadedFiles?: UploadedFileUncheckedCreateNestedManyWithoutUploadedByInput
    receivedMessages?: MessageUncheckedCreateNestedManyWithoutRecipientInput
    practiceProgress?: UserPracticeProgressUncheckedCreateNestedManyWithoutUserInput
    loginLogs?: LoginLogUncheckedCreateNestedManyWithoutUserInput
    discussions?: CloneDiscussionUncheckedCreateNestedManyWithoutStudentInput
    discussionMessagesSent?: DiscussionMessageUncheckedCreateNestedManyWithoutSenderInput
  }

  export type UserCreateOrConnectWithoutSentMessagesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSentMessagesInput, UserUncheckedCreateWithoutSentMessagesInput>
  }

  export type UserCreateWithoutReceivedMessagesInput = {
    email: string
    password: string
    name: string
    role: string
    status?: string
    resetToken?: string | null
    resetTokenExpiry?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    school?: SchoolCreateNestedOneWithoutUsersInput
    demographics?: DemographicsCreateNestedOneWithoutUserInput
    assignedFiles?: UploadedFileCreateNestedManyWithoutAssignedToInput
    uploadedFiles?: UploadedFileCreateNestedManyWithoutUploadedByInput
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    practiceProgress?: UserPracticeProgressCreateNestedManyWithoutUserInput
    loginLogs?: LoginLogCreateNestedManyWithoutUserInput
    discussions?: CloneDiscussionCreateNestedManyWithoutStudentInput
    discussionMessagesSent?: DiscussionMessageCreateNestedManyWithoutSenderInput
  }

  export type UserUncheckedCreateWithoutReceivedMessagesInput = {
    id?: number
    email: string
    password: string
    name: string
    role: string
    status?: string
    schoolId?: number | null
    resetToken?: string | null
    resetTokenExpiry?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    demographics?: DemographicsUncheckedCreateNestedOneWithoutUserInput
    assignedFiles?: UploadedFileUncheckedCreateNestedManyWithoutAssignedToInput
    uploadedFiles?: UploadedFileUncheckedCreateNestedManyWithoutUploadedByInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    practiceProgress?: UserPracticeProgressUncheckedCreateNestedManyWithoutUserInput
    loginLogs?: LoginLogUncheckedCreateNestedManyWithoutUserInput
    discussions?: CloneDiscussionUncheckedCreateNestedManyWithoutStudentInput
    discussionMessagesSent?: DiscussionMessageUncheckedCreateNestedManyWithoutSenderInput
  }

  export type UserCreateOrConnectWithoutReceivedMessagesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutReceivedMessagesInput, UserUncheckedCreateWithoutReceivedMessagesInput>
  }

  export type UploadedFileCreateWithoutMessagesInput = {
    filename: string
    originalName: string
    cloneName: string
    size: string
    uploadDate: string
    status?: string
    progress?: number
    analysisData?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    assignedTo?: UserCreateNestedOneWithoutAssignedFilesInput
    uploadedBy: UserCreateNestedOneWithoutUploadedFilesInput
    cloneDiscussions?: CloneDiscussionCreateNestedManyWithoutCloneInput
  }

  export type UploadedFileUncheckedCreateWithoutMessagesInput = {
    id?: number
    filename: string
    originalName: string
    cloneName: string
    size: string
    uploadDate: string
    status?: string
    progress?: number
    analysisData?: string | null
    assignedToId?: number | null
    uploadedById: number
    createdAt?: Date | string
    updatedAt?: Date | string
    cloneDiscussions?: CloneDiscussionUncheckedCreateNestedManyWithoutCloneInput
  }

  export type UploadedFileCreateOrConnectWithoutMessagesInput = {
    where: UploadedFileWhereUniqueInput
    create: XOR<UploadedFileCreateWithoutMessagesInput, UploadedFileUncheckedCreateWithoutMessagesInput>
  }

  export type UserUpsertWithoutSentMessagesInput = {
    update: XOR<UserUpdateWithoutSentMessagesInput, UserUncheckedUpdateWithoutSentMessagesInput>
    create: XOR<UserCreateWithoutSentMessagesInput, UserUncheckedCreateWithoutSentMessagesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSentMessagesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSentMessagesInput, UserUncheckedUpdateWithoutSentMessagesInput>
  }

  export type UserUpdateWithoutSentMessagesInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    school?: SchoolUpdateOneWithoutUsersNestedInput
    demographics?: DemographicsUpdateOneWithoutUserNestedInput
    assignedFiles?: UploadedFileUpdateManyWithoutAssignedToNestedInput
    uploadedFiles?: UploadedFileUpdateManyWithoutUploadedByNestedInput
    receivedMessages?: MessageUpdateManyWithoutRecipientNestedInput
    practiceProgress?: UserPracticeProgressUpdateManyWithoutUserNestedInput
    loginLogs?: LoginLogUpdateManyWithoutUserNestedInput
    discussions?: CloneDiscussionUpdateManyWithoutStudentNestedInput
    discussionMessagesSent?: DiscussionMessageUpdateManyWithoutSenderNestedInput
  }

  export type UserUncheckedUpdateWithoutSentMessagesInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    schoolId?: NullableIntFieldUpdateOperationsInput | number | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    demographics?: DemographicsUncheckedUpdateOneWithoutUserNestedInput
    assignedFiles?: UploadedFileUncheckedUpdateManyWithoutAssignedToNestedInput
    uploadedFiles?: UploadedFileUncheckedUpdateManyWithoutUploadedByNestedInput
    receivedMessages?: MessageUncheckedUpdateManyWithoutRecipientNestedInput
    practiceProgress?: UserPracticeProgressUncheckedUpdateManyWithoutUserNestedInput
    loginLogs?: LoginLogUncheckedUpdateManyWithoutUserNestedInput
    discussions?: CloneDiscussionUncheckedUpdateManyWithoutStudentNestedInput
    discussionMessagesSent?: DiscussionMessageUncheckedUpdateManyWithoutSenderNestedInput
  }

  export type UserUpsertWithoutReceivedMessagesInput = {
    update: XOR<UserUpdateWithoutReceivedMessagesInput, UserUncheckedUpdateWithoutReceivedMessagesInput>
    create: XOR<UserCreateWithoutReceivedMessagesInput, UserUncheckedCreateWithoutReceivedMessagesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutReceivedMessagesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutReceivedMessagesInput, UserUncheckedUpdateWithoutReceivedMessagesInput>
  }

  export type UserUpdateWithoutReceivedMessagesInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    school?: SchoolUpdateOneWithoutUsersNestedInput
    demographics?: DemographicsUpdateOneWithoutUserNestedInput
    assignedFiles?: UploadedFileUpdateManyWithoutAssignedToNestedInput
    uploadedFiles?: UploadedFileUpdateManyWithoutUploadedByNestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    practiceProgress?: UserPracticeProgressUpdateManyWithoutUserNestedInput
    loginLogs?: LoginLogUpdateManyWithoutUserNestedInput
    discussions?: CloneDiscussionUpdateManyWithoutStudentNestedInput
    discussionMessagesSent?: DiscussionMessageUpdateManyWithoutSenderNestedInput
  }

  export type UserUncheckedUpdateWithoutReceivedMessagesInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    schoolId?: NullableIntFieldUpdateOperationsInput | number | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    demographics?: DemographicsUncheckedUpdateOneWithoutUserNestedInput
    assignedFiles?: UploadedFileUncheckedUpdateManyWithoutAssignedToNestedInput
    uploadedFiles?: UploadedFileUncheckedUpdateManyWithoutUploadedByNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    practiceProgress?: UserPracticeProgressUncheckedUpdateManyWithoutUserNestedInput
    loginLogs?: LoginLogUncheckedUpdateManyWithoutUserNestedInput
    discussions?: CloneDiscussionUncheckedUpdateManyWithoutStudentNestedInput
    discussionMessagesSent?: DiscussionMessageUncheckedUpdateManyWithoutSenderNestedInput
  }

  export type UploadedFileUpsertWithoutMessagesInput = {
    update: XOR<UploadedFileUpdateWithoutMessagesInput, UploadedFileUncheckedUpdateWithoutMessagesInput>
    create: XOR<UploadedFileCreateWithoutMessagesInput, UploadedFileUncheckedCreateWithoutMessagesInput>
    where?: UploadedFileWhereInput
  }

  export type UploadedFileUpdateToOneWithWhereWithoutMessagesInput = {
    where?: UploadedFileWhereInput
    data: XOR<UploadedFileUpdateWithoutMessagesInput, UploadedFileUncheckedUpdateWithoutMessagesInput>
  }

  export type UploadedFileUpdateWithoutMessagesInput = {
    filename?: StringFieldUpdateOperationsInput | string
    originalName?: StringFieldUpdateOperationsInput | string
    cloneName?: StringFieldUpdateOperationsInput | string
    size?: StringFieldUpdateOperationsInput | string
    uploadDate?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    progress?: IntFieldUpdateOperationsInput | number
    analysisData?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedTo?: UserUpdateOneWithoutAssignedFilesNestedInput
    uploadedBy?: UserUpdateOneRequiredWithoutUploadedFilesNestedInput
    cloneDiscussions?: CloneDiscussionUpdateManyWithoutCloneNestedInput
  }

  export type UploadedFileUncheckedUpdateWithoutMessagesInput = {
    id?: IntFieldUpdateOperationsInput | number
    filename?: StringFieldUpdateOperationsInput | string
    originalName?: StringFieldUpdateOperationsInput | string
    cloneName?: StringFieldUpdateOperationsInput | string
    size?: StringFieldUpdateOperationsInput | string
    uploadDate?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    progress?: IntFieldUpdateOperationsInput | number
    analysisData?: NullableStringFieldUpdateOperationsInput | string | null
    assignedToId?: NullableIntFieldUpdateOperationsInput | number | null
    uploadedById?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cloneDiscussions?: CloneDiscussionUncheckedUpdateManyWithoutCloneNestedInput
  }

  export type PracticeAnswerCreateWithoutPracticeCloneInput = {
    id?: string
    questionId: string
    correctAnswer: string
    explanation?: string | null
  }

  export type PracticeAnswerUncheckedCreateWithoutPracticeCloneInput = {
    id?: string
    questionId: string
    correctAnswer: string
    explanation?: string | null
  }

  export type PracticeAnswerCreateOrConnectWithoutPracticeCloneInput = {
    where: PracticeAnswerWhereUniqueInput
    create: XOR<PracticeAnswerCreateWithoutPracticeCloneInput, PracticeAnswerUncheckedCreateWithoutPracticeCloneInput>
  }

  export type PracticeAnswerCreateManyPracticeCloneInputEnvelope = {
    data: PracticeAnswerCreateManyPracticeCloneInput | PracticeAnswerCreateManyPracticeCloneInput[]
  }

  export type UserPracticeProgressCreateWithoutPracticeCloneInput = {
    progress?: number
    answers?: string | null
    currentStep?: string
    status?: string
    lastSaved?: Date | string | null
    submittedAt?: Date | string | null
    reviewComments?: string | null
    reviewScore?: number | null
    lastReviewed?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutPracticeProgressInput
  }

  export type UserPracticeProgressUncheckedCreateWithoutPracticeCloneInput = {
    id?: number
    userId: number
    progress?: number
    answers?: string | null
    currentStep?: string
    status?: string
    lastSaved?: Date | string | null
    submittedAt?: Date | string | null
    reviewComments?: string | null
    reviewScore?: number | null
    lastReviewed?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserPracticeProgressCreateOrConnectWithoutPracticeCloneInput = {
    where: UserPracticeProgressWhereUniqueInput
    create: XOR<UserPracticeProgressCreateWithoutPracticeCloneInput, UserPracticeProgressUncheckedCreateWithoutPracticeCloneInput>
  }

  export type UserPracticeProgressCreateManyPracticeCloneInputEnvelope = {
    data: UserPracticeProgressCreateManyPracticeCloneInput | UserPracticeProgressCreateManyPracticeCloneInput[]
  }

  export type CloneDiscussionCreateWithoutPracticeCloneInput = {
    title: string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    lastMessageAt?: Date | string
    student: UserCreateNestedOneWithoutDiscussionsInput
    clone?: UploadedFileCreateNestedOneWithoutCloneDiscussionsInput
    messages?: DiscussionMessageCreateNestedManyWithoutDiscussionInput
  }

  export type CloneDiscussionUncheckedCreateWithoutPracticeCloneInput = {
    id?: number
    studentId: number
    cloneId?: number | null
    title: string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    lastMessageAt?: Date | string
    messages?: DiscussionMessageUncheckedCreateNestedManyWithoutDiscussionInput
  }

  export type CloneDiscussionCreateOrConnectWithoutPracticeCloneInput = {
    where: CloneDiscussionWhereUniqueInput
    create: XOR<CloneDiscussionCreateWithoutPracticeCloneInput, CloneDiscussionUncheckedCreateWithoutPracticeCloneInput>
  }

  export type CloneDiscussionCreateManyPracticeCloneInputEnvelope = {
    data: CloneDiscussionCreateManyPracticeCloneInput | CloneDiscussionCreateManyPracticeCloneInput[]
  }

  export type PracticeAnswerUpsertWithWhereUniqueWithoutPracticeCloneInput = {
    where: PracticeAnswerWhereUniqueInput
    update: XOR<PracticeAnswerUpdateWithoutPracticeCloneInput, PracticeAnswerUncheckedUpdateWithoutPracticeCloneInput>
    create: XOR<PracticeAnswerCreateWithoutPracticeCloneInput, PracticeAnswerUncheckedCreateWithoutPracticeCloneInput>
  }

  export type PracticeAnswerUpdateWithWhereUniqueWithoutPracticeCloneInput = {
    where: PracticeAnswerWhereUniqueInput
    data: XOR<PracticeAnswerUpdateWithoutPracticeCloneInput, PracticeAnswerUncheckedUpdateWithoutPracticeCloneInput>
  }

  export type PracticeAnswerUpdateManyWithWhereWithoutPracticeCloneInput = {
    where: PracticeAnswerScalarWhereInput
    data: XOR<PracticeAnswerUpdateManyMutationInput, PracticeAnswerUncheckedUpdateManyWithoutPracticeCloneInput>
  }

  export type PracticeAnswerScalarWhereInput = {
    AND?: PracticeAnswerScalarWhereInput | PracticeAnswerScalarWhereInput[]
    OR?: PracticeAnswerScalarWhereInput[]
    NOT?: PracticeAnswerScalarWhereInput | PracticeAnswerScalarWhereInput[]
    id?: StringFilter<"PracticeAnswer"> | string
    practiceCloneId?: IntFilter<"PracticeAnswer"> | number
    questionId?: StringFilter<"PracticeAnswer"> | string
    correctAnswer?: StringFilter<"PracticeAnswer"> | string
    explanation?: StringNullableFilter<"PracticeAnswer"> | string | null
  }

  export type UserPracticeProgressUpsertWithWhereUniqueWithoutPracticeCloneInput = {
    where: UserPracticeProgressWhereUniqueInput
    update: XOR<UserPracticeProgressUpdateWithoutPracticeCloneInput, UserPracticeProgressUncheckedUpdateWithoutPracticeCloneInput>
    create: XOR<UserPracticeProgressCreateWithoutPracticeCloneInput, UserPracticeProgressUncheckedCreateWithoutPracticeCloneInput>
  }

  export type UserPracticeProgressUpdateWithWhereUniqueWithoutPracticeCloneInput = {
    where: UserPracticeProgressWhereUniqueInput
    data: XOR<UserPracticeProgressUpdateWithoutPracticeCloneInput, UserPracticeProgressUncheckedUpdateWithoutPracticeCloneInput>
  }

  export type UserPracticeProgressUpdateManyWithWhereWithoutPracticeCloneInput = {
    where: UserPracticeProgressScalarWhereInput
    data: XOR<UserPracticeProgressUpdateManyMutationInput, UserPracticeProgressUncheckedUpdateManyWithoutPracticeCloneInput>
  }

  export type CloneDiscussionUpsertWithWhereUniqueWithoutPracticeCloneInput = {
    where: CloneDiscussionWhereUniqueInput
    update: XOR<CloneDiscussionUpdateWithoutPracticeCloneInput, CloneDiscussionUncheckedUpdateWithoutPracticeCloneInput>
    create: XOR<CloneDiscussionCreateWithoutPracticeCloneInput, CloneDiscussionUncheckedCreateWithoutPracticeCloneInput>
  }

  export type CloneDiscussionUpdateWithWhereUniqueWithoutPracticeCloneInput = {
    where: CloneDiscussionWhereUniqueInput
    data: XOR<CloneDiscussionUpdateWithoutPracticeCloneInput, CloneDiscussionUncheckedUpdateWithoutPracticeCloneInput>
  }

  export type CloneDiscussionUpdateManyWithWhereWithoutPracticeCloneInput = {
    where: CloneDiscussionScalarWhereInput
    data: XOR<CloneDiscussionUpdateManyMutationInput, CloneDiscussionUncheckedUpdateManyWithoutPracticeCloneInput>
  }

  export type PracticeCloneCreateWithoutPracticeAnswersInput = {
    cloneName: string
    filename: string
    originalName: string
    description?: string | null
    isActive?: boolean
    uploadDate?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    userProgress?: UserPracticeProgressCreateNestedManyWithoutPracticeCloneInput
    cloneDiscussions?: CloneDiscussionCreateNestedManyWithoutPracticeCloneInput
  }

  export type PracticeCloneUncheckedCreateWithoutPracticeAnswersInput = {
    id?: number
    cloneName: string
    filename: string
    originalName: string
    description?: string | null
    isActive?: boolean
    uploadDate?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    userProgress?: UserPracticeProgressUncheckedCreateNestedManyWithoutPracticeCloneInput
    cloneDiscussions?: CloneDiscussionUncheckedCreateNestedManyWithoutPracticeCloneInput
  }

  export type PracticeCloneCreateOrConnectWithoutPracticeAnswersInput = {
    where: PracticeCloneWhereUniqueInput
    create: XOR<PracticeCloneCreateWithoutPracticeAnswersInput, PracticeCloneUncheckedCreateWithoutPracticeAnswersInput>
  }

  export type PracticeCloneUpsertWithoutPracticeAnswersInput = {
    update: XOR<PracticeCloneUpdateWithoutPracticeAnswersInput, PracticeCloneUncheckedUpdateWithoutPracticeAnswersInput>
    create: XOR<PracticeCloneCreateWithoutPracticeAnswersInput, PracticeCloneUncheckedCreateWithoutPracticeAnswersInput>
    where?: PracticeCloneWhereInput
  }

  export type PracticeCloneUpdateToOneWithWhereWithoutPracticeAnswersInput = {
    where?: PracticeCloneWhereInput
    data: XOR<PracticeCloneUpdateWithoutPracticeAnswersInput, PracticeCloneUncheckedUpdateWithoutPracticeAnswersInput>
  }

  export type PracticeCloneUpdateWithoutPracticeAnswersInput = {
    cloneName?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    originalName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    uploadDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userProgress?: UserPracticeProgressUpdateManyWithoutPracticeCloneNestedInput
    cloneDiscussions?: CloneDiscussionUpdateManyWithoutPracticeCloneNestedInput
  }

  export type PracticeCloneUncheckedUpdateWithoutPracticeAnswersInput = {
    id?: IntFieldUpdateOperationsInput | number
    cloneName?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    originalName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    uploadDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userProgress?: UserPracticeProgressUncheckedUpdateManyWithoutPracticeCloneNestedInput
    cloneDiscussions?: CloneDiscussionUncheckedUpdateManyWithoutPracticeCloneNestedInput
  }

  export type UserCreateWithoutPracticeProgressInput = {
    email: string
    password: string
    name: string
    role: string
    status?: string
    resetToken?: string | null
    resetTokenExpiry?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    school?: SchoolCreateNestedOneWithoutUsersInput
    demographics?: DemographicsCreateNestedOneWithoutUserInput
    assignedFiles?: UploadedFileCreateNestedManyWithoutAssignedToInput
    uploadedFiles?: UploadedFileCreateNestedManyWithoutUploadedByInput
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    receivedMessages?: MessageCreateNestedManyWithoutRecipientInput
    loginLogs?: LoginLogCreateNestedManyWithoutUserInput
    discussions?: CloneDiscussionCreateNestedManyWithoutStudentInput
    discussionMessagesSent?: DiscussionMessageCreateNestedManyWithoutSenderInput
  }

  export type UserUncheckedCreateWithoutPracticeProgressInput = {
    id?: number
    email: string
    password: string
    name: string
    role: string
    status?: string
    schoolId?: number | null
    resetToken?: string | null
    resetTokenExpiry?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    demographics?: DemographicsUncheckedCreateNestedOneWithoutUserInput
    assignedFiles?: UploadedFileUncheckedCreateNestedManyWithoutAssignedToInput
    uploadedFiles?: UploadedFileUncheckedCreateNestedManyWithoutUploadedByInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    receivedMessages?: MessageUncheckedCreateNestedManyWithoutRecipientInput
    loginLogs?: LoginLogUncheckedCreateNestedManyWithoutUserInput
    discussions?: CloneDiscussionUncheckedCreateNestedManyWithoutStudentInput
    discussionMessagesSent?: DiscussionMessageUncheckedCreateNestedManyWithoutSenderInput
  }

  export type UserCreateOrConnectWithoutPracticeProgressInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutPracticeProgressInput, UserUncheckedCreateWithoutPracticeProgressInput>
  }

  export type PracticeCloneCreateWithoutUserProgressInput = {
    cloneName: string
    filename: string
    originalName: string
    description?: string | null
    isActive?: boolean
    uploadDate?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    practiceAnswers?: PracticeAnswerCreateNestedManyWithoutPracticeCloneInput
    cloneDiscussions?: CloneDiscussionCreateNestedManyWithoutPracticeCloneInput
  }

  export type PracticeCloneUncheckedCreateWithoutUserProgressInput = {
    id?: number
    cloneName: string
    filename: string
    originalName: string
    description?: string | null
    isActive?: boolean
    uploadDate?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    practiceAnswers?: PracticeAnswerUncheckedCreateNestedManyWithoutPracticeCloneInput
    cloneDiscussions?: CloneDiscussionUncheckedCreateNestedManyWithoutPracticeCloneInput
  }

  export type PracticeCloneCreateOrConnectWithoutUserProgressInput = {
    where: PracticeCloneWhereUniqueInput
    create: XOR<PracticeCloneCreateWithoutUserProgressInput, PracticeCloneUncheckedCreateWithoutUserProgressInput>
  }

  export type UserUpsertWithoutPracticeProgressInput = {
    update: XOR<UserUpdateWithoutPracticeProgressInput, UserUncheckedUpdateWithoutPracticeProgressInput>
    create: XOR<UserCreateWithoutPracticeProgressInput, UserUncheckedCreateWithoutPracticeProgressInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutPracticeProgressInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutPracticeProgressInput, UserUncheckedUpdateWithoutPracticeProgressInput>
  }

  export type UserUpdateWithoutPracticeProgressInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    school?: SchoolUpdateOneWithoutUsersNestedInput
    demographics?: DemographicsUpdateOneWithoutUserNestedInput
    assignedFiles?: UploadedFileUpdateManyWithoutAssignedToNestedInput
    uploadedFiles?: UploadedFileUpdateManyWithoutUploadedByNestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    receivedMessages?: MessageUpdateManyWithoutRecipientNestedInput
    loginLogs?: LoginLogUpdateManyWithoutUserNestedInput
    discussions?: CloneDiscussionUpdateManyWithoutStudentNestedInput
    discussionMessagesSent?: DiscussionMessageUpdateManyWithoutSenderNestedInput
  }

  export type UserUncheckedUpdateWithoutPracticeProgressInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    schoolId?: NullableIntFieldUpdateOperationsInput | number | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    demographics?: DemographicsUncheckedUpdateOneWithoutUserNestedInput
    assignedFiles?: UploadedFileUncheckedUpdateManyWithoutAssignedToNestedInput
    uploadedFiles?: UploadedFileUncheckedUpdateManyWithoutUploadedByNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    receivedMessages?: MessageUncheckedUpdateManyWithoutRecipientNestedInput
    loginLogs?: LoginLogUncheckedUpdateManyWithoutUserNestedInput
    discussions?: CloneDiscussionUncheckedUpdateManyWithoutStudentNestedInput
    discussionMessagesSent?: DiscussionMessageUncheckedUpdateManyWithoutSenderNestedInput
  }

  export type PracticeCloneUpsertWithoutUserProgressInput = {
    update: XOR<PracticeCloneUpdateWithoutUserProgressInput, PracticeCloneUncheckedUpdateWithoutUserProgressInput>
    create: XOR<PracticeCloneCreateWithoutUserProgressInput, PracticeCloneUncheckedCreateWithoutUserProgressInput>
    where?: PracticeCloneWhereInput
  }

  export type PracticeCloneUpdateToOneWithWhereWithoutUserProgressInput = {
    where?: PracticeCloneWhereInput
    data: XOR<PracticeCloneUpdateWithoutUserProgressInput, PracticeCloneUncheckedUpdateWithoutUserProgressInput>
  }

  export type PracticeCloneUpdateWithoutUserProgressInput = {
    cloneName?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    originalName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    uploadDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    practiceAnswers?: PracticeAnswerUpdateManyWithoutPracticeCloneNestedInput
    cloneDiscussions?: CloneDiscussionUpdateManyWithoutPracticeCloneNestedInput
  }

  export type PracticeCloneUncheckedUpdateWithoutUserProgressInput = {
    id?: IntFieldUpdateOperationsInput | number
    cloneName?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    originalName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    uploadDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    practiceAnswers?: PracticeAnswerUncheckedUpdateManyWithoutPracticeCloneNestedInput
    cloneDiscussions?: CloneDiscussionUncheckedUpdateManyWithoutPracticeCloneNestedInput
  }

  export type AnalysisQuestionCreateWithoutHelpTopicInput = {
    id?: string
    step: string
    text: string
    type: string
    options?: string | null
    required?: boolean
    order?: number
    conditionalLogic?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AnalysisQuestionUncheckedCreateWithoutHelpTopicInput = {
    id?: string
    step: string
    text: string
    type: string
    options?: string | null
    required?: boolean
    order?: number
    conditionalLogic?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AnalysisQuestionCreateOrConnectWithoutHelpTopicInput = {
    where: AnalysisQuestionWhereUniqueInput
    create: XOR<AnalysisQuestionCreateWithoutHelpTopicInput, AnalysisQuestionUncheckedCreateWithoutHelpTopicInput>
  }

  export type AnalysisQuestionUpsertWithoutHelpTopicInput = {
    update: XOR<AnalysisQuestionUpdateWithoutHelpTopicInput, AnalysisQuestionUncheckedUpdateWithoutHelpTopicInput>
    create: XOR<AnalysisQuestionCreateWithoutHelpTopicInput, AnalysisQuestionUncheckedCreateWithoutHelpTopicInput>
    where?: AnalysisQuestionWhereInput
  }

  export type AnalysisQuestionUpdateToOneWithWhereWithoutHelpTopicInput = {
    where?: AnalysisQuestionWhereInput
    data: XOR<AnalysisQuestionUpdateWithoutHelpTopicInput, AnalysisQuestionUncheckedUpdateWithoutHelpTopicInput>
  }

  export type AnalysisQuestionUpdateWithoutHelpTopicInput = {
    id?: StringFieldUpdateOperationsInput | string
    step?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    options?: NullableStringFieldUpdateOperationsInput | string | null
    required?: BoolFieldUpdateOperationsInput | boolean
    order?: IntFieldUpdateOperationsInput | number
    conditionalLogic?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AnalysisQuestionUncheckedUpdateWithoutHelpTopicInput = {
    id?: StringFieldUpdateOperationsInput | string
    step?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    options?: NullableStringFieldUpdateOperationsInput | string | null
    required?: BoolFieldUpdateOperationsInput | boolean
    order?: IntFieldUpdateOperationsInput | number
    conditionalLogic?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UploadedFileCreateManyAssignedToInput = {
    id?: number
    filename: string
    originalName: string
    cloneName: string
    size: string
    uploadDate: string
    status?: string
    progress?: number
    analysisData?: string | null
    uploadedById: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UploadedFileCreateManyUploadedByInput = {
    id?: number
    filename: string
    originalName: string
    cloneName: string
    size: string
    uploadDate: string
    status?: string
    progress?: number
    analysisData?: string | null
    assignedToId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MessageCreateManySenderInput = {
    id?: number
    subject: string
    content: string
    messageType?: string
    isRead?: boolean
    recipientId: number
    cloneId?: number | null
    cloneProgress?: number | null
    currentStep?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isGroupMessage?: boolean | null
    groupParticipants?: string | null
  }

  export type MessageCreateManyRecipientInput = {
    id?: number
    subject: string
    content: string
    messageType?: string
    isRead?: boolean
    senderId: number
    cloneId?: number | null
    cloneProgress?: number | null
    currentStep?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isGroupMessage?: boolean | null
    groupParticipants?: string | null
  }

  export type UserPracticeProgressCreateManyUserInput = {
    id?: number
    practiceCloneId: number
    progress?: number
    answers?: string | null
    currentStep?: string
    status?: string
    lastSaved?: Date | string | null
    submittedAt?: Date | string | null
    reviewComments?: string | null
    reviewScore?: number | null
    lastReviewed?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LoginLogCreateManyUserInput = {
    id?: number
    loginTime?: Date | string
    ipAddress?: string | null
    userAgent?: string | null
    success?: boolean
    createdAt?: Date | string
  }

  export type CloneDiscussionCreateManyStudentInput = {
    id?: number
    cloneId?: number | null
    practiceCloneId?: number | null
    title: string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    lastMessageAt?: Date | string
  }

  export type DiscussionMessageCreateManySenderInput = {
    id?: number
    discussionId: number
    content: string
    messageType?: string
    readBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UploadedFileUpdateWithoutAssignedToInput = {
    filename?: StringFieldUpdateOperationsInput | string
    originalName?: StringFieldUpdateOperationsInput | string
    cloneName?: StringFieldUpdateOperationsInput | string
    size?: StringFieldUpdateOperationsInput | string
    uploadDate?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    progress?: IntFieldUpdateOperationsInput | number
    analysisData?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    uploadedBy?: UserUpdateOneRequiredWithoutUploadedFilesNestedInput
    messages?: MessageUpdateManyWithoutCloneNestedInput
    cloneDiscussions?: CloneDiscussionUpdateManyWithoutCloneNestedInput
  }

  export type UploadedFileUncheckedUpdateWithoutAssignedToInput = {
    id?: IntFieldUpdateOperationsInput | number
    filename?: StringFieldUpdateOperationsInput | string
    originalName?: StringFieldUpdateOperationsInput | string
    cloneName?: StringFieldUpdateOperationsInput | string
    size?: StringFieldUpdateOperationsInput | string
    uploadDate?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    progress?: IntFieldUpdateOperationsInput | number
    analysisData?: NullableStringFieldUpdateOperationsInput | string | null
    uploadedById?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    messages?: MessageUncheckedUpdateManyWithoutCloneNestedInput
    cloneDiscussions?: CloneDiscussionUncheckedUpdateManyWithoutCloneNestedInput
  }

  export type UploadedFileUncheckedUpdateManyWithoutAssignedToInput = {
    id?: IntFieldUpdateOperationsInput | number
    filename?: StringFieldUpdateOperationsInput | string
    originalName?: StringFieldUpdateOperationsInput | string
    cloneName?: StringFieldUpdateOperationsInput | string
    size?: StringFieldUpdateOperationsInput | string
    uploadDate?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    progress?: IntFieldUpdateOperationsInput | number
    analysisData?: NullableStringFieldUpdateOperationsInput | string | null
    uploadedById?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UploadedFileUpdateWithoutUploadedByInput = {
    filename?: StringFieldUpdateOperationsInput | string
    originalName?: StringFieldUpdateOperationsInput | string
    cloneName?: StringFieldUpdateOperationsInput | string
    size?: StringFieldUpdateOperationsInput | string
    uploadDate?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    progress?: IntFieldUpdateOperationsInput | number
    analysisData?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedTo?: UserUpdateOneWithoutAssignedFilesNestedInput
    messages?: MessageUpdateManyWithoutCloneNestedInput
    cloneDiscussions?: CloneDiscussionUpdateManyWithoutCloneNestedInput
  }

  export type UploadedFileUncheckedUpdateWithoutUploadedByInput = {
    id?: IntFieldUpdateOperationsInput | number
    filename?: StringFieldUpdateOperationsInput | string
    originalName?: StringFieldUpdateOperationsInput | string
    cloneName?: StringFieldUpdateOperationsInput | string
    size?: StringFieldUpdateOperationsInput | string
    uploadDate?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    progress?: IntFieldUpdateOperationsInput | number
    analysisData?: NullableStringFieldUpdateOperationsInput | string | null
    assignedToId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    messages?: MessageUncheckedUpdateManyWithoutCloneNestedInput
    cloneDiscussions?: CloneDiscussionUncheckedUpdateManyWithoutCloneNestedInput
  }

  export type UploadedFileUncheckedUpdateManyWithoutUploadedByInput = {
    id?: IntFieldUpdateOperationsInput | number
    filename?: StringFieldUpdateOperationsInput | string
    originalName?: StringFieldUpdateOperationsInput | string
    cloneName?: StringFieldUpdateOperationsInput | string
    size?: StringFieldUpdateOperationsInput | string
    uploadDate?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    progress?: IntFieldUpdateOperationsInput | number
    analysisData?: NullableStringFieldUpdateOperationsInput | string | null
    assignedToId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageUpdateWithoutSenderInput = {
    subject?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    messageType?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    cloneProgress?: NullableIntFieldUpdateOperationsInput | number | null
    currentStep?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isGroupMessage?: NullableBoolFieldUpdateOperationsInput | boolean | null
    groupParticipants?: NullableStringFieldUpdateOperationsInput | string | null
    recipient?: UserUpdateOneRequiredWithoutReceivedMessagesNestedInput
    clone?: UploadedFileUpdateOneWithoutMessagesNestedInput
  }

  export type MessageUncheckedUpdateWithoutSenderInput = {
    id?: IntFieldUpdateOperationsInput | number
    subject?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    messageType?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    recipientId?: IntFieldUpdateOperationsInput | number
    cloneId?: NullableIntFieldUpdateOperationsInput | number | null
    cloneProgress?: NullableIntFieldUpdateOperationsInput | number | null
    currentStep?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isGroupMessage?: NullableBoolFieldUpdateOperationsInput | boolean | null
    groupParticipants?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type MessageUncheckedUpdateManyWithoutSenderInput = {
    id?: IntFieldUpdateOperationsInput | number
    subject?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    messageType?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    recipientId?: IntFieldUpdateOperationsInput | number
    cloneId?: NullableIntFieldUpdateOperationsInput | number | null
    cloneProgress?: NullableIntFieldUpdateOperationsInput | number | null
    currentStep?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isGroupMessage?: NullableBoolFieldUpdateOperationsInput | boolean | null
    groupParticipants?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type MessageUpdateWithoutRecipientInput = {
    subject?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    messageType?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    cloneProgress?: NullableIntFieldUpdateOperationsInput | number | null
    currentStep?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isGroupMessage?: NullableBoolFieldUpdateOperationsInput | boolean | null
    groupParticipants?: NullableStringFieldUpdateOperationsInput | string | null
    sender?: UserUpdateOneRequiredWithoutSentMessagesNestedInput
    clone?: UploadedFileUpdateOneWithoutMessagesNestedInput
  }

  export type MessageUncheckedUpdateWithoutRecipientInput = {
    id?: IntFieldUpdateOperationsInput | number
    subject?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    messageType?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    senderId?: IntFieldUpdateOperationsInput | number
    cloneId?: NullableIntFieldUpdateOperationsInput | number | null
    cloneProgress?: NullableIntFieldUpdateOperationsInput | number | null
    currentStep?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isGroupMessage?: NullableBoolFieldUpdateOperationsInput | boolean | null
    groupParticipants?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type MessageUncheckedUpdateManyWithoutRecipientInput = {
    id?: IntFieldUpdateOperationsInput | number
    subject?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    messageType?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    senderId?: IntFieldUpdateOperationsInput | number
    cloneId?: NullableIntFieldUpdateOperationsInput | number | null
    cloneProgress?: NullableIntFieldUpdateOperationsInput | number | null
    currentStep?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isGroupMessage?: NullableBoolFieldUpdateOperationsInput | boolean | null
    groupParticipants?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserPracticeProgressUpdateWithoutUserInput = {
    progress?: IntFieldUpdateOperationsInput | number
    answers?: NullableStringFieldUpdateOperationsInput | string | null
    currentStep?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    lastSaved?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reviewComments?: NullableStringFieldUpdateOperationsInput | string | null
    reviewScore?: NullableIntFieldUpdateOperationsInput | number | null
    lastReviewed?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    practiceClone?: PracticeCloneUpdateOneRequiredWithoutUserProgressNestedInput
  }

  export type UserPracticeProgressUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    practiceCloneId?: IntFieldUpdateOperationsInput | number
    progress?: IntFieldUpdateOperationsInput | number
    answers?: NullableStringFieldUpdateOperationsInput | string | null
    currentStep?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    lastSaved?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reviewComments?: NullableStringFieldUpdateOperationsInput | string | null
    reviewScore?: NullableIntFieldUpdateOperationsInput | number | null
    lastReviewed?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserPracticeProgressUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    practiceCloneId?: IntFieldUpdateOperationsInput | number
    progress?: IntFieldUpdateOperationsInput | number
    answers?: NullableStringFieldUpdateOperationsInput | string | null
    currentStep?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    lastSaved?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reviewComments?: NullableStringFieldUpdateOperationsInput | string | null
    reviewScore?: NullableIntFieldUpdateOperationsInput | number | null
    lastReviewed?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LoginLogUpdateWithoutUserInput = {
    loginTime?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    success?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LoginLogUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    loginTime?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    success?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LoginLogUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    loginTime?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    success?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CloneDiscussionUpdateWithoutStudentInput = {
    title?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastMessageAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clone?: UploadedFileUpdateOneWithoutCloneDiscussionsNestedInput
    practiceClone?: PracticeCloneUpdateOneWithoutCloneDiscussionsNestedInput
    messages?: DiscussionMessageUpdateManyWithoutDiscussionNestedInput
  }

  export type CloneDiscussionUncheckedUpdateWithoutStudentInput = {
    id?: IntFieldUpdateOperationsInput | number
    cloneId?: NullableIntFieldUpdateOperationsInput | number | null
    practiceCloneId?: NullableIntFieldUpdateOperationsInput | number | null
    title?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastMessageAt?: DateTimeFieldUpdateOperationsInput | Date | string
    messages?: DiscussionMessageUncheckedUpdateManyWithoutDiscussionNestedInput
  }

  export type CloneDiscussionUncheckedUpdateManyWithoutStudentInput = {
    id?: IntFieldUpdateOperationsInput | number
    cloneId?: NullableIntFieldUpdateOperationsInput | number | null
    practiceCloneId?: NullableIntFieldUpdateOperationsInput | number | null
    title?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastMessageAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DiscussionMessageUpdateWithoutSenderInput = {
    content?: StringFieldUpdateOperationsInput | string
    messageType?: StringFieldUpdateOperationsInput | string
    readBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    discussion?: CloneDiscussionUpdateOneRequiredWithoutMessagesNestedInput
  }

  export type DiscussionMessageUncheckedUpdateWithoutSenderInput = {
    id?: IntFieldUpdateOperationsInput | number
    discussionId?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    messageType?: StringFieldUpdateOperationsInput | string
    readBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DiscussionMessageUncheckedUpdateManyWithoutSenderInput = {
    id?: IntFieldUpdateOperationsInput | number
    discussionId?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    messageType?: StringFieldUpdateOperationsInput | string
    readBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateManySchoolInput = {
    id?: number
    email: string
    password: string
    name: string
    role: string
    status?: string
    resetToken?: string | null
    resetTokenExpiry?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUpdateWithoutSchoolInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    demographics?: DemographicsUpdateOneWithoutUserNestedInput
    assignedFiles?: UploadedFileUpdateManyWithoutAssignedToNestedInput
    uploadedFiles?: UploadedFileUpdateManyWithoutUploadedByNestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    receivedMessages?: MessageUpdateManyWithoutRecipientNestedInput
    practiceProgress?: UserPracticeProgressUpdateManyWithoutUserNestedInput
    loginLogs?: LoginLogUpdateManyWithoutUserNestedInput
    discussions?: CloneDiscussionUpdateManyWithoutStudentNestedInput
    discussionMessagesSent?: DiscussionMessageUpdateManyWithoutSenderNestedInput
  }

  export type UserUncheckedUpdateWithoutSchoolInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    demographics?: DemographicsUncheckedUpdateOneWithoutUserNestedInput
    assignedFiles?: UploadedFileUncheckedUpdateManyWithoutAssignedToNestedInput
    uploadedFiles?: UploadedFileUncheckedUpdateManyWithoutUploadedByNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    receivedMessages?: MessageUncheckedUpdateManyWithoutRecipientNestedInput
    practiceProgress?: UserPracticeProgressUncheckedUpdateManyWithoutUserNestedInput
    loginLogs?: LoginLogUncheckedUpdateManyWithoutUserNestedInput
    discussions?: CloneDiscussionUncheckedUpdateManyWithoutStudentNestedInput
    discussionMessagesSent?: DiscussionMessageUncheckedUpdateManyWithoutSenderNestedInput
  }

  export type UserUncheckedUpdateManyWithoutSchoolInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HelpTopicCreateManyAnalysisQuestionInput = {
    id?: string
    title: string
    videoBoxUrl: string
    helpDocumentUrl: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type HelpTopicUpdateWithoutAnalysisQuestionInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    videoBoxUrl?: StringFieldUpdateOperationsInput | string
    helpDocumentUrl?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HelpTopicUncheckedUpdateWithoutAnalysisQuestionInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    videoBoxUrl?: StringFieldUpdateOperationsInput | string
    helpDocumentUrl?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HelpTopicUncheckedUpdateManyWithoutAnalysisQuestionInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    videoBoxUrl?: StringFieldUpdateOperationsInput | string
    helpDocumentUrl?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageCreateManyCloneInput = {
    id?: number
    subject: string
    content: string
    messageType?: string
    isRead?: boolean
    senderId: number
    recipientId: number
    cloneProgress?: number | null
    currentStep?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isGroupMessage?: boolean | null
    groupParticipants?: string | null
  }

  export type CloneDiscussionCreateManyCloneInput = {
    id?: number
    studentId: number
    practiceCloneId?: number | null
    title: string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    lastMessageAt?: Date | string
  }

  export type MessageUpdateWithoutCloneInput = {
    subject?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    messageType?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    cloneProgress?: NullableIntFieldUpdateOperationsInput | number | null
    currentStep?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isGroupMessage?: NullableBoolFieldUpdateOperationsInput | boolean | null
    groupParticipants?: NullableStringFieldUpdateOperationsInput | string | null
    sender?: UserUpdateOneRequiredWithoutSentMessagesNestedInput
    recipient?: UserUpdateOneRequiredWithoutReceivedMessagesNestedInput
  }

  export type MessageUncheckedUpdateWithoutCloneInput = {
    id?: IntFieldUpdateOperationsInput | number
    subject?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    messageType?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    senderId?: IntFieldUpdateOperationsInput | number
    recipientId?: IntFieldUpdateOperationsInput | number
    cloneProgress?: NullableIntFieldUpdateOperationsInput | number | null
    currentStep?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isGroupMessage?: NullableBoolFieldUpdateOperationsInput | boolean | null
    groupParticipants?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type MessageUncheckedUpdateManyWithoutCloneInput = {
    id?: IntFieldUpdateOperationsInput | number
    subject?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    messageType?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    senderId?: IntFieldUpdateOperationsInput | number
    recipientId?: IntFieldUpdateOperationsInput | number
    cloneProgress?: NullableIntFieldUpdateOperationsInput | number | null
    currentStep?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isGroupMessage?: NullableBoolFieldUpdateOperationsInput | boolean | null
    groupParticipants?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CloneDiscussionUpdateWithoutCloneInput = {
    title?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastMessageAt?: DateTimeFieldUpdateOperationsInput | Date | string
    student?: UserUpdateOneRequiredWithoutDiscussionsNestedInput
    practiceClone?: PracticeCloneUpdateOneWithoutCloneDiscussionsNestedInput
    messages?: DiscussionMessageUpdateManyWithoutDiscussionNestedInput
  }

  export type CloneDiscussionUncheckedUpdateWithoutCloneInput = {
    id?: IntFieldUpdateOperationsInput | number
    studentId?: IntFieldUpdateOperationsInput | number
    practiceCloneId?: NullableIntFieldUpdateOperationsInput | number | null
    title?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastMessageAt?: DateTimeFieldUpdateOperationsInput | Date | string
    messages?: DiscussionMessageUncheckedUpdateManyWithoutDiscussionNestedInput
  }

  export type CloneDiscussionUncheckedUpdateManyWithoutCloneInput = {
    id?: IntFieldUpdateOperationsInput | number
    studentId?: IntFieldUpdateOperationsInput | number
    practiceCloneId?: NullableIntFieldUpdateOperationsInput | number | null
    title?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastMessageAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DiscussionMessageCreateManyDiscussionInput = {
    id?: number
    senderId: number
    content: string
    messageType?: string
    readBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DiscussionMessageUpdateWithoutDiscussionInput = {
    content?: StringFieldUpdateOperationsInput | string
    messageType?: StringFieldUpdateOperationsInput | string
    readBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sender?: UserUpdateOneRequiredWithoutDiscussionMessagesSentNestedInput
  }

  export type DiscussionMessageUncheckedUpdateWithoutDiscussionInput = {
    id?: IntFieldUpdateOperationsInput | number
    senderId?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    messageType?: StringFieldUpdateOperationsInput | string
    readBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DiscussionMessageUncheckedUpdateManyWithoutDiscussionInput = {
    id?: IntFieldUpdateOperationsInput | number
    senderId?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    messageType?: StringFieldUpdateOperationsInput | string
    readBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PracticeAnswerCreateManyPracticeCloneInput = {
    id?: string
    questionId: string
    correctAnswer: string
    explanation?: string | null
  }

  export type UserPracticeProgressCreateManyPracticeCloneInput = {
    id?: number
    userId: number
    progress?: number
    answers?: string | null
    currentStep?: string
    status?: string
    lastSaved?: Date | string | null
    submittedAt?: Date | string | null
    reviewComments?: string | null
    reviewScore?: number | null
    lastReviewed?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CloneDiscussionCreateManyPracticeCloneInput = {
    id?: number
    studentId: number
    cloneId?: number | null
    title: string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    lastMessageAt?: Date | string
  }

  export type PracticeAnswerUpdateWithoutPracticeCloneInput = {
    id?: StringFieldUpdateOperationsInput | string
    questionId?: StringFieldUpdateOperationsInput | string
    correctAnswer?: StringFieldUpdateOperationsInput | string
    explanation?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PracticeAnswerUncheckedUpdateWithoutPracticeCloneInput = {
    id?: StringFieldUpdateOperationsInput | string
    questionId?: StringFieldUpdateOperationsInput | string
    correctAnswer?: StringFieldUpdateOperationsInput | string
    explanation?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PracticeAnswerUncheckedUpdateManyWithoutPracticeCloneInput = {
    id?: StringFieldUpdateOperationsInput | string
    questionId?: StringFieldUpdateOperationsInput | string
    correctAnswer?: StringFieldUpdateOperationsInput | string
    explanation?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserPracticeProgressUpdateWithoutPracticeCloneInput = {
    progress?: IntFieldUpdateOperationsInput | number
    answers?: NullableStringFieldUpdateOperationsInput | string | null
    currentStep?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    lastSaved?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reviewComments?: NullableStringFieldUpdateOperationsInput | string | null
    reviewScore?: NullableIntFieldUpdateOperationsInput | number | null
    lastReviewed?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutPracticeProgressNestedInput
  }

  export type UserPracticeProgressUncheckedUpdateWithoutPracticeCloneInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    progress?: IntFieldUpdateOperationsInput | number
    answers?: NullableStringFieldUpdateOperationsInput | string | null
    currentStep?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    lastSaved?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reviewComments?: NullableStringFieldUpdateOperationsInput | string | null
    reviewScore?: NullableIntFieldUpdateOperationsInput | number | null
    lastReviewed?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserPracticeProgressUncheckedUpdateManyWithoutPracticeCloneInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    progress?: IntFieldUpdateOperationsInput | number
    answers?: NullableStringFieldUpdateOperationsInput | string | null
    currentStep?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    lastSaved?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reviewComments?: NullableStringFieldUpdateOperationsInput | string | null
    reviewScore?: NullableIntFieldUpdateOperationsInput | number | null
    lastReviewed?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CloneDiscussionUpdateWithoutPracticeCloneInput = {
    title?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastMessageAt?: DateTimeFieldUpdateOperationsInput | Date | string
    student?: UserUpdateOneRequiredWithoutDiscussionsNestedInput
    clone?: UploadedFileUpdateOneWithoutCloneDiscussionsNestedInput
    messages?: DiscussionMessageUpdateManyWithoutDiscussionNestedInput
  }

  export type CloneDiscussionUncheckedUpdateWithoutPracticeCloneInput = {
    id?: IntFieldUpdateOperationsInput | number
    studentId?: IntFieldUpdateOperationsInput | number
    cloneId?: NullableIntFieldUpdateOperationsInput | number | null
    title?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastMessageAt?: DateTimeFieldUpdateOperationsInput | Date | string
    messages?: DiscussionMessageUncheckedUpdateManyWithoutDiscussionNestedInput
  }

  export type CloneDiscussionUncheckedUpdateManyWithoutPracticeCloneInput = {
    id?: IntFieldUpdateOperationsInput | number
    studentId?: IntFieldUpdateOperationsInput | number
    cloneId?: NullableIntFieldUpdateOperationsInput | number | null
    title?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastMessageAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}